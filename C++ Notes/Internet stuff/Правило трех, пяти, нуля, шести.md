В общем случае эти правила можно описать следующим образом:
"Если программист явно объявил что-то из конструктора\\деструктора\\конструктора копирования\\конструктора перемещения\\оператора присвоения копированием\\оператором присвоения перемещением - то требуется добавить так же и остальные специальные методы". Основная суть заключается в том, что если класс требует что-то не стандартного от компилятора - возможно в классе содержаться какие-то специфичные вещи, которые могут потребовать и остальные дополнительные определения


##### Правило трёх 
Правило (так же встречается как "Закон большой тройки" или "большая тройка"), которое гласит, что если класс или структура определяет один из следующих методов 
* деструктор, 
* конструктор копирования, 
* оператор присваивания копирования, 
то они должны явным образом определить все три метода. Эти три метода являются особыми членами-функциями, автоматически создаваемые компилятором в случае отсутствия их явного объявления программистом. Если один из них определен программистом, то это означает что версия, сгенерированная компилятором, не удовлетворяет потребностям класса в одном случае, и, вероятно, не удовлетворит в остальных случаях. 
Поправка к этому правилу заключается в том, что если используется RAII, то используемый деструктор может оставаться неопределённым (Закон больгой двойки)
##### Правило пяти 
Расширенние правила трех после появления в С++11 семантики перемещения: к трем явно объявленным методам добавилось еще и 
* конструктор перемешения 
* оператор присваивания перемещеием

##### Правило нуля
Правило, которое гласит, что все должны стремиться писать такие классы, которые не требуют явного определения ни одного из специальных членов (конструктор копирования, оператор присваивания копированием, конструктор перемещения, оператор присваивания перемещения и деструктор). Это достигается путем использования стандартных библиотек и [[RAII]]

##### Правило шести
Как можно догадаться, это правило пяти + конструктор
