Исключения - это типы, сообщающие об ошибке. При возникновении ошибки генерирует исключение,  после которого оно переходит в состояние полета. Когда исключение находиться в состоянии полета, программа останавливает нормальное выполнение и ищет обработчик исключений, который может управлять исключение в полете. Объекты, которые выпадают из области видимости во время этого процесса уничтожаются. Это особенно полезно в ситуациях, когда н е существует хорошего способа локальной обработки ошибки, например, в конструкторе Другой вариант оповещения об ошибках - возврат кода ошибки из части прототипа функции. 

Чтобы вызвать исключение используется словцо `throw`, за которым следует бросаемый объект. Большинство объектов являются бросаемыми, однако рекомендуется использовать одни из исключений из stdlib, например `std::runtime_error` из `#include <stdexcept>` 
```c++
throw std::runtime_error{"execption"};
```

Блоки `try-catch` используются для установки обработчиков исключений. Внутри `try` размещается код, который может вызывать исключение, внутри `catch` - обработчик. В `catch` можно указать тип выброшенного исключения, (`std::exception` выключает оба `std::logical_error` и `std::runtim_error`). С одним `try` можно ставить несколько `catch`. В блоке `catch` можно использовать `throw`  чтобы возобновить поиск подходящего обработчика исключения. Это называется <u>перебрасыванием исключения </u>
```c++
try
{

}
catch (std::exception& ex)
{
// Обрабатывает std::logic_error поскольку он наследуется от std::exception
}
catch (...)
{
// Обрабатывает любое исключение, даже 'z'
}
```
С ключевым словом `noexcept` можно пометить функцию, которая в теории не может вызывать исключения. В случае, если в такой функции возникает исключение - среда выполнения вызовет `std::terminate`

Среда выполнения ищет ближайший обработчик исключений для выброшенного исключения. Если соответствующий обработчик не найден - среда выполнения раскручивает стек вызова, пока не найдет подходящий обработчик. 

Исключения добавляют излишнюю обвязку вокруг кода, которая может быть лишней. 

## Альтернатива исключениям 
В качестве альтернативы можно обрабатывать "исключения" вручную. 

Во первых, можно вручную применить инварианты класса, предоставив некоторый метод, который сообщает - могут ли инварианты класса быть установлены 
```c++
class 
{
public:
	void connect ()
    {
     // Если is_connected() вернул true - повторное
     // подключение не к чему
    }
private: 
	bool is_connected() {}
};
```

Вторая стратегия - возвращать несколько значений с помощью объявления структурированной привязки (языковой функции, которая позволяет возвращать несколько значений из вызова функций). Эту функцию можно использовать для возврата флагов успеха вместе с обычным возвращаемым значением 
```c++
struct Result 
{
	HumptyDumpty hd;
	bool success;
};

Result MakeHumpty() 
{
 HumptyDumpty hd {};
 bool is_valid;
 // Проверка правильности hd и установка соответствующего значения is_valid
 return { hd, is_valid };
}
```

Сначала объявляется POD, который содержит класс и флаг успеха. Замет определяется функция make, которая создает и проверяет класс. Такие методы называются <u>фабричными</u>, поскольку их целью является инициализация объектов.