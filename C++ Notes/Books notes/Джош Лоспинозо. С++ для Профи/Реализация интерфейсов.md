Чтобы объявить интерфейс - нужно объявить чисто виртуальный класс. Чтобы реализовать интерфейс - наследоваться от него. Рекомендуется помечать методы реализации `override`. Это говорит о намерении переопределить виртуальную функцию и помогает компилятор избавить разработчика от простых ошибок. 

Потребитель может иметь дело только с ссылками или указателями на интерфейсы. Компилятор не может заранее знать, сколько памяти выделить для базового типа: если компилятор может знать базовый тип, лучше использовать шаблоны. Существует два варианта настройки элементов:
+ внедрение через конструктор - обычно используется ссылка на интерфейс. Поскольку ссылки не могут быть повторно установлены, они не будет меняться в течении всего срока жизни объекта 
`Bank(Logger& logger) : logger{ logger }{}`
+ Внедрение через свойство. Внедрение через свойство позволяет использовать метод для указания члена-указателя. Это позволяет изменить объект, на который направлен указатель.
`void set_logger(Logger* new_logger) { logger = new_logger; }`

Внедрение через конструктор используется, когда введеное поле не изменится в течении всего срока службы объекта. Если нужна гибкость изменения поля, то используется внедрение через свойство.