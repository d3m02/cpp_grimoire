```c++
struct BaseClass {};
struct DerivedClasss : BaseClass {};

void belong (BaseClass& base) {}

int main() 
{
	DerivedClass derived;
	belong(derived);
}
```
`DerivedClass` является производным от `BaseClass`. Функция `belong` принимает аргумент-ссылку на `BaseClass`, ее можно вызвать для `DerivedClass` так как `DerivedClass` является производным от `BaseClass`. Обратное не верное. 

Основная причина, по которой нужно наследовать класс - это наследование его членов. Производные классы наследуют неприватные члены от своих базовых классов. Предполагаемое преимущество наследования членов состоит в том, что можно определить функциональность один раз в базовом классе и не повторять её в производных классах. К сожалению, опыт убедил многих в сообществе программистов избегать наследование членов, потому что он может легко привести к хрупкому и трудному для понимания колу по сравнению с полиморфизмом на основе [[Наследование, композиция, агрегация#Композиция|композиции]]. 

## Виртуальные методы
Добавляя `virtual` в определении метода мы объявляем что должна использовать реализация в производном классе, если она предоставлена. В рамках реализации советуется добавлять ключевое слово `override` для удобства чтения. Реализация базового класса используется через экземпляр базового класса. Реализация производного класса используется когда присутствует экземпляр производного класса, даже если взаимодействие с ним осуществляется через ссылку базового класса 
```c++
BaseClass base;
DerivedClass derived;
BaseClass& ref = derived;

printf("BaseClass: %s\n", base.message());          // Base
printf("DerivedClass: %s\n", derived.message());    // Derived
printf("BaseClass&: %s\n", ref.message());          // Derived
```
Если нужно, что производный класс реализовывал метод - можно добавить `=0` к определению метода. создав так чисто виртуальный метод. Нельзя создавать экземпляры классов, которые содержат какие-либо чисто виртуальные методы. 

Виртуальные методы могут повлечь издержки во время выполнения, хотя обычно они не больший (в приделах 25% от обычного вызова функции) из-за таблицы виртуальных методов, которые содержат указатели на функции. Во время выполнения потребитель интерфейса обычно не знает его базовый тип, но он знает, как вызывать методы интерфейса благодаря `vtable`. В некоторых случаях редактор связей может обнаруживать все виды использования интерфейса и девиртуализировать вызов функции= - это удаляет вызов функции из `vtable`  и таким образом устраняет связанные с этим затраты времени выполнения. 

Чисто виртуальные классы - это классы, которые содержат только чисто виртуальные методы. В C++ интерфейсы всегда являются чисто виртуальными классами. Обычно виртуальные деструктор добавляются в интерфейсы для предотвращения утечки ресурсов, т.к. при удалении указателя вызывается деструктор базового класса, а не производного и ресурсы могут потеряться. 