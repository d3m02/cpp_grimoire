## Constructors
Constructors are special member functions of a class; they are called automatically when an object of the class is created. Compilers can generate a constructor if the class doesn't have one explicitly defined. Constructors are used to initialize data members and perform any necessary setup.  
If we don't explicitly initialize a class's members, they will be default-initialized. If the member is an object of another class, its default constructor will be called. If the member is of a built-in type, its initial value is undefined.

Beside initializing class members in constructor from C++11 we can initialize them in the class definition 
```c++
class A {
	int num{2}; // initialization in  class definition
	int secondNum;
public:
	A(int in) : secondNum{num * in} {}; // Init in constructor
}
```
> It's not recommended to initialize class member in constructor body since in that case member will be firstly default-initialized and then reassigned. Members order in initialization list recommended to keep in the same order as they definition in class since in that order they will be initialized, init-list can't change that order

 C++ allow to have multiple constructors. Common practice is perform all set-up in some separate function (`init()`/`setup()` etc) and call that function from constructors to reduce amount of duplication of code, in addition if something changed this approach can reduce amount of changes in constructors themselves. 
 ```c++
class Board{
public: 
	Board() { init("guest", "guest");}
	Board(int id) : m_id{id} 
	{
		init ("guest", "guest");
	}
	Board(const std::string& login, 
	      const std::string& pw)
	{ 
		init(login, pw);
	}
	Board(int id, 
	      const std::string& login, 
	      const std::string& pw) : m_id{id} 
	{ 
		init(login, pw);
	}
	
private:
	void init(const std::string& id, const std::string& pw){
		internet.connect();
	    internet.login(id, pw);
	} 

	int m_id{};
}
 ```
From C++11 it's also possible to use constructor in another constructor, it's called "delegating constructor". 
```c++
class Board{
public: 
	Board() : Board({}, "guest", "guest") {}
	Board(int id) : Board(id, "guest", "guest") {}
	Board(const std::string& login, 
	      const std::string& pw) : Board({}, login, pw) {}
	Board(int id, 
	      const std::string& login, 
	      const std::string& pw) : m_id{id} 
	{ 
		internet.connect();
	    internet.login(id, pw);
	}
	
private:
	int m_id{};
}
```

## Copy Constructor 
Copy constructor is a specialized version of the constructor which takes as argument a reference to an object of the same class and uses existing object of the class to initialize the new object. The copy constructor is automatically called: 
* When initialize a new object from an existing object (even when call `{cpp} Test test2 = test1;` - since `test2` is new object - instead `operator=` will be called Copy Constructor. But it doesn't mean that by defining copy constructor - we also change `operator=` - it's different function) 
* When object passed as an argument by value 
* When return from object a local variable by value 
However, compilers can apply RVO/copy elision as optimization to reduce amount of copying (from C++17 copy elision is guarantied is serval cases)

## Assignment Operator 
The assignment operator is a member function `operator=(const T&)`. It's invoked when when assign two object of the class: `y = z` will call `{cpp} y.operator=(z)`. After this statement, the members of `y` will have the same values as those of `z`. The assignment operator takes its argument by const reference and return modified object, usually _non-const_ reference to (`*this`). Main reason why operator return object is to support similar to build-in types chaining (`a = b = c`, firstly will be called `b.operator=(c)` and after `a.operator=(b)`), _non-const_ required for STL containers (again, to maintain similarity with build-in types). 

Assignment operator can be synthesized by compiler, in general synthesized operator will call assignment operator of all the data members. In general we might have to write own assignment operator if require some special work with resources, perform deep copy or avoid modification of some data members (like pointer to allocated memory of descriptor, created in constructor).   


## Shallow and Deep Copying 
Default generated by compiler copy special member function perform copy of class data members, which also appliable for pointers. If for example we have as data member pointer to some memory on heap, special member function will copy only pointer, which mean that two different object will point to one blob of memory. This  called "shallow" copy. Danger of such copy is that if one object remove data by pointer - another object can perform actions on already released memory. To avoid this required to create on copy member functions, which will allocate for second object own blob of memory and copy data from first's object blob of memory (this is called deep copying).

Main things to pay attention - me should ensure that we have enough space to store copied data, release current data, also worth it to check for self-assignment. 
```c++
String& operator=(const String& other) {
	if (&arg == this)
		return *this;
	
	delete[] data; // relase original memory
	data = new char[other.size];
	size = other.size;
	for (int i = 0; i < size; i++)
		data[i] = arg.data[i];
	
	retur *this;
} 
```
> This example have drawbacks. For example, if `new` throw exception - we already removed `data`, meaning that our class might be invalid (at least contain incorrect size). Take a look on [[Chapter 2 - Constructors, Destructors, and Assignment Operators#Item 11 Handle assignment to self in operator=|Item 11 from Effective C++]] 

There is "Rule of Three" which helps to determine when some special member functions need to be implemented.
_If a class needs to implement one of 
* _Copy constructor_
* _Assignment Operator_
* _Destructor_
_Then it probably need to implement the other two as well._
e.g class with pointer member allocated with `new` in constructor and release by `delete` in destructor - copy constructor is needed to perform deep copy when copying and assignment operator is needed to perform deep copy on assignment

## Copy elision 
Copy elision means that the compiler is allowed to skip over a call to the copy constructor in some cases and initialize the target object directly. This usually occurs when copying temporary variables during functions calls; either copying temporary variables into function arguments, or copying temporary variable into the function's return value. 
Usually compiler optimization not changing behavior as if optimization wasn't performed, but for copy elision allowed to change the behavior and might have side effects.

In this example expected two copies - one when return temporary object by value, and second when performing assign construction. In fact, first copy in return space will be elided (this's also known as "Return Value Optimization") and second copy will be elided as well.
```c++
sturct Test {
	Test(){ std::cout << "Default c_tor\n"; };
	Test(const Test& other) }{ std::cout << "Copy c_tor\n"; };
};

Test func() { return Test(); } // create temporary object
Test test = func();
// output will be "Default c_tor"
```

Return Value Optimization is when copy of a returned temporary object is elided, meaning that object instead initialized in return space instead. Also exist "Named Return Value Optimization" - a similar process but for local variables return by value. 

## Conversion Operator 
A class can define a conversion operator - member function which converts an object to some other type. For example the conversion operator below will be called whenever the object is used when an int is expected 
```c++
class Test {
	int i{};
public:
	operator int() const { return i; }
}; 
```
This used for implicit conversion. For example, if class don't have `{cpp} operator<<()` but have `{cpp} operator int()` - compiler as fallback will use provided to int for `{cpp} std::cout << test_obj` since compiler known how to print int values. 
> But this have downsides - when defined two conversion operator (for example, for `int` and `float`) and we use class where both types are supported (like `std::cout`) - for compiler this will be ambiguous.

Implicit conversion are often surprising, with undesirable results. 
For example, valid code from older versions of C++ (before C++11)
```c++
int i = 99;
std::ci << i;
```
`std::cin` have `operator bool()` conversation which check is used stream good. Compiler don't find `opartor<<` overload, but find conversion to bool and convert `std::cin` to `bool`. Then compiler see `<<` as left shift bit shift operator, converts `bool` to `int`, make 99 left shifts and discard result. 

In C++11 introduced `explicit` keyword. This prevent implicit conversion and conversion will only happen if it was ask for it (using casts). Exception only for `{cpp} explicit operator bool()` - beside casts, conversion performed in conditions (like `{cpp} if (test_obj)`). 

A constructor with a argument might also perform implicit conversion operator. If it's undesirable - `explicit` should be used. 
```c++
struct Test {
    int m_i{};
    Test (int i, char c = 'c') : m_i{i} {};
};
std::cout << Test(5.2).i;
```
> This also can be avoided using `{}` initialization: `Test{5.2}.i` will not compile

