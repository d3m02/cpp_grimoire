Move semantics is a C++11 feature which allows to perform optimization with exchanging (moving) function arguments and function return values  instead of copying it where it's possible. As and abstract example, we can copy file in file manager which will end up with two object, or move object to new location, which sometimes from file systems is just change address of file location. 
> Even though move semantics used in object construction, assignment etc - it's all functions (constructor is a function, assignment is a operator-function).

C++ often uses value (copy) semantics. By default, functions arguments are passed by value, functions return by value, STL containers copy data into their elements - references are not allowed. The reason why value semantics was chosen was that it avoids the need for a garbage collector and allow to deal less with dangling object. Historically garbage collectors was very slow, while C++ devised as a very efficient object-oriented language, copies trades off (extra memory and extra execution time for copying) was fair enough. 
In traditional C++ the compiler can elide copies when it is returning temporary and local variables from function (RVO, NRVO). 

## lvalues and rvalues
C++ partially inherited concepts of `lvalue` and `rvalue` from C. 

In C objects can be either "left value" or "right value" relatively to assignment operator. For example, `x = 2` - `x` is `lvalue`, `2` is `rvalue`. `x` also can be used as `rvalue`, however `2` - can't be `lvalue`. 

In C++ exist overloaded operators, some operators can return things which can be assigned to, so logic about values categories changed: 
* `lvalue` - Represents a persistent object. Object have a name, location in memory and we able to take address of it.
	* Persistence mean that they survive more than one statement, occupied memory is accessible to the programmer and they remain valid until they go out of scope or deleted. 
	* `lvalue` usually are local variables, global variables, static variables, function arguments  
* `rvalue` - Stored in location which are not accessible to the programmer (such as processor registers) and doesn't have name.
	* pure `rvalue`, `prvalue` - don't have name and can't be referred usually - It's literals (`2` or `'c'`) 
	* e*x*piring `rvalue`, `xvalue` -  temporary object which destroyed in the same statement in which they are created.
* generalize `lvalues`, `glvalues` -  describe both `lvalues` and `xvalues` since we can take references to objects and  dynamic type can be different from their static types. 
 
> More details in [[Understanding Value Categories]]

Passing by value (`{cpp}void func (int)`) or by `const lvalue` reference (`{cpp}void func(const int&)`) can accept both `lvalue` and `rvalue`.
Passing by address (`{cpp}void func(int*)`) or by `non-const lvalue` reference (`{cpp}void func(int&)`) can only accept `lvalue`.
Passing by `rvalue` reference (`{cpp} void func(int&&)`) can only accept `rvalue`. 

In C++11 when using passing by value, if object is `rvalue` and it's type is moveable - C++ might perform moving. This is true for almost all C++ library types. If object is `lvalue` or have not moveable type (including built-in types, they moveable, but since copying of trivial types not that expensive, their moving have no advantages and mostly is equal to copying), C++ probably will perform copying. Such rules provide compatibility with old code. 

`lvalue` references typically implemented as a pointer, the compiler adds code to de-reference the pointer as needed. 
For `rvalue` if we pass it to `const lvalue` reference, compiler will add code which makes this appear to work. 
> In this case happened temporary materialization conversion which create from`prvalue` a `xvalue` and reference is bind to that temporary object. 

When using `rvalue` reference in function argument, the passed object will be moved  into the argument if object is an `rvalue` and type is moveable, otherwise the call doesn't compiler. This allows to overload the function to behave differently depending on whether the passed object is an `lvalue` or and `rvalue`. 
If we want to pass an `lvalue` to a function which takes an `rvalue` reference, we can cast it to `rvalue` with `{cpp}std::move()`. After moving `lvalue` data in it may be empty or unusable, so before using it we must reassign its data. 

## Move operators
With C++11's move semantics and possibility to create different overload for `rvalue` and `lvalue` in classes was also added two new special member functions: 
* *Move constructor* - `{cpp}Test(Test&& arg) noexcept`
* *Move assignment operator* - `{cpp}Test& operatior=Test(Test&& arg) noexcept`

Move operator arguments cannot be `const`, since we going to move data from it, thus modify. 
> Technically, they can be `const`, but it makes no sense - create copy from moved into argument data.

The move operators shouldn't throw any exceptions, since there no simple way to recover from a part-completed move, (since in that case part of "old" moved location is invalided, while another part of "new" location invalided due to some exception). Also, STL containers will call an element's move operator if it's `noexcept` (container have checks like `{cpp}noexcept(std::is_nothrow_swappable_v<T>)`). Way how move operators implements in general it's call move operators of data classes and copy built-in types.  When writing a move operator for a derived class, we should call the corresponding operator for the base class as well. When moving elements with pointer members in move operators also required to invalidate moved pointers (otherwise we can get two pointers to same memory). 
```cpp
class SomeType {};
class Base {};

class Test : public Base { 
public:
    Test() = default;
    Test(const Test& other) : Base{other}, i{other.i}, m{other.m} p{new SomeType(*other.p)} {}
    Test(Test&& other) noexcept : Base{std::move(other)}, i{other.i}, m{std::move(other.m)}, p{other.p} { other.p = nullptr; }

    Test& operator=(const Test& other) {
        Test(other) tmp;
        swap(tmp)
        return *this;
    }

    Test& operator=(Test&& other) noexcept {
		Test tmp(std::move(other));
		swap(tmp);
        return *this;
    }
private:
    int i {};
    SomeType m {};
    SomeType* p {};
};

int main(){
    Test t1{};
    Test t2{std::move(t1)};
}
```

It's also possible to create move-only class - to do this we delete copy constructor, copy assignment operator and leave only move special member functions. 
Move-only classes useful when copies of object should be avoided. In STL  move-only  classes for example are `fstream`, `iostream`, smart pointers, some multithreading classes. 
These types follow the RAII idiom - only one object can own a given resource instance ate a time, the object acquires ownership of the resource in the constructor, the object releases ownership of the resource in the destructor. But ownership of the resource can be transferred from one object to another using move semantics. 

C++11 doesn't support in lambda capture by move, for move-only class we disabled coping so only capture by reference is available. However in C++14 generalized lambda capture allowed to move variable into a lambda-local variable. 
`{cpp} [lfs = std::move(fs)](int arg){}`.

From C++11 also changed rules for synthesized special members. 
The compiler will only synthesize a move operator if
+ the class doesn't define a copy constructor, copy assignment operator or destructor 
+ every data member of the class is either
	+ built-in type 
	+ user-defined type with move operators 
	+ static data member (not moved)

If a class defines a move operator, both the copy operators will be synthesized as `= delete` - the class should defined its own copy operators if it need them, otherwise the class will be move-only. 

>[!code-ref] Rule of Five:
If a class needs to implement a destructor to function correctly (and default version which simply call destructor to each member variable not suitable), then it probably needs to implement the copy and move operators as well.
> In another words, implement all five special members 

>[!code-ref] Rule of Zero
> If a class doesn't need to declare a destructor, it doesn't need to declare copy or move operators either - don't declare any special member functions.
> In this case default constructor sufficient enough, especially if member variable _initialized in-class_

## Forwarding references and Perfect forwarding
In C++ it's not possible to directly crate nested references (like `{cpp}int& & x = y`, compiler will give an error. 
However, the compiler can do this internally for a type alias or a template parameter. In this case type of the result is determined by _reference collapsing_
```cpp
using int_ref = int&;
int_ref j{i};
int_ref& rj{j}; // a reference to (reference to int), actually just a reference to int. 
```

`rvalue` reference collapse to `rvalue` reference only when used nested `rvalue` reference syntax
```cpp
using l_ref = int&;
using r_ref = int&&;

l_ref&  // int& - l_ref
l_ref&& // int& - l_ref
r_ref&  // int& - l_ref
r_ref&& // int&& - r_ref
```

This specific is useful for template argument parameters and allow to create _universal reference_ which can bind to an `rvalue` and `lvalue`, also known as reference forwarding
```cpp
template<class T>
func(T&& x);

// func(l_ref) -> T = int&; func(int& && ) -> func(int& x)
// func(r_ref) -> T = int&&; func(int&& &&x) -> funct(int&& x)
```

Since the most efficient way to implement functions is by providing two separate versions which can take `lvalue` and `rvalue`,
`{cpp} void func(const Test& obj)` + `{cpp} void func(Test&& obj)`, this can ends up with two almost similar functions. And reference forwarding can solve that issue, 

A function that passes some or all of its arguments to another function is said to _forward_ them. With _perfect forwarding_, the properties of the passed objects are preserved (if `x` is modifiable in `f()`, it's modifiable in `g()`; if `x` is moved into `f()` - it will be moved in `g()` etc). 
Perfect forwarding is used to write function which call constructors (e.g. `{cpp} std::make_pair()`), if a passed object is an `rvalue`, the more efficient move constructor will automatically be called, perfect forwarding is also used by variadic templates to dispatch their arguments to functions which process them. 

When implementing perfect forwarding function, if in template function `{cpp}f(T&& x)`simply use `{cpp}g(x)` - for `rvalue` instead of `{cpp}g(T&&)` will be called `{cpp}g(T&)` since `x` become a `lvalue`. If use `{cpp}g(std::move(x))` - now for `lvalue` called `{cpp}g(T&&)` since `std::move` will always cast to `rvalue`. Solution is `std::forward` - it's applies reference collapse instead cast. 
So rule is simple - for universal references use `{cpp}std::forward`, for `rvalue` references - `{cpp}std::move()`. 
```cpp
template<class T>
f(T&& x)
{
	g(std::forward<T>(x));
}
```

