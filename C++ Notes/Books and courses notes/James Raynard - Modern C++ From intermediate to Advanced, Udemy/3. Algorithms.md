## STL Algorithms overview
The C++ STL defines a number of functions in `<argorithm>` header, which implements classic algorithms as well as a number of other useful routines. STL algorithms coded and tested as part of the standard library implementation, might be more accurate and more efficient (even use some internal compiler features). 

Typically to STL algorithm passed an iterator range to specify which elements in container will be processed (`{cpp}begin()`, `{cpp}end()` means to process the entire container). 
> From C++ also possible to use [Ranged algorithms](https://cppreference.com/w/cpp/algorithm/ranges.html) library: `{cpp}std::sort(vec.begin(), vec.end())` equal to `{cpp}std::ranges::sort(vec)` 

> Also exists algorithms, which works not with container: `{cpp}std::min()`, `{cpp}std::max()`, `{cpp}std::clamp()`, `{cpp}std::minmax()` (containers variant of those algorithms have `_element()` suffix or defined in `ranges::` library: `{cpp} std::max_element()`/`std::ranges::max()`)

Most algorithms return either
* an iterator representing a particular element
`{cpp} InputIt std::find(InputIt first, InputIt last, const T& value)` - return an iterator to first element equal to T or iterator to `end()`/`last` in element not found; 
* a value containing the result of some operation on the elements. 
`{cpp} T accumulate(InputIt first, InputIt last, T init);` - return sum of the given value `init` and the elements in the range `[first, last)`.

> also some algorithms return `bool`, algorithms like `{cpp}std::all_of()`, `{cpp}std::binary_search()`, `{cpp} std::is_heap()`

Many algorithms takes as argument a callable object, such argument called "predicate". Predicate called with elements of container and returns bool. Most of algorithm have own predicate (`std::sort` as predicate use `operator<`, but we can provide any compare function instead). 
As a predicate we can pass
```cpp fold:"pointers to function" ln:false
bool compare(int a, int b) { return a < b; }
std::ranges::sort(arr, &compare); // explicit pointer
std::ranges::sort(arr, compare);  // implicit conversion to pointer

std::ranges::sort(arr, 
                  std::bind(compare, 
                            std::placeholders::_1, // first func argument
                            std::placeholders::_2)); // second func arg
``` 

```cpp fold:"functors (class object with implemented operator())" ln:false
struct Comparator {
    bool operator()(int a, int b) const { return a < b; }
};

// using temporary object
std::ranges::sort(arr, Comparator()); 
/* Important note, () - it's not function call/operator() call. 
   It's object initialization, similarly to Comparator{}. 
 */

// with object
Comparator cmp{};
std::ranges::sort(arr, cmp);

//or 
struct {
    bool operator()(int a, int b) const { return a < b; }
} cmp;
std::ranges::sort(arr, cmp);
```

```cpp fold:"lambda-functions" ln:false
std::ranges::sort(arr, [&](int a, int b) { return a < b; });
```

```cpp fold:"std::function object from <functional>" ln:false
std::function<bool(int, int)> cmp = [](int a, int b) { return a < b; };
std::ranges::sort(arr, cmp);

std::ranges::sort(arr, std::less_equal<int>());
//          template type is optional ^^^^^

std::ranges::sort(arr, std::ranges::greater());

std::ranges::sort(arr, std::not_fn(std::less<int>()));

// In some cases 
struct Point {
    int x, y;
    void print() const { std::cout << x << " " << y << "\n"; }
};
std::vector<Point> points = {{1, 2}, {3, 4}};
std::ranges::for_each(points, std::mem_fn(&Point::print));
// but it's can be replaced with more usual approach 
std::ranges::for_each(points, [](const Point& p) { p.print(); });
```

Many algorithms have `_if`/`_if_not` version, which takes predicate and modify base version with that predicate

```cpp unwrap ln:false 
// first, last - the pair of iterators defining the range of elements to examine
// value 	- 	value to compare the elements to 
template<class InputIt, class T>
InputIt find(InputIt first, InputIt last, const T& value);

// p - unary predicate which returns ​_true_ for the required element
template<class InputIt, class UnaryPred>
InputIt find_if(InputIt first, InputIt last, UnaryPred p);

// q - unary predicate which returns _false_ for the required element
template<class InputIt, class UnaryPred>
InputIt find_if_not(InputIt first, InputIt last, UnaryPred q);
```

## Lambda expressions 
When the compiler encounters a lambda expression, it will generate [[2. Special Member Functions and Operator Overloading#Functor|Functor]] class with function body provided in lambda body, return type the same as lambda expression and functor object. Lambda expressions are anonymous (don't have name, name generated by compiler and usually it's combination of "`__lambda_` + line number + column number"), to define lambda we put "_capture specifier_" `[]` for the function name, rest is similar to usual functions. 
```cpp ln:false
[](int n) { return (n % 2 == 1); }
// equal to, both return type will be deduced as bool
auto is_odd(int n) { return (n % 2 == 1); } // since C++14
```

In C++11 for first lambda versions compiler can deduce return type only if lambda is single statement, for complex expression return type of lambda function provided by trailing return type (similarly to usual functions).
```cpp ln:false
[](int n) -> bool { return (n % 2 == 1); }
auto is_odd(int n) -> bool { return (n % 2 == 1); }
```
In C++14 auto return type deduction start support complex expression only if all return types same, starting from C++17 it's no longer required

A lambda expression has access to global variables, static variables in the same scope, `local_thread` variable. By default, lambda expressions have very limited access to local variables, only to const integer and enum variables. 
```cpp fold:Example
int global_var = 10;
static int static_var = 20;
thread_local int thread_local_var = 30;

int main() {
    static int local_static_var {20};
    const int const_int {42};
    constexpr int constexpr_val {100};
    enum Color { RED = 1, GREEN = 2 };
    const Color color {RED};

    auto lambda = [](int n) { 
        return n + global_var
                 + static_var
                 + thread_local_var
                 + const_int
                 + constexpr_val
                 + color;
    };

    std::cout << lambda(1);
    return 0;
}
```


Lambda also have "capturing" mechanism. In this case functor will be _"functor with state"_. Captured variable will stored as private members of compiler-generated functor. 
* `{cpp} [n](int arg){ return n * arg; };` - capture local `n` variable by value (functor store own copy of variable). 
Variable is "const", it's can't be changed (until lambda not marked as mutable: `{cpp}[n](int arg) mutable { return ++n * arg; };`)

* `{cpp} [&n](int arg) { return ++n * arg; };` - capture by reference. Captured by reference can be modifiable and `mutable` not required. 
> If required to capture as const reference - starting from C++14 possible to use init-capture and pass variable as `std::as_const` (require `<utility>`) or use `std::cref` which will create `std::reference_wrapper` object (`<functional>`)
```cpp fold:Example
int local {3};

auto lambda = [&local_const = std::as_const(local)](int n) {
	return n + local_const;
}; // will create `const int& local_const;` in functor

auto lambda = [local_const = std::cref(local)](int n) {
    return n + local_const;
}; // will create `std::reference_wrapper<const int> local_const;`
```

* "_capture default_" provided:
	* `[=]` - will implicitly capture all variables by value (by-copy capture default)
	* `[&]` - will implicitly capture all variable by reference(by-reference capture default)
> Although compilers can optimize not used variables and not capture them, C++ standard doesn't guarantee this, so it's up to compiler and optimization level - capture unused local variable or not.

* Also possible to combine 
	* `[=, &a]` - capture `a` by reference, everything else by value 
	* `[&, a, b]` - capture `a` and `b` by value, everything else by reference. 

Lambda can be created inside class member function as well. In this case since [[0. Review of C++#Class functions in global scope|member function in C++ are in global scope]] and have hidden `this` argument (`{cpp}test.do_it()` <=>`{cpp}Test::do_it(&this)`), `this` is a local variable, which can be also captured by lambda. In another words, lambda in class can get *non-const* copy to `this`, as well as some additional capture options. 
* Even with implicit capture by value (`[=]`) `this` will be captured by reference
	* It's only work when default capture method provided, with `[]` `this` not captured =
	* In C++20 implicit capture of `this` via `[=]` deprecated and should be used `[=, this]` or `[=, *this]` 
	* Until C++20 `[=, this]` can generate warning or error. In C++20 it's will be equal to `[=]` (`this` by reference). 
* Capture "by reference" `[&this]` is not allowed. 
* From C++17 it's possible to capture `this` by value `[*this]`. 

Lambda can be stored in variable (in this case compiler will create functor and use it as type of variable). Variable in this case will be callable. 
Also, lambda can be returned from function (but it have own restriction, as return type and variable type which will store returned value type should be either `auto` (from C++14) or `std::function` (from C++11)).

```cpp fold:"Example"
using LambdaGreeterT = std::function<std::string(const std::string&)>;
LambdaGreeterT greeter(const std::string& salutation) {
  return [=](const std::string& name) 
  { return salutation + std::string(", ") + name; };
}

LambdaGreeterT greet = greeter("Hello");
std::cout << greet("students");

// From C++14
using namespace std::literals;
  
auto greeter(const std::string& salutation) {
  return [=](const std::string& name) 
  { salutation + ", "s + name; };
}


auto greet = greeter("Hello"s);
std::cout << greet("students"s);
```

> Version with `auto` quite interesting. It's relay on compiler type deduction and allow to return with such style not only lambda, but also classes defined inside function. Usually it's not possible without forward declaration.

When returning lambda from function it's dangerous to use capture by reference, similarly to returning reference to local variable. This case create dangling reference, since local variable will be destroyed when the function returns.  

Lambda expression with capture allows to implement _partial evaluation_ - functional programming technique, in which is data evaluated partially in stages. 

Starting from C++14 it's possible to create "_generic lambdas_" or "_polymorphic lambdas_" which uses `auto` arguments. In this case in functor will be generated `operator()` using `template` which will be instantiated with function arguments when it's gets called. 
```cpp
auto summator {[](auto x, auto y) {return x + y;}};
func(2, 5);
func(str1, str2);
```

Also starting from C++14 it's possible to create variables in the capture specifier. They implicitly "`auto`" and must be initialized:
`{cpp}[x = 3](int y) { return x + y; };`
> It's also possible to use `{cpp}[x{3}]` 

For variable initialization capture doesn't required even if we use `[x = z + 3]`, since `z + 3` will be passed to functor constructor. With variable initialization also `{cpp}std::move()` can be used. 

### Some additional information
"Effective modern C++" have whole [[Chapter 6 - Lambda Expressions]] dedicated to lambdas, but it's only up to C+14. 

#### From cppreference 
Starting from C+17 lambdas extended `constexpr` use:
* `{cpp}operator()` will be `constexpr` explicitly if it satisfies the requirements of a `constexpr` function
* User-defined conversion function is `constexpr`
* Captured by reference data members compatible with `constexpr` expressions  
* Lambda can be used with `static_assert`

From C++20: 
* Added support of `consteval` for `operator()` if lambda captures is empty(`[]`)
> `consteval` functions also called "_immediate function_"
* Lambda with empty captures can be used as template parameter 
```cpp ln:false
template<auto F>
void foo() { F(); }

foo<[]{ std::cout << "hi"; }>(); 
```
* Lambda can be used in `{cpp}decltype([](int x){return x;}) t;`
* Lambda can be defined with an explicit template parameter list, have `requires`
```cpp ln:false nowrap
auto lambda = [[maybe_unused]]
              [x = 5]<typename T>(T a, int b) mutable noexcept->decltype(auto)
              requires std::integral<T> {
  return a + b + x;
};
```
> Fun example [Let's Write a Lambda in C++ - Ben Deane - CppCon 2023](https://www.youtube.com/watch?v=EqiLTgQcDPM)

* If no captures are specified, the closure type has a defaulted copy assignment operator and a defaulted move assignment operator. Otherwise, it has a deleted copy assignment operator (this includes the case when there is a capture-default ﻿, even if it does not actually capture anything).
* Capture variadic pack: `[...args]`

C++23: 
* Lambda can be `static`.
* Lambda can use explicit object parameter.
```cpp ln:false
// Allow to change captured without mutable
auto lambda = [x = 5](this auto& self) {
    self.x++; 
    return self.x;
};

// self - it's lambda itself
auto lambda = [](this auto& self) {
    // self can be used for recursive call
    return self(...);
};

// Allow to avoid class's this capture 
class C {
    void f() {
        auto lambda = [](this auto& self) {
            // no access to C::member
        };
    }
};
```


#### Examples of how compiler generate lambdas from [cppinsights.io]()
As test example used code 
```cpp 
void takes_fn_ptr(bool (*fn)(int)) {  }
struct test {
	void func() {
        int local {};
        
        takes_fn_ptr([](int n) { return (2 % n == 1);}); 

        [&](int n) { return (local % n == 1);};
        [=](int n) { return (local % n == 1);};  
        [local](int n) { return (local % 2 == 1);};
        [&local](int n) { return (local % 2 == n);};
        [this](int n) { return (n % this->m_mem == 1);};
        [*this](int n) { return (n % this->m_mem == 1);};  
    }
private:
  	int m_mem{};
};
```
In this example only default lambda can be passed as argument to another function, since it doesn't have any copy to `this`

```cpp fold:"takes_fn_ptr([](int n) { return (2 % n == 1);});"
class __lambda_15_22
{
public: 
	inline /*constexpr */ bool operator()(int n) const
    {
	    return ((2 % n) == 1);
    }
      
	using retType_15_22 = bool (*)(int);
// conversion operator which allows to convert lambda to function pointer
    inline constexpr operator retType_15_22 () const noexcept
    {
	    return __invoke;
    }
      
private: 
    static inline /*constexpr */ bool __invoke(int n)
    {
	    return __lambda_15_22{}.operator()(n);
    }
};
    
takes_fn_ptr(__lambda_15_22{}.operator __lambda_15_22::retType_15_22());
```

```cpp fold:"[=](int n) { return (local % n == 1);};"
class __lambda_19_9
{
public:
  __lambda_19_9(int & _local) : local{_local} {} 
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % n) == 1);
  }
  
private: 
  const int local; // Copy of local variable
} __lambda_19_9{local};
```

```cpp fold:"[&](int n) { return (local % n == 1);};"
class __lambda_23_9
{
public:
  __lambda_23_9(int& _local) : local{_local}{} 
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % n) == 1);
  }
  
private: 
  int& local;
//   ^ what make it different - reference to local variable  
} __lambda_23_9{local};
```

```cpp fold:"[local](int n) { return (local % 2 == 1);};"
class __lambda_27_9
{
public:
  __lambda_27_9(int & _local) : local{_local} {}
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % 2) == 1);
  }
  
private:
  int local;
} __lambda_27_9{local};
```

```cpp fold:"[&local](int n) { return (local % 2 == n);};"   
class __lambda_31_9
{
public:
  __lambda_31_9(int & _local) : local{_local} {} 
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % 2) == n);
  }
  
private: 
  int& local;
} __lambda_31_9{local};
```

```cpp fold:"[this](int n) { return (n % this->m_mem == 1);};"
class __lambda_35_9
{
public: 
  public: __lambda_35_9(test* _this) : __this{_this} {}
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((n % __this->m_mem) == 1);
  }
  
private: 
  test* __this;
} __lambda_35_9{this};
```

```cpp fold:"[*this](int n) { return (n % this->m_mem == 1);};"
class __lambda_39_9
{
public:
  __lambda_39_9(const test& _this) : __this{_this} {}
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((n % (&__this)->m_mem) == 1);
  }
  
private: 
  const test __this;
//^^^ copy of this  
} __lambda_39_9{*this};
```

## Insert iterators 
An output stream iterator when value is assigned to actually perform insertion into output stream. But for container there are separately _insert iterators_: `std::back_insert_iterator`, `std::front_insert_iterator`, and `std::insert_iterator` (which add element to any given position). 
To get insert iterator we need to call _inserter_ function: `{cpp}std::back_inserter(Container& c)`, `{cpp}std::front_inserter(Container& c)`, `{cpp}std::inserter(Container& c, typename Container::iterator i)`, where `i` - position to insert. Assigning to returned insert iterator will add a new element to container using container's `::push_back()`/`::push_front()`/`insert()` (which means that not every container can support insert iterator).

|                                                                                        | `back_inserter()` | `front_inserter()` | `inserter()` |
| -------------------------------------------------------------------------------------- | :---------------: | :----------------: | :----------: |
| `std::vector`                                                                          |         ✅         |         ❌          |      ✅       |
| `std::deque`                                                                           |         ✅         |         ✅          |      ✅       |
| `std::list`                                                                            |         ✅         |         ✅          |      ✅       |
| `std::forward_list`                                                                    |         ❌         |         ✅          |      ✅       |
| `std::set`<br>`std::multiset`<br>`std::unordered_set`<br>`std::unordered_multiset`<br> |         ❌         |         ❌          |      ✅       |
| `std::map`<br>`std::multimap`<br>`std::unordered_map`<br>`std::unordered_multimap`<br> |         ❌         |         ❌          |      ✅       |
| `std::queue`<br>`std::stack`<br>`std::priority_queue`                                  |         ❌         |         ❌          |      ❌       |
| `array`                                                                                |         ❌         |         ❌          |      ❌       |
```cpp
std::vector vec {1, 3, 4};
auto el2 {std::next(vec.begin())};
auto insIt {std::inserter(vec, el2)};
*insIt = 2;
```
Keep in mind that some container after container modification can invalidate iterators. In example above `el2` after using insert iterator will be invalid (container might rearrange elements, or allocate large size memory space to store n+1 elements etc.) 

Input iterators mostly used with STL algorithm. Also one of usage is in conjunction with stream iterators, for example to write simpler code for copying data from stream to container. 
```cpp
using StringIter = std::istream_iterator<std::string>;
StringIter inItr{std::cin};
StringIter inItrEnd{};

std::vector<std::string> vec{};
auto vecInsItr {std::back_inserter(vec)};

while (inItr != inItrEnd) {
	vecInsItr = *inItr;
    ++inItr;
}  

// or 
std::copy(inItr, inItrEnd, std::back_inserter(vec));
```

## Library Function Objects
In `<functional>` header file can be found STL functional objects for generic operators for arithmetic, logic, relational operations etc.
They widely used with algorithms as well. 

|                    |        |                        |             |
| ------------------ | ------ | ---------------------- | ----------- |
| Arithmetic         |        | Comparisons            |             |
| `std::plus`        | x + y  | `std::equal_to`        | x == y      |
| `std::minus`       | x - y  | `std::not_equal_to`    | x != y      |
| `std::multiplies`  | x * y  | `std::greater`         | x > y  <br> |
| `std::divides`     | x / y  | `std::less`            | x < y  <br> |
| `std::modulus`     | x % y  | `std::greater_equal`   | x >= y      |
| `std::negate`      | -x     | `std::less_equal`      | x <= y      |
|                    |        |                        |             |
| Logical            |        | Bitwise                |             |
| `std::logical_and` | x && y | `std::bit_and`         | x & y       |
| `std::logical_or`  | x \| y | `std::bit_or`          | x \| y      |
| `std::logical_not` | !x     | `std::bit_xor`         | x ^ y<br>   |
|                    |        | `std::bit_not` (C++14) | ~x          |

## STL Algorithms 
### Searching algorithms
>[!Note]
> Mentioned function signature is not fully correct from language perspective, optional arguments can be only last function arguments, but theoretically it's valid - at the beggining `ExecutionPolicy&& policy = std::execution::seq` it's "use or not", in language it's two different template overloads 

* Searches for an element equal to `value` (using `operator==`)
>[!code-ref]- `{cpp}std::find()`
>```cpp ""
>ForwardIt std::find(ExecutionPolicy&& policy = std::execution::seq, 
>                     ForwardIt first, ForwardIt last, 
>                     const T& value);
>```

* Searches for an element for which _Unary_ predicate `p` returns `true`.
>[!code-ref]- `{cpp}std::find_if()`
>```cpp ""
>ForwardIt std::find_if(ExecutionPolicy&& policy = std::execution::seq,
>					    ForwardIt first, ForwardIt last, 
>					    UnaryPred p)
>```

* Searches for an element for which _Unary_ predicate `p` returns `false`.
>[!code-ref]- `{cpp}std::find_if_not()`
>```cpp ""
>ForwardIt std::find_if_not(ExecutionPolicy&& policy = std::execution::seq, 
>                            ForwardIt first, ForwardIt last, 
>                            UnaryPred p)
>```

> STL doesn't have algorithm to search last match, `{cpp}std::find_end()` is different algorithm. Last element can be find using _reverse iterators_ and use `{cpp}std::rend()` as "not found".

* Searches the range `[first, last)` for any of the elements in the range `[s_first, s_last)`. 
>[!code-ref]- `{cpp} std::find_first_of()`
>```cpp ""
>ForwardIt1 std::find_first_of(ExecutionPolicy&& policy = std::execution::seq, 
>                               InputIt first, InputIt last, 
>                               ForwardIt s_first, ForwardIt s_last, 
>                               BinaryPred p = std::equal_to())
>```

```cpp
auto str {"Hello world"s};
auto vowels {"aeiou"s};
auto case_insensitive_equal {[](auto a, auto b) {
    return std::tolower(a) == std::tolower(b);
}};
auto vowel {std::find_first_of(std::cbegin(str), std::cend(str), 
							  std::cbegin(vowels), std::cend(vowels), 
							  case_insensitive_equal)};
if (vowel != str.cend())
    std::cout << "First vowel is " << *vowel 
              << " at index " << std::distance(std::cbegin(str), vowel) 
              <<'\n';
```
> To find next match we can use found iterator and pass next iterator after it back to search function using `{cpp} std::next()`.

* Looks for two neighboring elements that have the same value
>[!code-ref]- `{cpp}std::adjecent_find()`
>```cpp ""
>ForwardIt std::adjecent_find(ExecutionPolicy&& policy = std::execution::seq,
>                              ForwardIt first, ForwardIt last, 
>                              BinaryPred p = std::equal_to())
>```

* Looks for a sequence of `count` successive elements which have the same given `value`, returns iterator to the first element of the sequence. 
>[!code-ref]- `{cpp} std::search_n()` 
>```cpp ""
>ForwardIt std::search_n(ExecutionPolicy&& policy = std::execution::seq,
>                         ForwardIt first, ForwardIt last, 
>                         Size count, const T& value, 
>                         BinaryPred p = std::equal_to())
>```
```cpp
std::vector vec {1, 2, 2, 3, 2, 3, 3};
auto count {2};
auto val {3};
auto pos {std::search_n(std::cbegin(vec), std::cend(vec), count, val)};
```

* Takes two iterator ranges and looks for an occurrence of the second iterator range in first.
>[!code-ref]- `{cpp}std::search()`
> ```cpp ""
> ForwardIt1 std::search(ExecutionPolicy&& policy = std::execution::seq,
>                        ForwardIt1 first, ForwardIt1 last, 
>                        ForwardIt2 s_first, ForwardIt2 s_last, 
>                        BinaryPred p = std::equal_to())
> ```

* Takes two iterator ranges and looks for an *LAST* occurrence of the second iterator range in first.
>[!code-ref]- `{cpp} std::find_end()`
>```cpp ""
>ForwardIt1 std::find_end(ExecutionPolicy&& policy = std::execution::seq,
 >                          ForwardIt1 first, ForwardIt1 last, 
 >                          ForwardIt2 s_first, ForwardIt2 s_last, 
 >                          BinaryPred p = std::equal_to())
>```
```cpp
int vec[] {1, 2, 2, 2, 3};
int sub[] {2, 2};

auto firstSubset {std::search(std::cbegin(vec), std::cend(vec), 
							 std::cbegin(sub), std::cend(sub))};
firstSubset != std::cend(vec)
    ? std::println("First occurrence at vec[{}]", 
                   std::distance(std::cbegin(vec), firstSubset))
    : std::println("No match for first occurence\n");

auto lastSubset {std::find_end(std::cbegin(vec), std::cend(vec), 
							  std::cbegin(sub), std::cend(sub))};
lastSubset != std::cend(vec)
    ? std::println("Last occurrence at vec[{}]", 
                   std::distance(std::cbegin(vec), lastSubset))
    : std::println("No match for last occurence");  
```

* Takes two iterator ranges and looks for differences between the two ranges. Returns a pair to the first elements that has a different value in each range. 
>[!code-ref]- `{cpp} std::mismatch()`
>```cpp ""
>std::pair<ForwardIt1, ForwardIt2>
>std::mismatch(ExecutionPolicy&& policy = std::execution::seq, 
>               ForwardIt1 first1, ForwardIt1 last1, 
>               ForwardIt2 first2, ForwardIt2 last2, 
>               BinaryPred p = std::equal_to()) 
>```
```cpp ln:false
int vec1[] {1, 2, 2, 3, 2, 3, 3};
int vec2[] {1, 2, 2, 2, 2, 3, 3};

auto [diff1, diff2] {std::mismatch(std::cbegin(vec1), std::cend(vec1),
						          std::cbegin(vec2), std::cend(vec2))};

if (diff1 != std::cend(vec1) && diff2 != std::cend(vec2))
    std::println("vec1[{}] != vec2[{}] ({} != {})", 
                 std::distance(std::cbegin(vec1), diff1), 
                 std::distance (std::cbegin(vec2), diff2),
                 *diff1, *diff2);
```

* Return `true` if the _unary_ predicate is `true` for every element. Equal to `{cpp} std::find_if_not(first, last, p) == last` 
>[!code-ref]- `{cpp}std::all_of()`
>```cpp ""
>bool std::all_of(ExecutionPolicy&& policy = std::execution::seq, 
>                  ForwardIt first, ForwardIt last, 
>                  UnaryPred p)`
>```

* Return `true` if the _unary_ predicate is `true` for at least one element. Equal to `{cpp} std::find_if(first, last, p) != last`
>[!code-ref]- `{cpp}std::any_of()`
>```cpp ""
>bool std::any_of(ExecutionPolicy&& policy = std::execution::seq, 
>                  ForwardIt first, ForwardIt last, 
>                  UnaryPred p)
>```

* Return `true` if the _unary_ predicate is `false` for every element. Equal to `{cpp} std::find_if(first, last, p) == last`.
>[!code-ref]- `{cpp}std::none_of()`
>```cpp ""
>bool std::none_of(ExecutionPolicy&& policy = std::execution::seq, 
>                   ForwardIt first, 
>                   ForwardIt last, UnaryPred p)
>```
```cpp
auto is_odd {[](auto n) { return n % 2 == 1; }};
std::vector vec {2, 3, 5};

if (std::all_of(std::cbegin(vec), std::cend(vec), is_odd))
	std::cout << "All elements of vec are odd\n";
if (std::any_of(std::cbegin(vec), std::cend(vec), is_odd))
	std::cout << "Some elements of vec are odd\n";
if (std::none_of(std::cbegin(vec), std::cend(vec), is_odd))
	std::cout << "No odd elements of vec\n";
```

* Return `true` if element `value` contains in *sorted* iterator range (using [Binary search](https://en.wikipedia.org/wiki/Binary_search))
>[!code-ref]- `{cpp} std::binary_search()`
>```cpp ""
>bool std::binary_search(ForwardIt first, ForwardIt last,
 >                         const T& value, Compare comp == std::less());
>```

* Checks is second iterator range is subrange of first iterator range. 
If ranges *sorted* - return `true` if all the elements in the second range are presented in the first range.
>[!code-ref]- `{cpp} std::includes()`
>```cpp ""
>bool includes(ExecutionPolicy&& policy = std::execution::seq,
 >               ForwardIt1 first1, ForwardIt1 last1,
 >               ForwardIt2 first2, ForwardIt2 last2, 
 >               Compare comp =std::less());
>```
```cpp
std::vector first {1, 2, 3, 4, 5};
std::vector second {5, 2, 1};

std::includes(std::cbegin(first), std::cend(first), 
              std::cbegin(second), std::cend(second))
            ? std::cout << "yes\n"
            : std::cout << "no\n";
// returned no

std::ranges::sort(first);
std::ranges::sort(second);

std::includes(std::cbegin(first), std::cend(first), 
              std::cbegin(second), std::cend(second))
            ? std::cout << "yes\n"
            : std::cout << "no\n";
// returned yes

std::vector first2 {3, 4, 5, 2, 1};
std::vector second2 {5, 2, 1};

std::includes(std::cbegin(first2), std::cend(first2), 
              std::cbegin(second2), std::cend(second2))
            ? std::cout << "yes\n"
            : std::cout << "no\n";
// returned yes
```
>[!note] 
> Algorithm have complexity $O(N_1 + N_2)$. Combining with complexity of `{cpp}std::sort()`, $O(N log N)$, `{cpp}std::sort()`+`{cpp}std::includes()` can provide complexity $O(N_1 log N_1 + N_2 log N_2)$, 
> which is better than complexity of `{cpp}std::all_of()`+`{cpp}std::find()` ($O(N_1 * N_2$), 
> but yet worser than using `{cpp}std::unorded_set::insert()` and check flag "was not inserted" ($O(N_1 + N_2)$) 

### Numeric Algorithms
Some of algorithm defined in `<numeric>` header. 

* Fill an iterator range with values increased on each new step by 1, starting from some `value` 
>[!code-ref]- `{cpp} std::iota()`
>```cpp ""
>void std::iota(ForwardIt first, ForwardIt last, T value)
>```
```cpp
std::vector<int> vec(10); // Constructor will create vector with 10 elements
std::iota(std::begin(vec), std::end(vec), -5);
for (auto& v : vec)
    std::print("{} ", v);
// -5 -4 -3 -2 -1 0 1 2 3 4
```

* Returns the sum of `init` value and all the elements in an iterator range, can be modified with Binary predicate `op`, execution will be *strictly from left to right*
>[!code-ref]- `{cpp}std::accumulate()`
>```cpp ""
>T std::accumulate(InputIt first, InputIt last, 
>                   T init, BinaryOp op = std::sum());
>```
```cpp
std::vector<int> vec(2);
std::iota(std::begin(vec), std::end(vec), 2);

auto res {std::accumulate(std::cbegin(vec), std::cend(vec), 1, std::multiplies())};
```

* Similarly to `{cpp} std::accumulate()`, but can be run in parallel, executing operation _in any order_. 
>[!code-ref]- `{cpp}std::reduce()`
>```cpp ""
>T reduce(ExecutionPolicy&& policy,
>          ForwardIt first, ForwardIt last, 
>          T init, BinaryOp op = std::sum());
>```

### Write-only Algorithms 
* Assigning given iterator range with `value`
>[!code-ref]- `{cpp} std::fill() `
>```cpp ""
>void fill(ExecutionPolicy&& policy = std::execution::seq,
>           ForwardIt first, ForwardIt last, const T& value);
>```

* Assigns the given value to the first `count` elements in the range beginning at `first` with `value` and return iterator to next after last assigned element. *Given container should have enough capacity, if `count` greater than container size - UB*. 
>[!code-ref]- `{cpp} std:fill_n()`
>```cpp ""
>ForwardIt std::fill_n(ExecutionPolicy&& policy = std::execution::seq,
>                  ForwardIt first, 
>                  Size count, const T& value )
>```

One "trick" which avoid overflow if `count` is greater than size - is use `{cpp}std::back_inserter()`, which will call `push_back()` for each element.
> But it's just example of use insertion iterator and not recommendation - poor performance (since that means that on each step we reallocate container) + create temporary object (since not `emplace_back()` is used) and not all container supports `push_back()`.

* Assign given iterator range with return value from executed `generator` callable object
>[!code-ref]- `{cpp} std::generate()`
>```cpp
>void std::generate(ExecutionPolicy&& policy = std::execution::seq, 
>                    ForwardIt first, ForwardIt last, 
>                    Generator g);
>```
```cpp
class {
    int n{};
public:
    int operator()() { return ++n * n; }
} SquareGen;

std::vector<int> vec(10);
std::generate(std::begin(vec), std::end(vec), SquareGen);
```
```cpp fold:"Or more generalized implementation which deduce type of vector"
template<class T>
class SquareGen {
    T n{};
public:
    template<class R>
    SquareGen(const R&) {}
    
    auto operator()() { return ++n * n; }
};

template<class R>
SquareGen(const R&) -> SquareGen<typename R::value_type>;

std::vector<int> vec(10);
std::generate(std::begin(vec), std::end(vec), SquareGen(vec));
```

* Generate value and assign it to container elements in range `[begin, begin + count]` and return iterator on container element after last assigned element. Similar to `{cpp} std::fill_n()`, with same UB if `count` is greater than container size.
>[!code-ref]- `{cpp} std::generate_n()`
>```cpp
>ForwardIt generate_n(ExecutionPolicy&& policy,
>                      ForwardIt first, Size count, 
>                      Generator g );
>```

### For_each
Takes each element from iterator range by reference and pass to provided unary function object. If callable function return anything - it will be ignored. Algorithm mutable and elements taken by reference, meaning that algorithm can modify elements as well.
>[!code-ref]- `{cpp} std::for_each()`
>```cpp
>void for_each(ExecutionPolicy&& policy,
>               ForwardIt first, ForwardIt last, 
>               UnaryFunc f);
>```
```cpp
std::vector vec{3, -4, 2, -8, 15, 267};
auto print {[](const auto& n) { std::cout << n << ' '; }};

std::for_each(std::cbegin(vec), std::cend(vec), print);
std::cout <<'\n';

std::for_each(std::begin(vec), std::end(vec), [](int &n) { n++; });

std::for_each(std::cbegin(vec), std::cend(vec), print);
```
