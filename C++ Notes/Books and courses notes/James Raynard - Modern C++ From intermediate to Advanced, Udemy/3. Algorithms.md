## STL Algorithms overview
The C++ STL defines a number of functions in `<argorithm>` header, which implements classic algorithms as well as a number of other useful routines. STL algorithms coded and tested as part of the standard library implementation, might be more accurate and more efficient (even use some internal compiler features). 

Typically to STL algorithm passed an iterator range to specify which elements in container will be processed (`{cpp}begin()`, `{cpp}end()` means to process the entire container). 
> From C++ also possible to use [Ranged algorithms](https://cppreference.com/w/cpp/algorithm/ranges.html) library: `{cpp}std::sort(vec.begin(), vec.end())` equal to `{cpp}std::ranges::sort(vec)` 

> Also exists algorithms, which works not with container: `{cpp}std::min()`, `{cpp}std::max()`, `{cpp}std::clamp()`, `{cpp}std::minmax()` (containers variant of those algorithms have `_element()` suffix or defined in `ranges::` library: `{cpp} std::max_element()`/`std::ranges::max()`)

Most algorithms return either
* an iterator representing a particular element
`{cpp} InputIt std::find(InputIt first, InputIt last, const T& value)` - return an iterator to first element equal to T or iterator to `end()`/`last` in element not found; 
* a value containing the result of some operation on the elements. 
`{cpp} T accumulate(InputIt first, InputIt last, T init);` - return sum of the given value `init` and the elements in the range `[first, last)`.

> also some algorithms return `bool`, algorithms like `{cpp}std::all_of()`, `{cpp}std::binary_search()`, `{cpp} std::is_heap()`

Many algorithms takes as argument a callable object, such argument called "predicate". Predicate called with elements of container and returns bool. Most of algorithm have own predicate (`std::sort` as predicate use `operator<`, but we can provide any compare function instead). 
As a predicate we can pass
```c++ fold:"pointers to function" ln:false
bool compare(int a, int b) { return a < b; }
std::ranges::sort(arr, &compare); // explicit pointer
std::ranges::sort(arr, compare);  // implicit conversion to pointer

std::ranges::sort(arr, 
                  std::bind(compare, 
                            std::placeholders::_1, // first func argument
                            std::placeholders::_2)); // second func arg
``` 

```c++ fold:"functors (class object with implemented operator())" ln:false
struct Comparator {
    bool operator()(int a, int b) const { return a < b; }
};

// using temporary object
std::ranges::sort(arr, Comparator()); 
/* Important note, () - it's not function call/operator() call. 
   It's object initialization, similarly to Comparator{}. 
 */

// with object
Comparator cmp{};
std::ranges::sort(arr, cmp);

//or 
struct {
    bool operator()(int a, int b) const { return a < b; }
} cmp;
std::ranges::sort(arr, cmp);
```

```c++ fold:"lambda-functions" ln:false
std::ranges::sort(arr, [&](int a, int b) { return a < b; });
```

```c++ fold:"std::function object from <functional>" ln:false
std::function<bool(int, int)> cmp = [](int a, int b) { return a < b; };
std::ranges::sort(arr, cmp);

std::ranges::sort(arr, std::less_equal<int>());
//          template type is optional ^^^^^

std::ranges::sort(arr, std::ranges::greater());

std::ranges::sort(arr, std::not_fn(std::less<int>()));

// In some cases 
struct Point {
    int x, y;
    void print() const { std::cout << x << " " << y << "\n"; }
};
std::vector<Point> points = {{1, 2}, {3, 4}};
std::ranges::for_each(points, std::mem_fn(&Point::print));
// but it's can be replaced with more usual approach 
std::ranges::for_each(points, [](const Point& p) { p.print(); });
```

Many algorithms have `_if`/`_if_not` version, which takes predicate and modify base version with that predicate

```c++ unwrap ln:false 
// first, last - the pair of iterators defining the range of elements to examine
// value 	- 	value to compare the elements to 
template<class InputIt, class T>
InputIt find(InputIt first, InputIt last, const T& value);

// p - unary predicate which returns ​_true_ for the required element
template<class InputIt, class UnaryPred>
InputIt find_if(InputIt first, InputIt last, UnaryPred p);

// q - unary predicate which returns _false_ for the required element
template<class InputIt, class UnaryPred>
InputIt find_if_not(InputIt first, InputIt last, UnaryPred q);
```

## Lambda expressions 
When the compiler encounters a lambda expression, it will generate [[2. Special Member Functions and Operator Overloading#Functor|Functor]] class with function body provided in lambda body, return type the same as lambda expression and functor object. Lambda expressions are anonymous (don't have name, name generated by compiler and usually it's combination of "`__lambda_` + line number + column number"), to define lambda we put "_capture specifier_" `[]` for the function name, rest is similar to usual functions. 
```c++ ln:false
[](int n) { return (n % 2 == 1); }
// equal to, both return type will be deduced as bool
auto is_odd(int n) { return (n % 2 == 1); } // since C++14
```

In C++11 for first lambda versions compiler can deduce return type only if lambda is single statement, for complex expression return type of lambda function provided by trailing return type (similarly to usual functions).
```c++ ln:false
[](int n) -> bool { return (n % 2 == 1); }
auto is_odd(int n) -> bool { return (n % 2 == 1); }
```
In C++14 auto return type deduction start support complex expression only if all return types same, starting from C++17 it's no longer required

A lambda expression has access to global variables, static variables in the same scope, `local_thread` variable. By default, lambda expressions have very limited access to local variables, only to const integer and enum variables. 
```c++ fold:Example
int global_var = 10;
static int static_var = 20;
thread_local int thread_local_var = 30;

int main() {
    static int local_static_var {20};
    const int const_int {42};
    constexpr int constexpr_val {100};
    enum Color { RED = 1, GREEN = 2 };
    const Color color {RED};

    auto lambda = [](int n) { 
        return n + global_var
                 + static_var
                 + thread_local_var
                 + const_int
                 + constexpr_val
                 + color;
    };

    std::cout << lambda(1);
    return 0;
}
```


Lambda also have "capturing" mechanism. In this case functor will be _"functor with state"_. Captured variable will stored as private members of compiler-generated functor. 
* `{cpp} [n](int arg){ return n * arg; };` - capture local `n` variable by value (functor store own copy of variable). 
Variable is "const", it's can't be changed (until lambda not marked as mutable: `{cpp}[n](int arg) mutable { return ++n * arg; };`)

* `{cpp} [&n](int arg) { return ++n * arg; };` - capture by reference. Captured by reference can be modifiable and `mutable` not required. 
> If required to capture as const reference - starting from C++14 possible to use init-capture and pass variable as `std::as_const` (require `<utility>`) or use `std::cref` which will create `std::reference_wrapper` object (`<functional>`)
```c++ fold:Example
int local {3};

auto lambda = [&local_const = std::as_const(local)](int n) {
	return n + local_const;
}; // will create `const int& local_const;` in functor

auto lambda = [local_const = std::cref(local)](int n) {
    return n + local_const;
}; // will create `std::reference_wrapper<const int> local_const;`
```

* "_capture default_" provided:
	* `[=]` - will implicitly capture all variables by value (by-copy capture default)
	* `[&]` - will implicitly capture all variable by reference(by-reference capture default)
> Although compilers can optimize not used variables and not capture them, C++ standard doesn't guarantee this, so it's up to compiler and optimization level - capture unused local variable or not.

* Also possible to combine 
	* `[=, &a]` - capture `a` by reference, everything else by value 
	* `[&, a, b]` - capture `a` and `b` by value, everything else by reference. 

Lambda can be created inside class member function as well. In this case since [[0. Review of C++#Class functions in global scope|member function in C++ are in global scope]] and have hidden `this` argument (`{cpp}test.do_it()` <=>`{cpp}Test::do_it(&this)`), `this` is a local variable, which can be also captured by lambda. In another words, lambda in class can get *non-const* copy to `this`, as well as some additional capture options. 
* Even with implicit capture by value (`[=]`) `this` will be captured by reference
	* It's only work when default capture method provided, with `[]` `this` not captured =
	* In C++20 implicit capture of `this` via `[=]` deprecated and should be used `[=, this]` or `[=, *this]` 
	* Until C++20 `[=, this]` can generate warning or error. In C++20 it's will be equal to `[=]` (`this` by reference). 
* Capture "by reference" `[&this]` is not allowed. 
* From C++17 it's possible to capture `this` by value `[*this]`. 

Lambda can be stored in variable (in this case compiler will create functor and use it as type of variable). Variable in this case will be callable. 
Also, lambda can be returned from function (but it have own restriction, as return type and variable type which will store returned value type should be either `auto` (from C++14) or `std::function` (from C++11)).

```c++ fold:"Example"
using LambdaGreeterT = std::function<std::string(const std::string&)>;
LambdaGreeterT greeter(const std::string& salutation) {
  return [=](const std::string& name) 
  { return salutation + std::string(", ") + name; };
}

LambdaGreeterT greet = greeter("Hello");
std::cout << greet("students");

// From C++14
using namespace std::literals;
  
auto greeter(const std::string& salutation) {
  return [=](const std::string& name) 
  { salutation + ", "s + name; };
}


auto greet = greeter("Hello"s);
std::cout << greet("students"s);
```

> Version with `auto` quite interesting. It's relay on compiler type deduction and allow to return with such style not only lambda, but also classes defined inside function. Usually it's not possible without forward declaration.

When returning lambda from function it's dangerous to use capture by reference, similarly to returning reference to local variable. This case create dangling reference, since local variable will be destroyed when the function returns.  

Lambda expression with capture allows to implement _partial evaluation_ - functional programming technique, in which is data evaluated partially in stages. 

Starting from C++14 it's possible to create "_generic lambdas_" or "_polymorphic lambdas_" which uses `auto` arguments. In this case in functor will be generated `operator()` using `template` which will be instantiated with function arguments when it's gets called. 
```c++
auto summator {[](auto x, auto y) {return x + y;}};
func(2, 5);
func(str1, str2);
```

Also starting from C++14 it's possible to create variables in the capture specifier. They implicitly "`auto`" and must be initialized:
`{cpp}[x = 3](int y) { return x + y; };`
> It's also possible to use `{cpp}[x{3}]` 

For variable initialization capture doesn't required even if we use `[x = z + 3]`, since `z + 3` will be passed to functor constructor. With variable initialization also `{cpp}std::move()` can be used. 

### Some additional information
"Effective modern C++" have whole [[Chapter 6 - Lambda Expressions]] dedicated to lambdas, but it's only up to C+14. 

#### From cppreference 
Starting from C+17 lambdas extended `constexpr` use:
* `{cpp}operator()` will be `constexpr` explicitly if it satisfies the requirements of a `constexpr` function
* User-defined conversion function is `constexpr`
* Captured by reference data members compatible with `constexpr` expressions  
* Lambda can be used with `static_assert`

From C++20: 
* Added support of `consteval` for `operator()` if lambda captures is empty(`[]`)
> `consteval` functions also called "_immediate function_"
* Lambda with empty captures can be used as template parameter 
```c++ ln:false
template<auto F>
void foo() { F(); }

foo<[]{ std::cout << "hi"; }>(); 
```
* Lambda can be used in `{cpp}decltype([](int x){return x;}) t;`
* Lambda can be defined with an explicit template parameter list, have `requires`
```c++ ln:false nowrap
auto lambda = [[maybe_unused]]
              [x = 5]<typename T>(T a, int b) mutable noexcept->decltype(auto)
              requires std::integral<T> {
  return a + b + x;
};
```
> Fun example [Let's Write a Lambda in C++ - Ben Deane - CppCon 2023](https://www.youtube.com/watch?v=EqiLTgQcDPM)

* If no captures are specified, the closure type has a defaulted copy assignment operator and a defaulted move assignment operator. Otherwise, it has a deleted copy assignment operator (this includes the case when there is a capture-default ﻿, even if it does not actually capture anything).
* Capture variadic pack: `[...args]`

C++23: 
* Lambda can be `static`.
* Lambda can use explicit object parameter.
```c++ ln:false
// Allow to change captured without mutable
auto lambda = [x = 5](this auto& self) {
    self.x++; 
    return self.x;
};

// self - it's lambda itself
auto lambda = [](this auto& self) {
    // self can be used for recursive call
    return self(...);
};

// Allow to avoid class's this capture 
class C {
    void f() {
        auto lambda = [](this auto& self) {
            // no access to C::member
        };
    }
};
```


#### Examples of how compiler generate lambdas from [cppinsights.io]()
As test example used code 
```c++ 
void takes_fn_ptr(bool (*fn)(int)) {  }
struct test {
	void func() {
        int local {};
        
        takes_fn_ptr([](int n) { return (2 % n == 1);}); 

        [&](int n) { return (local % n == 1);};
        [=](int n) { return (local % n == 1);};  
        [local](int n) { return (local % 2 == 1);};
        [&local](int n) { return (local % 2 == n);};
        [this](int n) { return (n % this->m_mem == 1);};
        [*this](int n) { return (n % this->m_mem == 1);};  
    }
private:
  	int m_mem{};
};
```
In this example only default lambda can be passed as argument to another function, since it doesn't have any copy to `this`

```c++ fold:"takes_fn_ptr([](int n) { return (2 % n == 1);});"
class __lambda_15_22
{
public: 
	inline /*constexpr */ bool operator()(int n) const
    {
	    return ((2 % n) == 1);
    }
      
	using retType_15_22 = bool (*)(int);
// conversion operator which allows to convert lambda to function pointer
    inline constexpr operator retType_15_22 () const noexcept
    {
	    return __invoke;
    }
      
private: 
    static inline /*constexpr */ bool __invoke(int n)
    {
	    return __lambda_15_22{}.operator()(n);
    }
};
    
takes_fn_ptr(__lambda_15_22{}.operator __lambda_15_22::retType_15_22());
```

```c++ fold:"[=](int n) { return (local % n == 1);};"
class __lambda_19_9
{
public:
  __lambda_19_9(int & _local) : local{_local} {} 
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % n) == 1);
  }
  
private: 
  const int local; // Copy of local variable
} __lambda_19_9{local};
```

```c++ fold:"[&](int n) { return (local % n == 1);};"
class __lambda_23_9
{
public:
  __lambda_23_9(int& _local) : local{_local}{} 
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % n) == 1);
  }
  
private: 
  int& local;
//   ^ what make it different - reference to local variable  
} __lambda_23_9{local};
```

```c++ fold:"[local](int n) { return (local % 2 == 1);};"
class __lambda_27_9
{
public:
  __lambda_27_9(int & _local) : local{_local} {}
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % 2) == 1);
  }
  
private:
  int local;
} __lambda_27_9{local};
```

```c++ fold:"[&local](int n) { return (local % 2 == n);};"   
class __lambda_31_9
{
public:
  __lambda_31_9(int & _local) : local{_local} {} 
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % 2) == n);
  }
  
private: 
  int& local;
} __lambda_31_9{local};
```

```c++ fold:"[this](int n) { return (n % this->m_mem == 1);};"
class __lambda_35_9
{
public: 
  public: __lambda_35_9(test* _this) : __this{_this} {}
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((n % __this->m_mem) == 1);
  }
  
private: 
  test* __this;
} __lambda_35_9{this};
```

```c++ fold:"[*this](int n) { return (n % this->m_mem == 1);};"
class __lambda_39_9
{
public:
  __lambda_39_9(const test& _this) : __this{_this} {}
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((n % (&__this)->m_mem) == 1);
  }
  
private: 
  const test __this;
//^^^ copy of this  
} __lambda_39_9{*this};
```

## Insert iterators 
An output stream iterator when value is assigned to actually perform insertion into output stream. But for container there are separately _insert iterators_: `std::back_insert_iterator`, `std::front_insert_iterator`, and `std::insert_iterator` (which add element to any given position). 
To get insert iterator we need to call _inserter_ function: `{cpp}std::back_inserter(Container& c)`, `{cpp}std::front_inserter(Container& c)`, `{cpp}std::inserter(Container& c, typename Container::iterator i)`, where `i` - position to insert. Assigning to returned insert iterator will add a new element to container using container's `::push_back()`/`::push_front()`/`insert()` (which means that not every container can support insert iterator).

|                                                                                        | `back_inserter()` | `front_inserter()` | `inserter()` |
| -------------------------------------------------------------------------------------- | :---------------: | :----------------: | :----------: |
| `std::vector`                                                                          |         ✅         |         ❌          |      ✅       |
| `std::deque`                                                                           |         ✅         |         ✅          |      ✅       |
| `std::list`                                                                            |         ✅         |         ✅          |      ✅       |
| `std::forward_list`                                                                    |         ❌         |         ✅          |      ✅       |
| `std::set`<br>`std::multiset`<br>`std::unordered_set`<br>`std::unordered_multiset`<br> |         ❌         |         ❌          |      ✅       |
| `std::map`<br>`std::multimap`<br>`std::unordered_map`<br>`std::unordered_multimap`<br> |         ❌         |         ❌          |      ✅       |
| `std::queue`<br>`std::stack`<br>`std::priority_queue`                                  |         ❌         |         ❌          |      ❌       |
| `array`                                                                                |         ❌         |         ❌          |      ❌       |
```c++
std::vector vec {1, 3, 4};
auto el2 {std::next(vec.begin())};
auto insIt {std::inserter(vec, el2)};
*insIt = 2;
```
Keep in mind that some container after container modification can invalidate iterators. In example above `el2` after using insert iterator will be invalid (container might rearrange elements, or allocate large size memory space to store n+1 elements etc.) 

Input iterators mostly used with STL algorithm. Also one of usage is in conjunction with stream iterators, for example to write simpler code for copying data from stream to container. 
```c++
using StringIter = std::istream_iterator<std::string>;
StringIter inItr{std::cin};
StringIter inItrEnd{};

std::vector<std::string> vec{};
auto vecInsItr {std::back_inserter(vec)};

while (inItr != inItrEnd) {
	vecInsItr = *inItr;
    ++inItr;
}  

// or 
std::copy(inItr, inItrEnd, std::back_inserter(vec));
```

## Library Function Objects
In `<functional>` header file can be found STL functional objects for generic operators for arithmetic, logic, relational operations etc.
They widely used with algorithms as well. 

|                    |        |                        |             |
| ------------------ | ------ | ---------------------- | ----------- |
| ##### Arithmetic   |        | ##### Comparisons      |             |
| `std::plus`        | x + y  | `std::equal_to`        | x == y      |
| `std::minus`       | x - y  | `std::not_equal_to`    | x != y      |
| `std::multiplies`  | x * y  | `std::greater`         | x > y  <br> |
| `std::divides`     | x / y  | `std::less`            | x < y  <br> |
| `std::modulus`     | x % y  | `std::greater_equal`   | x >= y      |
| `std::negate`      | -x     | `std::less_equal`      | x <= y      |
|                    |        |                        |             |
| ##### Logical      |        | ##### Bitwise          |             |
| `std::logical_and` | x && y | `std::bit_and`         | x & y       |
| `std::logical_or`  | x \| y | `std::bit_or`          | x \| y      |
| `std::logical_not` | !x     | `std::bit_xor`         | x ^ y<br>   |
|                    |        | `std::bit_not` (C++14) | ~x          |


