## STL Algorithms overview
The C++ STL defines a number of functions in `<argorithm>` header, which implements classic algorithms as well as a number of other useful routines. STL algorithms coded and tested as part of the standard library implementation, might be more accurate and more efficient (even use some internal compiler features). 

Typically to STL algorithm passed an iterator range to specify which elements in container will be processed (`{cpp}begin()`, `{cpp}end()` means to process the entire container). 
> From C++ also possible to use [Ranged algorithms](https://cppreference.com/w/cpp/algorithm/ranges.html) library: `{cpp}std::sort(vec.begin(), vec.end())` equal to `{cpp}std::ranges::sort(vec)` 

> Also exists algorithms, which works not with container: `{cpp}std::min()`, `{cpp}std::max()`, `{cpp}std::clamp()`, `{cpp}std::minmax()` (containers variant of those algorithms have `_element()` suffix or defined in `ranges::` library: `{cpp} std::max_element()`/`std::ranges::max()`)

Most algorithms return either
* an iterator representing a particular element
`{cpp} InputIt std::find(InputIt first, InputIt last, const T& value)` - return an iterator to first element equal to T or iterator to `end()`/`last` in element not found; 
* a value containing the result of some operation on the elements. 
`{cpp} T accumulate(InputIt first, InputIt last, T init);` - return sum of the given value `init` and the elements in the range `[first, last)`.

> also some algorithms return `bool`, algorithms like `{cpp}std::all_of()`, `{cpp}std::binary_search()`, `{cpp} std::is_heap()`

Many algorithms takes as argument a callable object, such argument called "predicate". Predicate called with elements of container and returns bool. Most of algorithm have own predicate (`std::sort` as predicate use `operator<`, but we can provide any compare function instead). 
As a predicate we can pass
```cpp fold:"pointers to function" ln:false
bool compare(int a, int b) { return a < b; }
std::ranges::sort(arr, &compare); // explicit pointer
std::ranges::sort(arr, compare);  // implicit conversion to pointer

std::ranges::sort(arr, 
                  std::bind(compare, 
                            std::placeholders::_1, // first func argument
                            std::placeholders::_2)); // second func arg
``` 

```cpp fold:"functors (class object with implemented operator())" ln:false
struct Comparator {
    bool operator()(int a, int b) const { return a < b; }
};

// using temporary object
std::ranges::sort(arr, Comparator()); 
/* Important note, () - it's not function call/operator() call. 
   It's object initialization, similarly to Comparator{}. 
 */

// with object
Comparator cmp{};
std::ranges::sort(arr, cmp);

//or 
struct {
    bool operator()(int a, int b) const { return a < b; }
} cmp;
std::ranges::sort(arr, cmp);
```

```cpp fold:"lambda-functions" ln:false
std::ranges::sort(arr, [&](int a, int b) { return a < b; });
```

```cpp fold:"std::function object from <functional>" ln:false
std::function<bool(int, int)> cmp = [](int a, int b) { return a < b; };
std::ranges::sort(arr, cmp);

std::ranges::sort(arr, std::less_equal<int>());
//          template type is optional ^^^^^

std::ranges::sort(arr, std::ranges::greater());

std::ranges::sort(arr, std::not_fn(std::less<int>()));

// In some cases 
struct Point {
    int x, y;
    void print() const { std::cout << x << " " << y << "\n"; }
};
std::vector<Point> points = {{1, 2}, {3, 4}};
std::ranges::for_each(points, std::mem_fn(&Point::print));
// but it's can be replaced with more usual approach 
std::ranges::for_each(points, [](const Point& p) { p.print(); });
```

Many algorithms have `_if`/`_if_not` version, which takes predicate and modify base version with that predicate

```cpp unwrap ln:false 
// first, last - the pair of iterators defining the range of elements to examine
// value 	- 	value to compare the elements to 
template<class InputIt, class T>
InputIt find(InputIt first, InputIt last, const T& value);

// p - unary predicate which returns ​_true_ for the required element
template<class InputIt, class UnaryPred>
InputIt find_if(InputIt first, InputIt last, UnaryPred p);

// q - unary predicate which returns _false_ for the required element
template<class InputIt, class UnaryPred>
InputIt find_if_not(InputIt first, InputIt last, UnaryPred q);
```

Algorithm which change elements can also have `_copy` version. While base version overwrites the data in the original range, `_copy` version writes the data to a different iterator range
(`{cpp} std::replace()` and `{cpp} std::replace_copy()`)

## Lambda expressions 
When the compiler encounters a lambda expression, it will generate [[2. Special Member Functions and Operator Overloading#Functor|Functor]] class with function body provided in lambda body, return type the same as lambda expression and functor object. Lambda expressions are anonymous (don't have name, name generated by compiler and usually it's combination of "`__lambda_` + line number + column number"), to define lambda we put "_capture specifier_" `[]` for the function name, rest is similar to usual functions. 
```cpp ln:false
[](int n) { return (n % 2 == 1); }
// equal to, both return type will be deduced as bool
auto is_odd(int n) { return (n % 2 == 1); } // since C++14
```

In C++11 for first lambda versions compiler can deduce return type only if lambda is single statement, for complex expression return type of lambda function provided by trailing return type (similarly to usual functions).
```cpp ln:false
[](int n) -> bool { return (n % 2 == 1); }
auto is_odd(int n) -> bool { return (n % 2 == 1); }
```
In C++14 auto return type deduction start support complex expression only if all return types same, starting from C++17 it's no longer required

A lambda expression has access to global variables, static variables in the same scope, `local_thread` variable. By default, lambda expressions have very limited access to local variables, only to const integer and enum variables. 
```cpp fold:Example
int global_var = 10;
static int static_var = 20;
thread_local int thread_local_var = 30;

int main() {
    static int local_static_var {20};
    const int const_int {42};
    constexpr int constexpr_val {100};
    enum Color { RED = 1, GREEN = 2 };
    const Color color {RED};

    auto lambda = [](int n) { 
        return n + global_var
                 + static_var
                 + thread_local_var
                 + const_int
                 + constexpr_val
                 + color;
    };

    std::cout << lambda(1);
    return 0;
}
```


Lambda also have "capturing" mechanism. In this case functor will be _"functor with state"_. Captured variable will stored as private members of compiler-generated functor. 
* `{cpp} [n](int arg){ return n * arg; };` - capture local `n` variable by value (functor store own copy of variable). 
Variable is "const", it's can't be changed (until lambda not marked as mutable: `{cpp}[n](int arg) mutable { return ++n * arg; };`)

* `{cpp} [&n](int arg) { return ++n * arg; };` - capture by reference. Captured by reference can be modifiable and `mutable` not required. 
> If required to capture as const reference - starting from C++14 possible to use init-capture and pass variable as `std::as_const` (require `<utility>`) or use `std::cref` which will create `std::reference_wrapper` object (`<functional>`)
```cpp fold:Example
int local {3};

auto lambda = [&local_const = std::as_const(local)](int n) {
	return n + local_const;
}; // will create `const int& local_const;` in functor

auto lambda = [local_const = std::cref(local)](int n) {
    return n + local_const;
}; // will create `std::reference_wrapper<const int> local_const;`
```

* "_capture default_" provided:
	* `[=]` - will implicitly capture all variables by value (by-copy capture default)
	* `[&]` - will implicitly capture all variable by reference(by-reference capture default)
> Although compilers can optimize not used variables and not capture them, C++ standard doesn't guarantee this, so it's up to compiler and optimization level - capture unused local variable or not.

* Also possible to combine 
	* `[=, &a]` - capture `a` by reference, everything else by value 
	* `[&, a, b]` - capture `a` and `b` by value, everything else by reference. 

Lambda can be created inside class member function as well. In this case since [[0. Review of C++#Class functions in global scope|member function in C++ are in global scope]] and have hidden `this` argument (`{cpp}test.do_it()` <=>`{cpp}Test::do_it(&this)`), `this` is a local variable, which can be also captured by lambda. In another words, lambda in class can get *non-const* copy to `this`, as well as some additional capture options. 
* Even with implicit capture by value (`[=]`) `this` will be captured by reference
	* It's only work when default capture method provided, with `[]` `this` not captured =
	* In C++20 implicit capture of `this` via `[=]` deprecated and should be used `[=, this]` or `[=, *this]` 
	* Until C++20 `[=, this]` can generate warning or error. In C++20 it's will be equal to `[=]` (`this` by reference). 
* Capture "by reference" `[&this]` is not allowed. 
* From C++17 it's possible to capture `this` by value `[*this]`. 

Lambda can be stored in variable (in this case compiler will create functor and use it as type of variable). Variable in this case will be callable. 
Also, lambda can be returned from function (but it have own restriction, as return type and variable type which will store returned value type should be either `auto` (from C++14) or `std::function` (from C++11)).

```cpp fold:"Example"
using LambdaGreeterT = std::function<std::string(const std::string&)>;
LambdaGreeterT greeter(const std::string& salutation) {
  return [=](const std::string& name) 
  { return salutation + std::string(", ") + name; };
}

LambdaGreeterT greet = greeter("Hello");
std::cout << greet("students");

// From C++14
using namespace std::literals;
  
auto greeter(const std::string& salutation) {
  return [=](const std::string& name) 
  { salutation + ", "s + name; };
}


auto greet = greeter("Hello"s);
std::cout << greet("students"s);
```

> Version with `auto` quite interesting. It's relay on compiler type deduction and allow to return with such style not only lambda, but also classes defined inside function. Usually it's not possible without forward declaration.

When returning lambda from function it's dangerous to use capture by reference, similarly to returning reference to local variable. This case create dangling reference, since local variable will be destroyed when the function returns.  

Lambda expression with capture allows to implement _partial evaluation_ - functional programming technique, in which is data evaluated partially in stages. 

Starting from C++14 it's possible to create "_generic lambdas_" or "_polymorphic lambdas_" which uses `auto` arguments. In this case in functor will be generated `operator()` using `template` which will be instantiated with function arguments when it's gets called. 
```cpp
auto summator {[](auto x, auto y) {return x + y;}};
func(2, 5);
func(str1, str2);
```

Also starting from C++14 it's possible to create variables in the capture specifier. They implicitly "`auto`" and must be initialized:
`{cpp}[x = 3](int y) { return x + y; };`
> It's also possible to use `{cpp}[x{3}]` 

For variable initialization capture doesn't required even if we use `[x = z + 3]`, since `z + 3` will be passed to functor constructor. With variable initialization also `{cpp}std::move()` can be used. 

### Some additional information
"Effective modern C++" have whole [[Chapter 6 - Lambda Expressions]] dedicated to lambdas, but it's only up to C+14. 

#### From cppreference 
Starting from C+17 lambdas extended `constexpr` use:
* `{cpp}operator()` will be `constexpr` explicitly if it satisfies the requirements of a `constexpr` function
* User-defined conversion function is `constexpr`
* Captured by reference data members compatible with `constexpr` expressions  
* Lambda can be used with `static_assert`

From C++20: 
* Added support of `consteval` for `operator()` if lambda captures is empty(`[]`)
> `consteval` functions also called "_immediate function_"
* Lambda with empty captures can be used as template parameter 
```cpp ln:false
template<auto F>
void foo() { F(); }

foo<[]{ std::cout << "hi"; }>(); 
```
* Lambda can be used in `{cpp}decltype([](int x){return x;}) t;`
* Lambda can be defined with an explicit template parameter list, have `requires`
```cpp ln:false nowrap
auto lambda = [[maybe_unused]]
              [x = 5]<typename T>(T a, int b) mutable noexcept->decltype(auto)
              requires std::integral<T> {
  return a + b + x;
};
```
> Fun example [Let's Write a Lambda in C++ - Ben Deane - CppCon 2023](https://www.youtube.com/watch?v=EqiLTgQcDPM)

* If no captures are specified, the closure type has a defaulted copy assignment operator and a defaulted move assignment operator. Otherwise, it has a deleted copy assignment operator (this includes the case when there is a capture-default ﻿, even if it does not actually capture anything).
* Capture variadic pack: `[...args]`

C++23: 
* Lambda can be `static`.
* Lambda can use explicit object parameter.
```cpp ln:false
// Allow to change captured without mutable
auto lambda = [x = 5](this auto& self) {
    self.x++; 
    return self.x;
};

// self - it's lambda itself
auto lambda = [](this auto& self) {
    // self can be used for recursive call
    return self(...);
};

// Allow to avoid class's this capture 
class C {
    void f() {
        auto lambda = [](this auto& self) {
            // no access to C::member
        };
    }
};
```


#### Examples of how compiler generate lambdas from [cppinsights.io]()
As test example used code 
```cpp 
void takes_fn_ptr(bool (*fn)(int)) {  }
struct test {
	void func() {
        int local {};
        
        takes_fn_ptr([](int n) { return (2 % n == 1);}); 

        [&](int n) { return (local % n == 1);};
        [=](int n) { return (local % n == 1);};  
        [local](int n) { return (local % 2 == 1);};
        [&local](int n) { return (local % 2 == n);};
        [this](int n) { return (n % this->m_mem == 1);};
        [*this](int n) { return (n % this->m_mem == 1);};  
    }
private:
  	int m_mem{};
};
```
In this example only default lambda can be passed as argument to another function, since it doesn't have any copy to `this`

```cpp fold:"takes_fn_ptr([](int n) { return (2 % n == 1);});"
class __lambda_15_22
{
public: 
	inline /*constexpr */ bool operator()(int n) const
    {
	    return ((2 % n) == 1);
    }
      
	using retType_15_22 = bool (*)(int);
// conversion operator which allows to convert lambda to function pointer
    inline constexpr operator retType_15_22 () const noexcept
    {
	    return __invoke;
    }
      
private: 
    static inline /*constexpr */ bool __invoke(int n)
    {
	    return __lambda_15_22{}.operator()(n);
    }
};
    
takes_fn_ptr(__lambda_15_22{}.operator __lambda_15_22::retType_15_22());
```

```cpp fold:"[=](int n) { return (local % n == 1);};"
class __lambda_19_9
{
public:
  __lambda_19_9(int & _local) : local{_local} {} 
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % n) == 1);
  }
  
private: 
  const int local; // Copy of local variable
} __lambda_19_9{local};
```

```cpp fold:"[&](int n) { return (local % n == 1);};"
class __lambda_23_9
{
public:
  __lambda_23_9(int& _local) : local{_local}{} 
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % n) == 1);
  }
  
private: 
  int& local;
//   ^ what make it different - reference to local variable  
} __lambda_23_9{local};
```

```cpp fold:"[local](int n) { return (local % 2 == 1);};"
class __lambda_27_9
{
public:
  __lambda_27_9(int & _local) : local{_local} {}
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % 2) == 1);
  }
  
private:
  int local;
} __lambda_27_9{local};
```

```cpp fold:"[&local](int n) { return (local % 2 == n);};"   
class __lambda_31_9
{
public:
  __lambda_31_9(int & _local) : local{_local} {} 
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((local % 2) == n);
  }
  
private: 
  int& local;
} __lambda_31_9{local};
```

```cpp fold:"[this](int n) { return (n % this->m_mem == 1);};"
class __lambda_35_9
{
public: 
  public: __lambda_35_9(test* _this) : __this{_this} {}
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((n % __this->m_mem) == 1);
  }
  
private: 
  test* __this;
} __lambda_35_9{this};
```

```cpp fold:"[*this](int n) { return (n % this->m_mem == 1);};"
class __lambda_39_9
{
public:
  __lambda_39_9(const test& _this) : __this{_this} {}
  inline /*constexpr */ bool operator()(int n) const
  {
    return ((n % (&__this)->m_mem) == 1);
  }
  
private: 
  const test __this;
//^^^ copy of this  
} __lambda_39_9{*this};
```

## Insert iterators 
An output stream iterator when value is assigned to actually perform insertion into output stream. But for container there are separately _insert iterators_: `std::back_insert_iterator`, `std::front_insert_iterator`, and `std::insert_iterator` (which add element to any given position). 
To get insert iterator we need to call _inserter_ function: `{cpp}std::back_inserter(Container& c)`, `{cpp}std::front_inserter(Container& c)`, `{cpp}std::inserter(Container& c, typename Container::iterator i)`, where `i` - position to insert. Assigning to returned insert iterator will add a new element to container using container's `::push_back()`/`::push_front()`/`insert()` (which means that not every container can support insert iterator).

|                                                                                        | `back_inserter()` | `front_inserter()` | `inserter()` |
| -------------------------------------------------------------------------------------- | :---------------: | :----------------: | :----------: |
| `std::vector`                                                                          |         ✅         |         ❌          |      ✅       |
| `std::deque`                                                                           |         ✅         |         ✅          |      ✅       |
| `std::list`                                                                            |         ✅         |         ✅          |      ✅       |
| `std::forward_list`                                                                    |         ❌         |         ✅          |      ✅       |
| `std::set`<br>`std::multiset`<br>`std::unordered_set`<br>`std::unordered_multiset`<br> |         ❌         |         ❌          |      ✅       |
| `std::map`<br>`std::multimap`<br>`std::unordered_map`<br>`std::unordered_multimap`<br> |         ❌         |         ❌          |      ✅       |
| `std::queue`<br>`std::stack`<br>`std::priority_queue`                                  |         ❌         |         ❌          |      ❌       |
| `array`                                                                                |         ❌         |         ❌          |      ❌       |
```cpp
std::vector vec {1, 3, 4};
auto el2 {std::next(vec.begin())};
auto insIt {std::inserter(vec, el2)};
*insIt = 2;
```
Keep in mind that some container after container modification can invalidate iterators. In example above `el2` after using insert iterator will be invalid (container might rearrange elements, or allocate large size memory space to store n+1 elements etc.) 

Input iterators mostly used with STL algorithm. Also one of usage is in conjunction with stream iterators, for example to write simpler code for copying data from stream to container. 
```cpp
using StringIter = std::istream_iterator<std::string>;
StringIter inItr{std::cin};
StringIter inItrEnd{};

std::vector<std::string> vec{};
auto vecInsItr {std::back_inserter(vec)};

while (inItr != inItrEnd) {
	vecInsItr = *inItr;
    ++inItr;
}  

// or 
std::copy(inItr, inItrEnd, std::back_inserter(vec));
```

## Library Function Objects
In `<functional>` header file can be found STL functional objects for generic operators for arithmetic, logic, relational operations etc.
They widely used with algorithms as well. 

|                    |        |                        |             |
| ------------------ | ------ | ---------------------- | ----------- |
| Arithmetic         |        | Comparisons            |             |
| `std::plus`        | x + y  | `std::equal_to`        | x == y      |
| `std::minus`       | x - y  | `std::not_equal_to`    | x != y      |
| `std::multiplies`  | x * y  | `std::greater`         | x > y  <br> |
| `std::divides`     | x / y  | `std::less`            | x < y  <br> |
| `std::modulus`     | x % y  | `std::greater_equal`   | x >= y      |
| `std::negate`      | -x     | `std::less_equal`      | x <= y      |
|                    |        |                        |             |
| Logical            |        | Bitwise                |             |
| `std::logical_and` | x && y | `std::bit_and`         | x & y       |
| `std::logical_or`  | x \| y | `std::bit_or`          | x \| y      |
| `std::logical_not` | !x     | `std::bit_xor`         | x ^ y<br>   |
|                    |        | `std::bit_not` (C++14) | ~x          |

## Iterators type (cpprefernce)
In modern C++ there are 6 kinds of iterator: 
* Input Iterator
* Output Iterator
* Forward Iterator
* Bidirectional Iterator
* Random Access Iterator 
* Contiguous Iterator. 

All of the iterator categories (except Output Iterator) can be organized into a hierarchy, where more powerful iterator categories support the operations of less powerful categories. If an iterator also satisfies the requirements of Output Iterator, then it is called a _mutable iterator_ and supports both input and output.

|                        | write | read | increment <br>without <br>multiple passes | increment <br>with multiple passes | decrement | random    <br>access | contiguous<br>storage |
| ---------------------- | ----- | ---- | ----------------------------------------- | ---------------------------------- | --------- | -------------------- | --------------------- |
| Output Iterator        | +     |      | +                                         |                                    |           |                      |                       |
| Input Iterator         |       | +    | +                                         |                                    |           |                      |                       |
| Forward Iterator       |       | +    | +                                         | +                                  |           |                      |                       |
| Bidirectional Iterator |       | +    | +                                         | +                                  | +         |                      |                       |
| Random Access Iterator |       | +    | +                                         | +                                  | +         | +                    |                       |
| Contiguous Iterator    |       | +    | +                                         | +                                  | +         | +                    | +                     |

|                        |                                                                                                                                                            |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Contiguous Iterator    | `std::vector`, `std::array`, `std::string`, `std::basic_string`, `std::span`, `std::string_view`                                                           |
| Random Access Iterator | `std::deque`, `std::valarray`,                                                                                                                             |
| Bidirectional Iterator | `std::list`, `std::map`, `std::multimap`, `std::set`, `std::multiset`, `std::reverse_iterator`                                                             |
| Forward Iterator       | `std::forward_list`, `std::unordered_map`, `std::unordered_multimap`, `std::unordered_set`, `std::unordered_multiset`                                      |
| Input Iterator         | `std::istream_iterator`, `std::stringstream`, `std::istreambuf_iterator`, `std::filesystem::directory_iterator`                                            |
| Output Iterator        | `std::ostream_iterator`, `std::ostreambuf_iterator`, `std::back_insert_iterator`, `std::front_insert_iterator`, `std::stringstream`,`std::insert_iterator` |


## Random 
### Random in old C++
In C++ available inherited from C `{cpp}std::rand()`, function declared in `<cstdlib>`. Calling `{cpp}std::rand()` returns the next pseudo-random number in range `[0, RAND_MAX)`. 
Some math can be used for setting custom range.
* `{cpp} 1.0f * std::rand() / RAND_MAX` - get random value in range `[0.0 1.0]`
* `{cpp} 99 * std::rand() / RAND_MAX + 1` - get random value in range `[1 100]`

To seed random generator used `{cpp}std::srand()`, typical approach is use current time with `{cpp}std::time(0)`. 
This approach have several disadvantages. The PRNG algorithm is chosen by the implementer, typically `{cpp}std::rand()` implementation generate number which are not very random, especially in the last few digits. Also value needs to be scaled, which introduces bias. In general, `{cpp}std::rand()` has poor cryptographic security. 

### Random in modern C++
Starting from C++11 available new approach for random number generation defined in `<random>` header. It of a *Random Device*, *Random Number Engine*, and *Distribution*. 

```mermaid
---
config:
  layout: elk
  theme: dark
---
flowchart LR
    A[Random Device] -->|Seed| B(Random Number Engine)
    B -->|Random Number| C(Distribution n, m)
    C -->|Random Number between m and n| STOP[ ]

    style STOP  fill:#FFFFFF00, stroke:#FFFFFF00;
```


Random number engine is implemented as a functor. The constructor generates the sequence of pseudo-random numbers, `{cpp}operator()` return next number from the sequence.
* `{cpp}std::default_random_engine()` implementation-defined generator, may be a wrapper around the `{cpp}std::rand()` implementation. 
* `{cpp}std::mt19937()` - "Mersenne Twister" with period of $2^{1993-1}$ - almost crypto secure, has a lot of state (slow to initialize), but still very fast at generating number.
 >[!note] 
> Also exist `minstd_rand0`, `minstd_rand`, `mt19937_64`, `ranlux24_base`, `ranlux48_base`, `ranlux24`, `ranlux48`, `knuth_b`, `philox4x32`,`philox4x64`

A distribution is also implemented as a functor. It's constructor takes the range as arguments. It's overloaded  `{cpp}operator()` takes as an argument function object which returns a number each time it's called (including random generator). The distribution will then rescale this number to fit in the range and return it. A distribution can be used with any numerical data sequence, not just random number 
There are lots of distribution functions, one of common is distribution which provide uniformly distributed value, `{cpp}std::uniform_int_distribution<T>(m, n)`, `{cpp}std::uniform_real_distribution<T>(m, n)` 
>[!note]- List of other distribution functions 
>|                                                 |
>| ------------------------------|
>|*Uniform distributions *  |
>|[`uniform_int_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/uniform_int_distribution.html "cpp/numeric/random/uniform int distribution")                      |
>|[`uniform_real_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/uniform_real_distribution.html "cpp/numeric/random/uniform real distribution")                   |
>|*Bernoulli distributions*  |
>|[`bernoulli_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/bernoulli_distribution.html "cpp/numeric/random/bernoulli distribution")                            |
>|[`binomial_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/binomial_distribution.html "cpp/numeric/random/binomial distribution")                               |
>|[`negative_binomial_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/negative_binomial_distribution.html "cpp/numeric/random/negative binomial distribution")    |
>|[`geometric_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/geometric_distribution.html "cpp/numeric/random/geometric distribution")                            |
>|*Poisson distributions*      |
>|[`poisson_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/poisson_distribution.html "cpp/numeric/random/poisson distribution")                                  |
>|[`exponential_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/exponential_distribution.html "cpp/numeric/random/exponential distribution")                      |
>|[`gamma_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/gamma_distribution.html "cpp/numeric/random/gamma distribution")                                        |
>|[`weibull_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/weibull_distribution.html "cpp/numeric/random/weibull distribution")                                  |
>|[`extreme_value_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/extreme_value_distribution.html "cpp/numeric/random/extreme value distribution")  |
>|*Normal distributions*  |
>|[`normal_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/normal_distribution.html "cpp/numeric/random/normal distribution")                                     |
>|[`lognormal_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/lognormal_distribution.html "cpp/numeric/random/lognormal distribution")                            |
>|[`chi_squared_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/chi_squared_distribution.html "cpp/numeric/random/chi squared distribution")                      |
>|[`cauchy_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/cauchy_distribution.html "cpp/numeric/random/cauchy distribution")                                     |
>|[`fisher_f_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/fisher_f_distribution.html "cpp/numeric/random/fisher f distribution")                               |
>|[`student_t_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/student_t_distribution.html "cpp/numeric/random/student t distribution")                            |
>|*Sampling distributions*     |
>|[`discrete_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/discrete_distribution.html "cpp/numeric/random/discrete distribution")                               |
>|[`piecewise_constant_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution.html "cpp/numeric/random/piecewise constant distribution") |
>|[`piecewise_linear_distribution<T>(m, n)`](https://cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution.html "cpp/numeric/random/piecewise linear distribution")|

`{cpp} random_device` produces a hardware-generated random number from system entropy data (like cpu temperature). However, it will produce a pseudo-random number if the system does not provide entropy data or if compiler doesn't support it (like some GNU C++ version). If all the entropy data has been used up it will stop and wait until more data become available. It's slower than mt19937 but is crypto secure if fully implemented. Random device can be used stand-alone as functor or used as seed for random generator.
```cpp
std::random_device rd{};
auto randNum {rt()};
```

```cpp
std::mt19937 rEng{std::random_device{}()};
std::uniform_int_distribution<int> idist(0, 10); // constructor
int randInt {idist(rEng)}; // operator()

std::uniform_real_distribution<double> fdist(0.0, 1.0);
double randDouble {fdist(rEng)};
```



## STL Algorithms
### Searching algorithms
>[!Note]
> Mentioned function signature is not fully correct from language perspective, optional arguments can be only last function arguments, but theoretically it's valid - at the beggining `ExecutionPolicy&& policy = std::execution::seq` it's "use or not", in language it's two different template overloads 

* Searches for an element equal to `value` (using `operator==`)
Parallel version works with *Forward iterators* range
>[!code-ref]+ `{cpp}std::find()` | $O(n)$
>```cpp
>InputIt std::find(InputIt first, InputIt last, const T& value);
>
>ForwardIt std::find(ExecutionPolicy&& policy, 
>                     ForwardIt first, ForwardIt last, 
>                     const T& value);
>```

* Searches for an element for which _Unary_ predicate `p` returns `true`.
Parallel version works with *Forward iterators* range 
>[!code-ref]+ `{cpp}std::find_if()` | $O(n)$
>```cpp
>InputIt std::find_if(InputIt first, InputIt last, UnaryPred p);
>
>ForwardIt std::find_if(ExecutionPolicy&& policy,
>					   ForwardIt first, ForwardIt last, 
>					   UnaryPred p);
>```

* Searches for an element for which _Unary_ predicate `p` returns `false`.
Parallel version works with *Forward iterators* range 
>[!code-ref]+ `{cpp}std::find_if_not()` | $O(n)$
>```cpp
>InputIt std::find_if_not(InputIt first, InputIt last, UnaryPred q);
>
>ForwardIt std::find_if_not(ExecutionPolicy&& policy, 
>                            ForwardIt first, ForwardIt last, 
>                            UnaryPred p);
>```

> STL doesn't have algorithm to search last match, `{cpp}std::find_end()` is different algorithm. Last element can be find using _reverse iterators_ and use `{cpp}std::rend()` as "not found".

* Searches the range `[first, last)` for any of the elements in the range `[s_first, s_last)`.
Parallel version requires _Forward iterators_ range for "reference range"
>[!code-ref]+ `{cpp}std::find_first_of()` | $O(n*m)$
>```cpp
>InputIt std::find_first_of(InputIt first, InputIt last,
>                            ForwardIt s_first, ForwardIt s_last);
>
>ForwardIt1 std::find_first_of(ExecutionPolicy&& policy, 
>                               ForwardIt1 first, ForwardIt last, 
>                               ForwardIt s_first, ForwardIt s_last, 
>                               BinaryPred p = std::equal_to());
>```

```cpp
auto str {"Hello world"s};
auto vowels {"aeiou"s};
auto case_insensitive_equal {[](auto a, auto b) {
    return std::tolower(a) == std::tolower(b);
}};
auto vowel {std::find_first_of(std::cbegin(str), std::cend(str), 
							  std::cbegin(vowels), std::cend(vowels), 
							  case_insensitive_equal)};
if (vowel != str.cend())
    std::cout << "First vowel is " << *vowel 
              << " at index " << std::distance(std::cbegin(str), vowel) 
              <<'\n';
```
> To find next match we can use found iterator and pass next iterator after it back to search function using `{cpp} std::next()`.

* Looks for two neighboring elements that have the same value
>[!code-ref]+ `{cpp}std::adjacent_find()` | $O(n)$
>```cpp
>ForwardIt std::adjacent_find(ExecutionPolicy&& policy = std::execution::seq,
>                              ForwardIt first, ForwardIt last, 
>                              BinaryPred p = std::equal_to());
>```

* Looks for a sequence of `count` successive elements which have the same given `value`, returns iterator to the first element of the sequence. 
>[!code-ref]+ `{cpp} std::search_n()` | $O(n)$
>```cpp
>ForwardIt std::search_n(ExecutionPolicy&& policy = std::execution::seq,
>                         ForwardIt first, ForwardIt last, 
>                         Size count, const T& value, 
>                         BinaryPred p = std::equal_to());
>```
```cpp
std::vector vec {1, 2, 2, 3, 2, 3, 3};
auto count {2};
auto val {3};
auto pos {std::search_n(std::cbegin(vec), std::cend(vec), count, val)};
```

* Takes two iterator ranges and looks for an occurrence of the second iterator range in first.
>[!code-ref]+ `{cpp}std::search()` | $O(N*S)$
> ```cpp
> ForwardIt1 std::search(ExecutionPolicy&& policy = std::execution::seq,
>                        ForwardIt1 first, ForwardIt1 last, 
>                        ForwardIt2 s_first, ForwardIt2 s_last, 
>                        BinaryPred p = std::equal_to());
> ```

* Takes two iterator ranges and looks for an *LAST* occurrence of the second iterator range in first.
>[!code-ref]+ `{cpp} std::find_end()` | $O(N*S)$
>```cpp
>ForwardIt1 std::find_end(ExecutionPolicy&& policy = std::execution::seq,
>                          ForwardIt1 first, ForwardIt1 last, 
>                          ForwardIt2 s_first, ForwardIt2 s_last, 
>                          BinaryPred p = std::equal_to());
>```

> Complexity according to cppreference $O(S*(N-S+1)), where S = s\_end - s\_begin$, but it's simplified up to $O(N*S)$
```cpp
int vec[] {1, 2, 2, 2, 3};
int sub[] {2, 2};

auto firstSubset {std::search(std::cbegin(vec), std::cend(vec), 
							 std::cbegin(sub), std::cend(sub))};
firstSubset != std::cend(vec)
    ? std::println("First occurrence at vec[{}]", 
                   std::distance(std::cbegin(vec), firstSubset))
    : std::println("No match for first occurence\n");

auto lastSubset {std::find_end(std::cbegin(vec), std::cend(vec), 
							  std::cbegin(sub), std::cend(sub))};
lastSubset != std::cend(vec)
    ? std::println("Last occurrence at vec[{}]", 
                   std::distance(std::cbegin(vec), lastSubset))
    : std::println("No match for last occurence");  
```

* Takes two iterator ranges and looks for differences between the two ranges. Returns a pair to the first elements that has a different value in each range. 
Parallel version require *Forward iterators* range.
>[!code-ref]+ `{cpp} std::mismatch()` | $O(n)$
>```cpp
>std::pair<InputIt1, InputIt2>
>std::mismatch(InputIt1 first1, InputIt1 last1, 
>               InputIt2 first2, InputIt2 last2, 
>               BinaryPred p = std::equal_to()); 
>               
>std::pair<ForwardIt1, ForwardIt2>
>std::mismatch(ExecutionPolicy&& policy, 
>               ForwardIt1 first1, ForwardIt1 last1, 
>               ForwardIt2 first2, ForwardIt2 last2, 
>               BinaryPred p = std::equal_to()); 
>```
```cpp ln:false
int vec1[] {1, 2, 2, 3, 2, 3, 3};
int vec2[] {1, 2, 2, 2, 2, 3, 3};

auto [diff1, diff2] {std::mismatch(std::cbegin(vec1), std::cend(vec1),
						          std::cbegin(vec2), std::cend(vec2))};

if (diff1 != std::cend(vec1) && diff2 != std::cend(vec2))
    std::println("vec1[{}] != vec2[{}] ({} != {})", 
                 std::distance(std::cbegin(vec1), diff1), 
                 std::distance (std::cbegin(vec2), diff2),
                 *diff1, *diff2);
```

* Return `true` if the _unary_ predicate is `true` for every element. 
Equal to `{cpp} std::find_if_not(first, last, p) == last`. Parallel version require *Forward iterators* range.
>[!code-ref]+ `{cpp}std::all_of()` | $O(n)$
>```cpp
>bool std::all_of(InputIt first, InputIt last, UnaryPred p);
>
>bool std::all_of(ExecutionPolicy&& policy, 
>                  ForwardIt first, ForwardIt last, 
>                  UnaryPred p);
>```

* Return `true` if the _unary_ predicate is `true` for at least one element. 
Equal to `{cpp} std::find_if(first, last, p) != last`. Parallel version require *Forward iterators* range.
>[!code-ref]+ `{cpp}std::any_of()` | $O(n)$
>```cpp
>bool std::any_of(InputIt first, InputIt last, UnaryPred p);
>
>bool std::any_of(ExecutionPolicy&& policy, 
>                  ForwardIt first, ForwardIt last, 
>                  UnaryPred p);
>```

* Return `true` if the _unary_ predicate is `false` for every element.
Equal to `{cpp} std::find_if(first, last, p) == last`. Parallel version require *Forward iterators* range.
>[!code-ref]+ `{cpp}std::none_of()` | $O(n)$
>```cpp
>bool std::none_of(InputIt first, InputIt last, UnaryPred p);
>
>bool std::none_of(ExecutionPolicy&& policy, 
>                   ForwardIt first, 
>                   ForwardIt last, UnaryPred p);
>```
```cpp
auto is_odd {[](auto n) { return n % 2 == 1; }};
std::vector vec {2, 3, 5};

if (std::all_of(std::cbegin(vec), std::cend(vec), is_odd))
	std::cout << "All elements of vec are odd\n";
if (std::any_of(std::cbegin(vec), std::cend(vec), is_odd))
	std::cout << "Some elements of vec are odd\n";
if (std::none_of(std::cbegin(vec), std::cend(vec), is_odd))
	std::cout << "No odd elements of vec\n";
```

* Return `true` if element `value` contains in *sorted* iterator range (using [Binary search](https://en.wikipedia.org/wiki/Binary_search))
>[!code-ref]+ `{cpp} std::binary_search()` | $O(log n)$
>```cpp
>bool std::binary_search(ForwardIt first, ForwardIt last,
>                         const T& value, Compare comp == std::less());
>```

* Checks is second iterator range is subrange of first iterator range. 
If ranges *sorted* - return `true` if all the elements in the second range are presented in the first range. Parallel version require _Forward iterators_ range.
>[!code-ref]+ `{cpp} std::includes()` | $O(n + m)$
>```cpp
>bool std::includes(InputIt1 first1, InputIt1 last1,
>                    InputIt2 first2, InputIt2 last2,
>                    Compare comp = std::less());
>
>bool std::includes(ExecutionPolicy&& policy,
>                    ForwardIt1 first1, ForwardIt1 last1,
>                    ForwardIt2 first2, ForwardIt2 last2, 
>                    Compare comp = std::less());
>```
```cpp
std::vector first {1, 2, 3, 4, 5};
std::vector second {5, 2, 1};

std::includes(std::cbegin(first), std::cend(first), 
              std::cbegin(second), std::cend(second))
            ? std::cout << "yes\n"
            : std::cout << "no\n";
// returned no

std::ranges::sort(first);
std::ranges::sort(second);

std::includes(std::cbegin(first), std::cend(first), 
              std::cbegin(second), std::cend(second))
            ? std::cout << "yes\n"
            : std::cout << "no\n";
// returned yes

std::vector first2 {3, 4, 5, 2, 1};
std::vector second2 {5, 2, 1};

std::includes(std::cbegin(first2), std::cend(first2), 
              std::cbegin(second2), std::cend(second2))
            ? std::cout << "yes\n"
            : std::cout << "no\n";
// returned yes
```
>[!note] 
> Algorithm have complexity $O(N_1 + N_2)$. Combining with complexity of `{cpp}std::sort()`, $O(N log N)$, `{cpp}std::sort()`+`{cpp}std::includes()` can provide complexity $O(N_1 log N_1 + N_2 log N_2)$, 
> which is better than complexity of `{cpp}std::all_of()`+`{cpp}std::find()` ($O(N_1 * N_2$), 
> but yet worser than using `{cpp}std::unorded_set::insert()` and check flag "was not inserted" ($O(N_1 + N_2)$) 

### Numeric Algorithms
Some of algorithm defined in `<numeric>` header. 

* Fill an iterator range with values increased on each new step by 1, starting from some `value` 
>[!code-ref]+ `{cpp} std::iota()` | $O(n)$
>```cpp
>void std::iota(ForwardIt first, ForwardIt last, T value);
>```
```cpp
std::vector<int> vec(10); // Constructor will create vector with 10 elements
std::iota(std::begin(vec), std::end(vec), -5);
for (auto& v : vec)
    std::print("{} ", v);
// -5 -4 -3 -2 -1 0 1 2 3 4
```

* Returns the sum of `init` value and all the elements in an iterator range, can be modified with Binary predicate `op`, execution will be *strictly from left to right*
>[!code-ref]+ `{cpp}std::accumulate()` | $O(n)$
>```cpp
>T std::accumulate(InputIt first, InputIt last = std::execution::seq, 
>                   T init, BinaryOp op = std::sum());
>```
```cpp
std::vector<int> vec(2);
std::iota(std::begin(vec), std::end(vec), 2);

auto res {std::accumulate(std::cbegin(vec), std::cend(vec), 1, std::multiplies())};
```

* Similarly to `{cpp} std::accumulate()`, but can be run in parallel, executing operation _in any order_. 
Parallel version require _Forward iterator_ range
>[!code-ref]+ `{cpp}std::reduce()` | $O(n)$
>```cpp
>T std::reduce(InputIt first, InputIt last, 
>               T init, BinaryOp op = std::sum());
>
>T std::reduce(ExecutionPolicy&& policy,
>               ForwardIt first, ForwardIt last, 
>               T init, BinaryOp op = std::sum());
>```

### Write-only Algorithms 
* Assigning given iterator range with `value`
>[!code-ref]+ `{cpp} std::fill() ` | $O(n)$
>```cpp
>void fill(ExecutionPolicy&& policy = std::execution::seq,
>           ForwardIt first, ForwardIt last, const T& value);
>```

* Assigns the given value to the first `count` elements in the range beginning at `first` with `value` and return iterator to next after last assigned element. 
*Given container should have enough capacity, if `count` greater than container size - UB*. Parallel version require *Forward iterators* range 
>[!code-ref]+ `{cpp} std:fill_n()` | $O(n)$
>```cpp
>OutputIt std::fill_n(OutputIt first, Size count, const T& value);
>
>ForwardIt std::fill_n(ExecutionPolicy&& policy = std::execution::seq,
>                       ForwardIt first, 
>                       Size count, const T& value);
>```

One "trick" which avoid overflow if `count` is greater than size - is use `{cpp}std::back_inserter()`, which will call `push_back()` for each element.
> But it's just example of use insertion iterator and not recommendation - poor performance (since that means that on each step we reallocate container) + create temporary object (since not `emplace_back()` is used) and not all container supports `push_back()`.

* Assign given iterator range with return value from executed `generator` callable object
>[!code-ref]+ `{cpp} std::generate()` | $O(n)$
>```cpp
>void std::generate(ExecutionPolicy&& policy = std::execution::seq, 
>                    ForwardIt first, ForwardIt last, 
>                    Generator g);
>```
```cpp
class {
    int n{};
public:
    int operator()() { return ++n * n; }
} SquareGen;

std::vector<int> vec(10);
std::generate(std::begin(vec), std::end(vec), SquareGen);
```
```cpp fold:"Or more generalized implementation which deduce type of vector"
template<class T>
class SquareGen {
    T n{};
public:
    template<class R>
    SquareGen(const R&) {}
    
    auto operator()() { return ++n * n; }
};

template<class R>
SquareGen(const R&) -> SquareGen<typename R::value_type>;

std::vector<int> vec(10);
std::generate(std::begin(vec), std::end(vec), SquareGen(vec));
```

* Generate value and assign it to container elements in range `[begin, begin + count]` and return iterator on container element after last assigned element. 
Similar to `{cpp} std::fill_n()`, with same UB if `count` is greater than container size. Parallel version require *Forward iterator* range. 
>[!code-ref]+ `{cpp} std::generate_n()` | $O(n)$
>```cpp
>OutputIt std::generate_n(OutputIt first, Size count, Generator);
>
>ForwardIt std::generate_n(ExecutionPolicy&& policy,
>                           ForwardIt first, Size count, 
>                           Generator g);
>```

### For_each
Takes each element from iterator range by reference and pass to provided unary function object. If callable function return anything - it will be ignored. Algorithm mutable and elements taken by reference, meaning that algorithm can modify elements as well.
Parallel version require *Forward iterator* range. 
>[!code-ref]+ `{cpp} std::for_each()` | $O(n)$
>```cpp
>UnaryFunc std::for_each(InputIt first, InputIt last, UnaryFunc f);
>
>void std::for_each(ExecutionPolicy&& policy = std::execution::seq,
>                    ForwardIt first, ForwardIt last, 
>                    UnaryFunc f);
>```
```cpp
std::vector vec{3, -4, 2, -8, 15, 267};
auto print {[](const auto& n) { std::cout << n << ' '; }};

std::for_each(std::cbegin(vec), std::cend(vec), print);
std::cout <<'\n';

std::for_each(std::begin(vec), std::end(vec), [](int &n) { n++; });

std::for_each(std::cbegin(vec), std::cend(vec), print);
```


### Copying algorithm 
* Basic deep copy from one iterator range to another. 
The target container must have enough capacity. Returns iterator to next after last copied element position from second container. Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::copy()` | $O(n)$
>```cpp
>OutputIt std::copy(InputIt first, InputIt last, OutputIt d_first);
>
>ForwardIt2 std::copy(ExecutionPolicy&& policy,
>                      ForwardIt1 first, ForwardIt1 last,
>                      ForwardIt2 d_first);
>``` 

* Copy first n elements of a range. 
Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::copy_n()` | $O(n)$
>```cpp
>OutputIt std::copy_n(InputIt first, Size count, OutputIt result);
>
>ForwardIt2 std::copy_n(ExecutionPolicy&& policy,
>                        ForwardIt1 first, Size count, 
>                        ForwardIt2 result);
>```

* Copy only the elements for which a unary predicate is `true`. 
Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::copy_if()` | $O(n)$
>```cpp
>OutputIt std::copy_if(InputIt first, InputIt last, 
>                       OutputIt d_first, UnaryPred pred);
>
>ForwardIt2 std::copy_if(ExecutionPolicy&& policy, 
>				         ForwardIt1 first, ForwardIt1 last, 
>                         ForwardIt2 d_first, 
>                         UnaryPred pred);
>```
```cpp
std::vector vec{3, -4, 2, -8, 15, 267};
std::vector<int> vec2(vec.size());
    
// Abstract example - take first 2 element, than only possitive element and fill rest element with content from original container up to end
auto lastIt {std::copy_n(std::cbegin(vec), 2, std::begin(vec2))};
lastIt = std::copy_if(std::cbegin(vec) + 2, std::cend(vec), 
                      lastIt, [](int a) { return a > 0;});
std::copy(std::cbegin(vec) + std::distance(std::begin(vec2), lastIt), 
          std::cend(vec), lastIt);
```


### Write Algorithm 
* Change all elements with a given `old_value` to another `new_value`.
>[!code-ref]+ `{cpp} std::replace()` | $O(n)$
>```cpp
>void std::replace(ExecutionPolicy&& policy = std::execution::seq,
>                   ForwardIt first, ForwardIt last,
>                   const T& old_value, const T& new_value );
>```

* Change all elements for which an unary predicate returns `true` with value `new_value` 
>[!code-ref]+ `{cpp} std::replace_if()` | $O(n)$
>```cpp
>void std::replace_if(ExecutionPolicy&& policy = std::execution::seq, 
>                      ForwardIt first, ForwardIt last, 
>                      UnaryPred p, const T& new_value);
>```

* Copy data to destination container, replacing `old_value` with `new_value`.
Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::replace_copy()` | $O(n)$
>```cpp
>OutputIt std::replace_copy(InputIt first, InputIt last, 
>                            OutputIt d_first,
>                            const T& old_value, const T& new_value);
>
>ForwardIt2 std::replace_copy(ExecutionPolicy&& policy,
>                              ForwardIt1 first, ForwardIt1 last, 
>                              ForwardIt2 d_first,
>                              const T& old_value, const T& new_value );
>```

* Copy data to destination container, replacing elements for which unary predicate return `true` wit `new_value`.
Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::repalce_copy_if()` | $O(n)$
>```cpp
>OutputIt std::replace_copy_if(InputIt first, InputIt last, 
>                               OutputIt d_first, UnaryPred p, 
>                               const T& new_value);
>
>ForwardIt2 std::replace_copy_if(ExecutionPolicy&& policy, 
>                                 ForwardIt1 first, ForwardIt1 last,
>                                 ForwardIt2 d_first, 
>                                 UnaryPred p, const T& new_value);
>```

### Remove algorithm 
* Move to the back of the iterator range each element equal to given value and return iterator to the first "removed" element. 
Element not actually removed, `{cpp}size()` of container will be same, idea is that returned iterator now new `{cpp}end()`. Values of removed elements not defined (since from C++11 might be applied move semantics). Algorithm uses `operator==`.
>[!code-ref]+ `{cpp} std::remove()` | $O(n)$
>```cpp
>ForwardIt remove(ExecutionPolicy&& policy = std::execution::seq, 
>                  ForwardIt first, ForwardIt last, 
>                  const T& value);
>```

* Remove elements for which unary predicate return `true`. Return iterator to "new end".
>[!code-ref]+ `{cpp} std::remove_if()` | $O(n)$
>```cpp
>ForwardIt std::remove_if(ExecutionPolicy&& policy = std::execution::seq, 
>                          ForwardIt first, ForwardIt last, 
>                          UnaryPred p);
>```

`{cpp}std::remove()`/`{cpp}std::remove_if()` doesn't change container size, doesn't destroy elements. To "physically" remove elements - can be used container member functions 
```cpp fold:"Test example"
struct Test {
   Test(int val) : m_val{val} {};
    ~Test() { std::println("Test destroyed"); }
   int m_val{};
};
bool operator==(const Test& lhs, const Test& rhs) { return lhs.m_val == rhs.m_val; } 

int main() {
    std::vector<Test> vec;
    vec.reserve(6);
    for (int val : {1, 3, 3, 4, 5, 6})
        vec.emplace_back(val);
    
    Test toRemove{3};
    auto newEnd = std::remove(std::begin(vec), std::end(vec), toRemove);
    for (auto& val : vec)
        std::print ("{} ", val.m_val);
    std::cout << "\n";

    for (auto it {newEnd}; it != std::end(vec); ++it)
        std::print ("{} ", (*it).m_val);
    std::cout << "\n";

    vec.erase(newEnd, std::end(vec));
    for (auto& val : vec)
        std::print ("{} ", val.m_val);
    std::cout << "\n";

    std::println("\nMain exiting\n");
}
/* Output
1 4 5 6 5 6 
5 6 
Test destroyed
Test destroyed
1 4 5 6 

Main exiting

Test destroyed
Test destroyed
Test destroyed
Test destroyed
Test destroyed
*/
```

* Copy elements from first iterator range to second, but "removing" elements which equal to given. Return iterator to the element past the last element copied.
Technically opposite to `{cpp} std::copy()`. Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::remove_copy()` | $O(n)$
>```cpp
>OutputIt std::remove_copy(InputIt first, InputIt last,
>                           OutputIt d_first, const T& value);
>
>ForwardIt2 std::remove_copy(ExecutionPolicy&& policy,
>                             ForwardIt1 first, ForwardIt1 last,
>                             ForwardIt2 d_first, 
>                             const T& value );
>```

* Copy elements from first iterator range to second except elements, for which unary predicator returns `true`. 
Return iterator to the element past the last element copied. Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::remove_copy_if()` | $O(n)$
>```cpp
>OutputIt std::remove_copy_if(InputIt first, InputIt last,
>                              OutputIt d_first, UnaryPred p);
>
>ForwardIt2 std::remove_copy_if(ExecutionPolicy&& policy,
>                                ForwardIt1 first, ForwardIt1 last,
>                                ForwardIt2 d_first, 
>                                UnaryPred p );
>```

* Remove from *sorted* iterator range duplicate adjacent elements. 
>[!code-ref]+ `{cpp} std::unique()` | $O(n)$
>```cpp
>ForwardIt unique(ExecutionPolicy&& policy = std::execution::seq,
>                  ForwardIt first, ForwardIt last, 
>                  BinaryPred p = std::equal_to());
>```

* Copy from *sorted* iterator range unique elements to second range.
Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::unique_copy()` | $O(n)$
>```cpp
>OutputIt std::unique_copy(InputIt first, InputIt last,
>                           OutputIt d_first, 
>                           BinaryPred p = std::equal_to());
>
>ForwardIt std::unique_copy(ExecutionPolicy&& policy,
>                            ForwardIt first, ForwardIt last, 
>                            ForwardIt2 d_first,
>                            BinaryPred p = std::equal_to());
>```

### Transform Algorithm 
* Call given function on every element in the range and copy result into a destination. 
Have version with *unary* function object and *binary* function object (which takes 2 container and 3rd for storing result). As a destination container can be used original container. Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::transform()` | $O(n)$
>```cpp
>OutputIt std::transform(InputIt first1, InputIt last1, 
>                         OutputIt d_first, UnaryOp unary_op);
>
>ForwardIt2 std::transform(ExecutionPolicy&& policy,
>                           ForwardIt1 first1, ForwardIt1 last1,
>                           ForwardIt2 d_first, 
>                           UnaryOp unary_op);
>
>OutputIt std::transform(InputIt1 first1, InputIt1 last1, 
>                         InputIt2 first2,
>                         OutputIt d_first, BinaryOp binary_op);
>
>ForwardIt3 std::transform(ExecutionPolicy&& policy,
>                           ForwardIt1 first1, ForwardIt1 last1,
>                           ForwardIt2 first2,
>                           ForwardIt3 d_first, 
>                           BinaryOp binary_op );
>```


### Merging Algorithms
Destination container should have enough capacity. Overload with `ExecutionPolicy` require for output _forward iterator_ (non-parallel overload can write to file for example, while parallel - in most container only).

* Combines two *sorted* iterator ranges into a destination. 
Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::merge()` | $O(n + m)$
>```cpp
>OutputIt std::merge(InputIt1 first1, InputIt1 last1,
>                     InputIt2 first2, InputIt2 last2,
>                     OutputIt d_first, Compare comp);
>
> ForwardIt3 std::merge(ExecutionPolicy&& policy, 
>                       InputIt1 first1, InputIt1 last1,
>                       InputIt2 first2, InputIt2 last2,
>                       ForwardIt3 d_first, Compare comp = std::less());
>```
```cpp
std::vector vec1{1, 2, 5, 6, 8};
std::vector vec2{1, 5, 6};
std::vector<int> vecRes(vec1.size() + vec2.size());

std::merge(std::cbegin(vec1), std::cend(vec1), 
           std::cbegin(vec2), std::cend(vec2), 
           std::begin(vecRes));

for (auto& val : vecRes) 
	std::print("{} ", val);
// 1 1 2 5 5 6 6 8
```

* Combines two *sorted* iterator ranges into a destination only the elements which are present in both ranges (intersected elements).
Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::set_intersection()` | $O(n + m)$
>```cpp
>OutputIt std::set_intersection(InputIt1 first1, InputIt1 last1,
>                                InputIt2 first2, InputIt2 last2,
>                                OutputIt d_first, 
>                                Compare comp = std::less());
>
>ForwardIt3 std::set_intersection(ExecutionPolicy&& policy,
>                                  ForwardIt1 first1, ForwardIt1 last1,
>                                  ForwardIt2 first2, ForwardIt2 last2,
>                                  ForwardIt3 d_first, 
>                                  Compare comp = std::less());
>```
```cpp
std::vector vec1{1, 2, 5, 6, 8};
std::vector vec2{1, 5, 6};
std::vector<int> vecRes{};

std::set_intersection(std::cbegin(vec1), std::cend(vec1), 
                      std::cbegin(vec2), std::cend(vec2), 
                      std::back_inserter(vecRes));

for (auto& val : vecRes) 
	std::print("{} ", val);
// 1 5 6
```

* Combines two *sorted* iterator ranges into a destination only elements which are in either range. 
If both container have same value - only one value will be presented (which makes it different from `{cpp}std::merge`, but it doesn't remove duplicates if its in one container). Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::set_union()` | $O(n + m)$
>```cpp
>OutputIt std::set_union(InputIt1 first1, InputIt1 last1,
>                         InputIt2 first2, InputIt2 last2,
>                         OutputIt d_first, 
>                         Compare comp = std::less());
>
>ForwardIt3 std::set_union(ExecutionPolicy&& policy,
>                           ForwardIt1 first1, ForwardIt1 last1,
>                           ForwardIt2 first2, ForwardIt2 last2,
>                           ForwardIt3 d_first, 
>                           Compare comp = std::less());
>```
```cpp
std::vector vec1{1, 2, 2, 5, 8};
std::vector vec2{1, 2, 6};
std::vector<int> vecRes{};

std::set_union(std::cbegin(vec1), std::cend(vec1), 
               std::cbegin(vec2), std::cend(vec2), 
               std::ostream_iterator<int>(std::cout, " "));
// 1 2 2 5 6 8
```

### Reordering Algorithms 
* Takes the elements in an iterator range and reverses their order. 
>[!code-ref]+ `{cpp} std::reverse()` | $O(n)$
>```cpp
>void std::reverse(ExecutionPolicy&& policy = std::execution::seq, 
>                   BidirIt first, BidirIt last);
>```

* Copies the elements of iterator range into destination range in reversed order.
Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::reverse_copy()` | $O(n)$
>```cpp
>OutputIt std::reverse_copy(BidirIt first, BidirIt last,
>                            OutputIt d_first);
>
>ForwardIt std::reverse_copy(ExecutionPolicy&& policy,
>                             BidirIt first, BidirIt last,
>                             ForwardIt d_first);
>```
 
* Performs a "rotation" inside iterator range about a given element.
All the elements before the pivot are moved to the back of the range, the pivot and all the elements behind it are moved to the front of the iterator range.
I.e. for pivot = 3: `[1 2 3 4 5]` -> `[3 4 5 1 2]` (so it's link ring container.)
>[!code-ref]+ `{cpp} std::rotate()` | $O(n)$
>```cpp
>ForwardIt rotate(ExecutionPolicy&& policy = std::execution::seq,
>                  ForwardIt first, ForwardIt middle, ForwardIt last);
>```

* Perform rotation of iterator range and write result into destination iterator range. 
Return iterator past last copied element. Parallel version require *Forward iterator* range.
>[!code-ref] `{cpp} std::rotate_copy()` | $O(n)$
>```cpp
>OutputIt std::rotate_copy(ForwardIt first, ForwardIt middle,
>                           ForwardIt last, OutputIt d_first);
>
>ForwardIt2 std::rotate_copy(ExecutionPolicy&& policy,
>                             ForwardIt1 first, ForwardIt1 middle, ForwardIt1 last, 
>                             ForwardIt2 d_first);
>```

Rotation algorithms rotating to always left. For rotation to right `{cpp}std::rotate` can be combined with `{cpp}std:reverse()` can be used *reverse iterator*. Also, `{cpp}std::advance` can make reusable pivot (and improve readability).  
```cpp
std::vector<int> vec1{1, 2, 2, 5, 6, 8};
std::vector<int> vec2(vec1.size());

auto pivot{std::begin(vec1)};
std::advance(pivot, 3);
std::rotate_copy(std::begin(vec1), pivot, std::end(vec1), std::begin(vec2));
for (auto& val : vec2) 
    std::print("{} ", val);
// 5 6 8 1 2 2
std::cout<<'\n';

auto rpivot{ std::rbegin(vec2)};
std::advance(rpivot, 3);
std::rotate(std::rbegin(vec2), rpivot, std::rend(vec2));
for (auto& val : vec2) 
    std::print("{} ", val);
// 1 2 2 5 6 8
```


### Partitioning Algorithms
Partitioning the elements meaning move container elements to the front (if element have some property) or to the back (if elements don't have that property). Boundary between the two groups called _partition point_.

* Perform partition over iterator range based on _unary_ predicate. Order not guarantied. 
>[!code-ref]+ `{cpp} std::partition()` | $O(n)$
>```cpp
>ForwardIt std::partition(ExecutionPolicy&& policy = std::execution::seq,
>                          ForwardIt first, ForwardIt last, UnaryPred p);
>```

* Perform partition over iterator range based on _unary_ predicate, saving elements relative order. 
It might be slower. And works only with containers which support bidirectional iterators (which means with `std::unorded_*`, `std:forward_list` and `iostream` algorithm will not work)
>[!code-ref]+ `{cpp} std::stable_partition()` | $O(n*logn)$ 
>```cpp
>BidirIt stable_partition(ExecutionPolicy&& policy = std::execution::seq,
>                          BidirIt first, BidirIt last, UnaryPred p);
>```

* Return `true` if iterator range partitioned by given predicate function
Parallel version require *Forward iterator* range.
>[!code-ref]+ `{cpp} std::is_partitined()` | $O(n)$ 
>```cpp
>bool std::is_partitioned(InputIt first, InputIt last, UnaryPred p);
>
>bool std::is_partitioned(ExecutionPolicy&& policy,
>                          ForwardIt first, ForwardIt last, UnaryPred p);
>```

* Return iterator to partition point for partitioned by given predicate function iterator range. 
>[!code-ref]+ `{cpp} std::partion_point()` | $O(log n)$ 
>```cpp
>ForwardIt std::partition_point(ForwardIt first, ForwardIt last, 
>                                UnaryPred p);
>```


## Sorting algorithm
* Order the elements in ascending order.
Usually implemented as a _quicksort_. With newer versions implementation switched to _introsort_ The order of equal elements is not guaranteed to be preserved. Works only with *Random Access Iterators* 
>[!code-ref] `{cpp} std::sort()` | $O(n * log n)$ 
>```cpp
>void std::sort(ExecutionPolicy&& policy = std::execution::seq,
>                RandomIt first, RandomIt last, 
>                Compare comp = std::less());
>```

* Return `true` if iterator range is sorted 
>[!code-ref] `{cpp} std::is_sorted()` | $O(n)$ 
>```cpp
>bool std::is_sorted(ExecutionPolicy&& policy = std::execution::seq, 
>                     ForwardIt first, ForwardIt last, 
>                     Compare comp = std::less());
>```

* Return an iterator to the first element which is not in order 
>[!code-ref] `{cpp} std::is_sorted_until()` | $O(n)$ 
>```cpp
>ForwardIt std::is_sorted_until(ExecutionPolicy&& policy = std::execution::seq, 
>                                ForwardIt first, ForwardIt last, 
>                                Compare comp = std::less());
>```

* Sort only first `n` element of iterator range.
Works only with *Random Access Iterators* 
>[!code-ref] `{cpp} std::paratial_sort()` | $O(n * log m)$ 
>```cpp
>void std::partial_sort(ExecutionPolicy&& policy = std::execution::seq, 
>                        RandomIt first, RandomIt middle, RandomIt last,
>                        Compare comp = std::less());
>```

* Sort first `n` in iterator range, storing result in destination container. 
As destination can be used only *Random Access Iterators* range
>[!code-ref] `{cpp} std::paratial_sort_copy()` | $O(n * log m)$ 
>```cpp
>RandomIt std::partial_sort_copy(ExecutionPolicy&& policy = std::execution::seq,
>                                 ForwardIt first, ForwardIt last,
>                                 RandomIt d_first, RandomIt d_last,
>                                 Compare comp = std::less());
>```

* Rearranges the elements so that the `nth` iterator points to the element that would be in that position if the range was sorted. It then performs a partition with this element as the partition point - all the elements before it will have a lower or equal value; all the elements after it will have greater value. 
Works only with *Random Access Iterators* 
>[!code-ref] `{cpp} std::nth_element()` | $O(n)$ 
>```cpp
>void std::nth_element(ExecutionPolicy&& policy = std::execution::seq,
>                       RandomIt first, RandomIt nth, RandomIt last,
>                       Compare comp = std::less());
>```

## Permutation algorithms
Permutations - set of every possible arrangements of some elements in order.

* Reorder the elements of iterator range to give the next permutation according to ascending order. Return `true` of there is a next permutation.
To get all possible permutation required to sort iterator range first.
>[!code-ref]+ `{cpp}std::next_permutation()`
>```cpp
>```

* Reorder the elements of iterator range to give the previous permutation according to descending order. Return `true` of there is a previous permutation
To get all possible permutation in reverse order required to sort iterator range in descending order.
>[!code-ref]+ `{cpp}std::prev_permutation()`
>```cpp
>```

* Takes two iterator ranges and return `true` if both ranges contain the same elements and can be permutation relatively each other.
>[!code-ref]+ `{cpp}std::is_permutation()`
>```cpp
>```


## Min and Max Algorithms 
STL contain Min and Max algorithms which can support two elements comparison, iterator range and also `std::initializer_list`.

* Returns smallest element between provided two provided items or `std::initializer_list`
>[!code-ref]+ `std::min()`
>```cpp
>```

* Returns smallest element among provided iterator range
>[!code-ref]+ `std::min_element()`
>```cpp
>```

* Returns largest element between provided two provided items or `std::initializer_list`
>[!code-ref]+ `std::max()`
>```cpp
>```

* Returns largest element among provided iterator range
>[!code-ref]+ `std::max_element()`
>```cpp
>```

* Returns largest element between provided two provided items or `std::initializer_list`
>[!code-ref]+ `std::minmax()`
>```cpp
>```

* Returns `std::pair` with smallest and largest elements among provided iterator range
>[!code-ref]+ `std::minmax_element()`
>```cpp
>```


## Other Numeric Algorithms
C++17 provides a number of [special math function](https://cppreference.com/w/cpp/numeric/special_math.html) (Hermite polynomials, Riemann zeta function etc.), they are *not observed in this course*

Some other numeric algorithms are presented in [`<numeric>`](https://cppreference.com/w/cpp/numeric.html#Numeric_algorithms) header. 

* Takes an iterator range and writes into another container "running total" of the elements - performs *binary* operation between _current input_ element (`input[n]`) and _previous output_ element (`output[n-1]`).  
For example, for container `{a, b, c, ..}` destination container will have `{a, a+b, a+b+c, ..}`
>[!code-ref]- `{cpp} std::partial_sum()`
>```cpp
>OutputIt partial_sum(InputIt first, InputIt last,
>                      OutputIt d_first, 
>                      BinaryOp op = std::plus());
>```

* Writes the difference between successive elements into another iterator range.
`{a, b, c}` -> `{a, b-a, c-b, ..}`
It's also inverse  of `std::partial_sum`. Parallel version require *Forward Iterator*.
>[!code-ref]- `{cpp}std::adjacent_difference()`
>```cpp
>OutputIt std::adjacent_difference(InputIt first, InputIt last,
>                                   OutputIt d_first, 
>                                   BinaryOp op = std::minus());
>
>ForwardIt2 std::adjacent_difference(ExecutionPolicy&& policy, 
>                                     ForwardIt1 first, ForwardIt1 last, 
>                                     ForwardIt2 d_first, 
>                                     BinaryOp op = std::minus());
>```

* Multiplies the corresponding elements of two containers and calculate their sum
Synonym to scalar product. In general, it's combination of two algorithms: `std::accumulate` and `std::transform`. As result, function overloading require 2 binary operations for overloading - first is binary operation for `std::accumulate` and second is binary operation for `std::transform`.  
>[!code-ref]+ `{cpp} std::inner_product()`
>```cpp
>T std::inner_product(InputIt1 first1, InputIt1 last1, 
>                      InputIt2 first2, 
>                      T init, 
>                      BinaryOp1 op1 = std::plus(), BinaryOp2 op2 = std::multiplies());
>```

* Similarly to `std::inner_product`, but supports parallel execution. 
Algorithm also support variation with unary operation and single container. Parallel version requires *forward iterator*
>[!code-ref]+ `{cpp}std::transform_reduce()`
>```cpp
>(1)T std::transform_reduce(InputIt1 first1, InputIt1 last1, 
>                            InputIt2 first2, T init,
>                            BinaryOp1 reduce = std::plus(), 
>                            BinaryOp2 transform = std::multiplies());
>
>(2)T std::transform_reduce(InputIt first, InputIt last, T init,
>                            BinaryOp reduce = std::plus(), 
>                            UnaryOp transform = std::identity());
>
>T std::transform_reduce(ExecutionPolicy&& policy,
>                         ForwardIt1 first1, ForwardIt1 last1,
>                         ForwardIt2 first2, T init,
>                         BinaryOp1 reduce = std::plus(), 
>                         BinaryOp2 transform = std::multiplies());
>                        
>T std::transform_reduce(ExecutionPolicy&& policy,
>                         ForwardIt first, ForwardIt last, T init,
>                         BinaryOp reduce = std::plus(), 
>                         UnaryOp transform = std::identity());
>
>```

