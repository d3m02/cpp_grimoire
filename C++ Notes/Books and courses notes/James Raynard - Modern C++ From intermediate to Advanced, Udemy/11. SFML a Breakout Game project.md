SFML - [The  Simple and Fast Multimedia Library](https://www.sfml-dev.org/) - an easy to use and well documented library written on modern C++ which provides an interface to the multimedia components of computer. 
It's working with different operating systems. Library contain modules for different purposes:
+ _System module_ - mostly not relevent for modern C++ since most of provided features (like time handling, threads etc) part of modern C++, so module for more working with older versions/C
+ _Window module_ - managing windows, interactive with event, keyboard etc.
+ _Graphics module_ - drawing, working with sprites and textures, texts and fonts, shapes etc.
+ _Audio module_ - playing sounds and music, recording audio etc
+ _Network module_ - communication using sockets, packets handling, HTTP/FTP etc

> [!Attention] Course designed around SFML 2.5, which is now outdated

## CMake installing 
> It's my own note, in course provided instruction for Visual Code. 

Web site provide [CMake instruction](https://www.sfml-dev.org/tutorials/3.0/getting-started/cmake/), which probably can be simplified to including into CMake project
```cmake
cmake_minimum_required(VERSION 3.28)

include(FetchContent)
FetchContent_Declare(SFML
    GIT_REPOSITORY https://github.com/SFML/SFML.git
    GIT_TAG 3.0.2
    GIT_SHALLOW ON
    EXCLUDE_FROM_ALL
    SYSTEM)
FetchContent_MakeAvailable(SFML)

target_link_libraries({project} PRIVATE SFML::Graphics)
```
 
 Alternatively, create a submodule in project 
 ```bash
 mkdir external
 git submodule add https://github.com/SFML/SFML.git external/SFML
 ```
 and in CMake project file 
 ```cmake
# For linking library probably examples and tests are redundant
set(SFML_BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
set(SFML_BUILD_TEST_SUITE OFF CACHE BOOL "" FORCE)

add_subdirectory(${EXTERN_LIBS_PATH}/SFML "${CMAKE_BINARY_DIR}/SFML")
include_directories(${EXTERN_LIBS_PATH}/SFML/include)

target_link_libraries(
	untitled
        PRIVATE
    SFML::Graphics
    SFML::Window
)
 ```

## Basic windows 
SFML defines in `<SFML/Graphics.hpp>` classes which we require for window. These are in the `sf` namespace, 
+ `sf::Windows` - base class which represent a windows on the screen which does nothing really.
+ `sf::RenderWindows` - represents a windows which can be used for 2D drawing. 
+ `sf::Event` - union which contains a user interaction event (click on windows, pressing key while the windows has focus etc).
	> In v3.0 it's not union, it's `std::variant`

`RenderWindow` have 3 important member functions: `{cpp} clear(Color color)` for clearing the windows, `{cpp} draw()` - draw in the memory buffer which is maintained by the window (it will not change what is user see currently on the screen) and `{cpp} display()` which makes the contents of the memory buffer appear on the display. Those 3 functions usually run in loop, `clear -> draw -> display`. 

Constructor of `RenderWindow` takes as argument 2D vector with the windows dimensions (in this case it's worth to store them as `static constexpr int`) and optional title name of window. 
> [!note] 
> Constructor as first argument takes class `VideoMode` which in v2.5 have constructor `{cpp} VideoMode(unsigned int modeWidth, unsigned int modeHeight, unsigned int modeBitsPerPixel = 32);`. 
> However in v3.0 constructor is `{cpp}explicit VideoMode(Vector2u modeSize, unsigned int modeBitsPerPixel = 32);`, which mean that to for constructor `RenderWindow` - first argument will be `{cpp} sf::VideoMode({constants::window_width, constants::window_height})`    

Usually it's good idea to limit the frame rate with `{cpp}setFramerateLimit(60)` - how often the windows will update, higher FPS mean higher lowed on CPU, 60 FPS is usually is enough.  

After than we create game loop while windows is open, `{cpp}while(gameWindows.isOpen())`. 
First step we clear current windows and fill with black color, `{cpp} gameWindows.clear(sf::Color::Black)`; 

Then we check for user interaction events. By calling `{cpp}pollEvent(event)` the windows will stop and wait for some user event. Then it will check for _all events_.  We check type of event (since event is tagged ~~union~~ `std::variant`) and perform required actions. `sf::Event::Closed` means the user has done something which will close the windows, like clicking 'X' or pressing 'Alt-F4'. `close()`  window's member function will terminate the program. For keyboard press can be used static method `sf::Keyboard::isKeyPressed`, which take a key to test. The following example will be handler for application closing on ESC key or any system-provided close event.

```cpp fold:"Deprecated SFML V2.5 example"
sf::Event event;
while (gameWindows.pollEvent(event)) {
	if (event.type == sf::Event::Closed)
		gameWindows.close();	
}
if (sf::Keyboard:isKeyPressed(sf::Keyboard::Key::Escape))
	gameWindows.close();
```
```cpp title:"SFML v3.0 example"
while (const auto event = gameWindow.pollEvent()) {
	if (event->is<sf::Event::Closed>()) {
	    gameWindow.close();
    }
    // sf::Keyboard::isKeyPressed still available, but probably handling events inside one loop is more convenient 
	else if (const auto& keyPressed = event->getIf<sf::Event::KeyPressed>())
    {
	    if (keyPressed->scancode == sf::Keyboard::Scancode::Escape) {
	        gameWindow.close();
        }
    }
}
```

After that will be code for calculating and update graphics (placeholder  for `draw()`)
And in the end, with calling `display()` we update display for the next frame.

```cpp title:"Lesson example"
Game::Game() : m_gameWindow {sf::VideoMode({constants::window_width, constants::window_height}),
                             "Breakout game"} {
    m_gameWindow.setFramerateLimit(60);
}

void GameLoop::loop() {
    while (gameWindow.isOpen()) {
        clearWindow();
		// update objects and draw objects
        gameWindow.display();
    }
}

void Game::clearWindow() {
    m_gameWindow.clear(sf::Color::Black);

    while (const auto event = m_gameWindow.pollEvent()) {
        if (event->is<sf::Event::Closed>()) {
            m_gameWindow.close();
        }
        else if (const auto* keyPressed = event->getIf<sf::Event::KeyPressed>())
        {
            if (keyPressed->scancode == sf::Keyboard::Scancode::Escape)
                m_gameWindow.close();
        }
    }
}
```

## Random walk
Firstly, we need to start off with a couple more concepts from SFML. 
+ `sf::Vector2` - represents a 2D vector with members `x` and `y` can be accessed directly. It's a template class with support of common arithmetic operations. 
+ `sf::Vector2f` - alias for `sf::Vector2<float>` instantiation. SFML uses `float` internally, so this vector will be used quite often. 
+ `sf::Texture` - represents an image which will be loaded into the graphics card and then can be drawn on a render target, such as render window. This drawn will be done by the graphics card.
+ `sf::Shape` - an abstract base class which represents a pre-defined texture. It has a _texture rectangle_ associated with it. All transformations are relative to the "origin" of the shape, be default this is the top left-hand corner of the texture rectangle. 
	+ `sf::CircleShape` - a subclass of `sf::Shape` representing a circle 
	+ `sf::ConvexShape` - a subclass of `sf::Shape` representing a convex polygon
	+ `sf::RactangleShape` -  a subclass of `sf::Shape` representing a rectangle 

In this example we create class which represent some 'creature'. In constructor we provide position where spawn it. Create have two variable `m_vx` and `m_vy` which control it's movement, 
        `-m_vy`
`-m_vx`                   `+m_vx`
         `m_vy`
Random walk implemented in `update` function, which uses Bernoulli distribution to get with 50/50 change `true` or `false`, which will flip sign of move variable and on each frame we move object by set values. Since random generator and distribution declared as `static` - they must be initialized outside class. And last member function is `{cpp}draw()` which will draw a creature on a provided windows. 
```cpp title:"Exaple from lesson"
class Creature {
public:
    /// @brief Create a creature in the requested position.
    Creature(float x, float y) {
        m_circle.setRadius(10.0f);
        m_circle.setPosition({x, y});
        m_circle.setFillColor(sf::Color::Red);
    }

    /// @brief Draw a creature on a provided window
    void draw(sf::RenderWindow& window) const {
        window.draw(m_circle);
    }

    /// @brief Calculate the creature's new position
    void update() {
        m_vx = bd(mt) ? m_vx : -m_vx;
        m_vy = bd(mt) ? m_vy : -m_vy;
        m_circle.move({m_vx, m_vy});
    }
private:
    // Random numer with 50/50 chance of true or false
    static std::mt19937 mt;
    static std::bernoulli_distribution bd;

    float m_vx{4.0f};                         /// @brief Control movements, positive - move right, negative - move left
    float m_vy{4.0f};                         /// @brief Control movements, positive - move down, negative - move up
    sf::Vector2f m_velocity{m_vx, m_vy};      /// @brief Creature velocity

    sf::CircleShape m_circle;                 /// @brief Used graphical object
};

// Initialized static variables
std::mt19937 Creature::mt;
std::bernoulli_distribution Creature::bd;

void GameLoop::run() {
	// Create window
	
	// Create a creature in the middle of a window
    Creature creature {constants::window_width / 2.0f, constants::window_height / 2.0f};
    while (gameWindow.isOpen()) {
		
		// after chacking events
		creature.update();
        creature.draw(gameWindow);
        
	    gameWindow.display();
    }
```

## Sprite 
`sf::Sprite`  represents a texture associated with a rectangle, similar to `sf::Shape`, but we provide our own image. They loaded into the graphics card and alternative when pre-defined by library options not enough. It's represents a group of pixels as a single graphical entity. 

To create a sprite, first we need a texture, `sf::Texture`. In that object we can use `{cpp} loadFromFile` to load a texture into a graphics card. Loading can fail if the image is not valid or image file in not in the expected directory, so it's worth to check result was a image loaded. Once we have texture, we can create the `sf::Sprite` object and set texture, `{cpp}setTexture(texture)` to associate this texture with sprite. 

In this game we require several sprites, to organize them we create an entity class to represent them - this will be an abstract base class and concrete sprite class will inherit from entity. 
Base class will contain `sf::Sprite` and pure virtual interfaces.
> [!note] 
> In SFML v3.0 removed default constructors for `sf::Sprite` and such base class not possible to compiler, since only left explicit constructor which takes texture, so we also need to add a texture to base class. If pass in sprite in-class member initialization default-initialized texture - sprite will have 0x0 rectangle, so after loading an image - we need to reset rectangle.
>
> Also, not agree with design - `draw()` function will be exactly same for all sub classes, but we can keep it as `virtual` in case if some different implementation will be required. Since each texture needs to be loaded from file in constructor, it's worth to add in base class non-virtual function  which take filename of resource, loads it into texture and recalculate rectangle. I using CMake for project and learn one trick to easily handle resource files - define a macro in CMakeLists.txt which will be expanded to absolute path to resource folder 
> ```cmake
> add_compile_definitions (RES_FOLDER="${CMAKE_CURRENT_SOURCE_DIR}/res/")
> ```

```cpp title:Entity.h
#include <string_view>
#include "SFML/Graphics/RenderWindow.hpp"
#include "SFML/Graphics/Sprite.hpp"  
#include "SFML/Graphics/Texture.hpp"

/// @brief Abstract class to represent graphical entities
class Entity {
public:
    virtual ~Entity() = default;

    virtual void update() = 0;
    
    virtual void draw(sf::RenderWindow& window) const {
        window.draw(m_sprite);
    }

    /// @brief Helper function to set position of the entity
    void setPosition(const sf::Vector2f position) noexcept {
        m_sprite.setPosition(position);
    }
    
    /// @brief Helper function to get position of the entity
    sf::Vector2f getPosition() const noexcept {
        return m_sprite.getPosition();
    }

    void loadTextureFromRes(const std::string_view path) {
        if (m_texture.loadFromFile(std::string(RES_FOLDER) + path)) {
            m_sprite.setTexture(m_texture, true);
        }
        else {
            throw std::runtime_error("Failed to load texture from " + std::string(RES_FOLDER) + path);
        }
    }

protected:
    sf::Texture m_texture;
    sf::Sprite m_sprite{m_texture};
};
```

> It's in most cases not good idea to put implementation inside header file, since that implantation will copy-pasted in each file which include that header file, everywhere where header included - it will cause recompilation of that file on every implementation change + extra work for compiler and linker to remove duplicates, link inline function. But in scope of game, it's probably safe for background class, since it's not expected to be reused multiple files.
```cpp title:Background.h
#include "Entity.h"

class Background final : public Entity {
public:
    Background() {  
	    loadTextureFromRes("background.png");  
	    m_sprite.setColor({0, 220, 140, 100});  
	    setPosition({0., 0.});  
	}
    ~Background() override = default;

    void update() override {}
};
```
Now we just create background object and draw it in main loop. 


## Moving object: Ball
In game we will have several sprites which can move. We can create a subclass of `Entity` which can be moved or destroyed during game,  `DynamicEntity`. It will have `sf::Vector2f` member for storing velocity, implementation of `Entity` pure virtual functions with require functionality to move entity.  Because we don't anything, class will inherit `Entity` class pure virtual functions and become also an abstract class.  

Ball needs to bounce when it hits and obstructions or edges of screen. 

To do this, we need a getter which provide ball position, we also can add getters for ball center and bounding rectangle. Ball center can be calculated from bounding rectangle origin, it's ${width/2, height/2}$. Those functions can be also useful to other entities, so we can add them in base class as well. 
> In SFML 2.5 to get center can be used `{cpp} return {m_sprite.getGlobalBound().width/2.f, m_sprite.getGlobalBound().height/2.f}`, `width` and `height` are fields of `sf::Rect`. In SFML 3.0 this class was refactored, fields `width`, `height`, `left` and `top`  replaced with `position` and `size`. So better approach will be use just `{cpp}m_sprite.getGlobalBounds().size / 2.f`, vectors support division.

```cpp title:Entity.h

/// @brief Abstract class to represent dynamic graphical entities
class DynamicEntity : public Entity {
public:
    bool isDestroyed() const noexcept {
        return m_isDestroyed;
    }

    void setDestroyed(const bool destroyed) noexcept {
        m_isDestroyed = destroyed;
    }

    /// @brief Helper function to get the bounding box of the entity
    sf::FloatRect getBoundingBox() const noexcept {
        return m_sprite.getGlobalBounds();
    }
    /// @brief Helper function to get the center of the entity
    sf::Vector2f getCenter() const noexcept {
        return m_sprite.getGlobalBounds().size / 2.f;
    }

    /// @brief Helper function to get entity's center position
    sf::Vector2f getCenterPos() const noexcept {
        return m_sprite.getPosition() + getCenter();
    }

protected:
    sf::Vector2f m_velocity {};
private:
    bool m_isDestroyed{false};
};
```

If ball is moving off the screen, we need to make sure it moves back onto the screen, so we need to keep ball inside coordinates ${0 <= x() <= windows\_width, 0 <= y() <= windows\_height}$. When balls coordinate is out of screen bounds, we just change velocity sign to make next ball move in opposite direction.  

```cpp title:"Ball.h"
/// @brief Class represent bouncing ball
class Ball final : public DynamicEntity {
public:
    /// @brief Constructor, arguments represent starting position of ball
    Ball(sf::Vector2f);
    ~Ball() override = default;
    void update() override;
    
	void moveUp() noexcept;  
	void moveDown() noexcept;  
	void moveLeft() noexcept;  
	void moveRight() noexcept;
};
```
```cpp title:"Ball.cpp"
Ball::Ball(const sf::Vector2f pos) {
    loadTextureFromRes("ball.png");
    setPosition(pos);
    m_velocity = {constants::ball_speed, constants::ball_speed};
}

void Ball::update() {
    const auto nextPos = getPosition() + m_velocity;
    // Bounce off the screen edges
    if (nextPos.x < 0 || nextPos.x > constants::window_width)
        m_velocity.x = -m_velocity.x;
    if (nextPos.y < 0)
        m_velocity.y = -m_velocity.y;
    // Bottom edge, in complete game it will be condition of player lost
    // But for debug we can use same action as for top edge and bounce ball from edge
    if (nextPos.y > constants::window_height)
        m_velocity.y = -m_velocity.y;
        //setDestroyed(true);

    m_sprite.move(m_velocity);
}

void Ball::moveUp() noexcept {
    m_velocity.y = -constants::ball_speed;
}

void Ball::moveDown() noexcept {  
    m_velocity.y = -constants::ball_speed;  
}

void Ball::moveLeft() noexcept {
    m_velocity.x = -constants::ball_speed;
}

void Ball::moveRight() noexcept {
    m_velocity.x = constants::ball_speed;
}
```


## Paddle 
Paddle is another movable object in that game project. It will move left and right based on user input. The only tricky part is make a correct coordinates. Since origin on left-top corner and we want to appear paddle at the bottom of screen - proper `y` position will be `windows_height - (paddle_height + floating_offset)`. 
```cpp
Paddle::Paddle() {
    loadTextureFromRes("paddle.png");
    setPosition({constants::window_width / 2.f,
                 constants::window_height - getBoundingBox().size.y - constants::paddle_ground_offset});
}
```

For moving paddle in `{cpp}update()` function we check for pressed key, we only looking for keys for horizontal move (`sf::Keyboard::Key::Left` and `sf::Keyboard::Key::Right`)
```cpp
void Paddle::update() {
    m_velocity.x = 0;

    if (const auto bounds = getBoundingBox()
        ; sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Left) && bounds.position.x > 0) {
        m_velocity.x = -constants::paddle_speed;
    } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Right) &&
               bounds.position.x + bounds.size.x < constants::window_width) {
        m_velocity.x = +constants::paddle_speed;
    }
    m_sprite.move(m_velocity);
}
```

For interaction with ball we need to detect and resolve collisions for ball: if collision between ball and paddle we make ball bounce, if collision between ball and brick - destroy brick. Collision handler can be non-member function, which will call for member functions to change ball direction. 

```cpp title:Intersection.h
#pragma once
#include "Ball.h"
#include "Paddle.h"

inline bool isIntersecting(const Entity& e1, const Entity& e2) noexcept {
    const auto& box1{e1.getBoundingBox()};
    const auto& box2{e2.getBoundingBox()};
    return box1.findIntersection(box2).has_value();
}

inline void handleCollision(Ball& ball, const Paddle& paddle) noexcept {
    if (!isIntersecting(ball, paddle))
        return;

    ball.moveUp();
    if (ball.getCenterPos().x < paddle.getCenterPos().x)
        ball.moveLeft();
    else
        ball.moveRight();
}
```

And only left to add  in game loop `{cpp}handleCollision(ball, paddle)` after calling `{cpp}update()` of both entities. 

## Bricks 
Bricks are located on top of screen, from screen edges usually made offset, to make in simple. We are going to implement this using a vector of sprite objects (usually STL containers for games not suitable due to amount of allocation and deallocation, sometimes in debug mode they slower, so better use alternatives, but for this project it's enough). Next problem is location of bricks on screen, 
```
					     ^          ^ 
					     |  height  |
						 v          | 2 * height
         [###][###][###]            |
         [###][###][###]........... v 
<------->     .
 offset +     .
 width        .
<-----------> .
 offset + 2 * width         
```

> In course James suggested to calculate brick position in main function and coordinates pass to constructor. But with this approach one problem - textures loaded in runtime, while in his implementation bricks sizes - constant expressions, meaning that real size with calculated size can not match. I decided to create first a temporary object to get texture size, calculate how many bricks can I fit, then create bricks in place. Plus added some calculation set how many columns can fit displays with gap between bricks. 
```cpp title:Brickh.h
class Brick final : public DynamicEntity {
public:
    explicit Brick(const sf::Vector2f& pos) noexcept {
        loadTextureFromRes("brick.png");
        setPosition(pos);
    }
    ~Brick() override = default;

    void update() override {}
};
```
```cpp title:Game.cpp
void Game::loop() {
    Brick templateBrick{sf::Vector2f{0.f, 0.f}};
    const auto [brickWidth, brickHeight] = templateBrick.getBoundingBox().size;

    constexpr auto rows {4U};
    const auto cols = constants::window_width / static_cast<uint16_t>(brickWidth) - 3U;
    const auto colGap = (constants::window_width - static_cast<float>(cols) * brickWidth) / static_cast<float>(cols + 1);
    constexpr auto rowGap {5.f};

    std::vector<Brick> bricks;
    bricks.reserve(rows * cols);

    for (auto col {0U}; col < cols; ++col) {
        for (auto row {0U}; row < rows; ++row) {
            auto x = static_cast<float>(col) * (brickWidth + colGap) + colGap;
            auto y = static_cast<float>(row) * (brickHeight + rowGap) + rowGap;
            bricks.emplace_back(sf::Vector2f{x, y);
        }
    }
	...
}
```

When the ball hits a brick, the brick is destroyed - we remove it from vector, so on next iteration of update we only will display not destroyed.
> But deleting from `std::vector` not so cheap operation, since it will also move elements which a right-hand from deleted element. Maybe better to add flag `visible` and based on that flag skip draw function and collision check.

```cpp title:Brick.h
class Brick : public DynamicEntity {
public:
	...
    void draw(sf::RenderWindow& window) const override {
        if (!isVisible())
            return;
        Entity::draw(window);
    }

    bool isVisible() const noexcept { return m_visible; }
    void setInvisible() noexcept { m_visible = false; }

private:
    bool m_visible{true};
};
```

For collision detection, the brick has 4 edges and ball can come from any one of four different directions. To detect collision we look on overlaps between edges of the ball and edges of the brick. For this we need to add also helper functions to get coordinates of bounding boxes edges.
```cpp title:Entity.h
class DynamicEntity : public Entity {
	...
    /// @brief Helper function to coordinate of left bounding box edge
    float left() const { return getBoundingBox().position.x; }

    /// @brief Helper function to coordinate of right bounding box edge
    float right() const { return getBoundingBox().position.x + getBoundingBox().size.x; }

    /// @brief Helper function to coordinate of top bounding box edge
    float top() const { return getBoundingBox().position.y; }

    /// @brief Helper function to coordinate of bottom bounding box edge
    float bottom() const { return getBoundingBox().position.y + getBoundingBox().size.y; }
}
```

When ball get collision with left edge of brick - ball direction changes to left, when bottom edge - ball moves down etc. During overlapping we need to find distance between counterpart edges - smallest distance will be represent place of collapse.
```cpp title:instersect.h
inline void handleCollision(Ball& ball, Brick& brick) noexcept {
    if (!isIntersecting(ball, brick) || !brick.isVisible())
        return;

    brick.setInvisible();

    const float overlapLeft = ball.right() - brick.left();
    const float overlapRight = brick.right() - ball.left();
    const float overlapTop = ball.bottom() - brick.top();
    const float overlapBottom = brick.bottom() - ball.top();

    const float minOverlapX = std::min(overlapLeft, overlapRight);
    const float minOverlapY = std::min(overlapTop, overlapBottom);

    if (minOverlapX < minOverlapY) {
        overlapLeft < overlapRight ? ball.moveRight() : ball.moveLeft();
    } else {
        overlapTop < overlapBottom ? ball.moveDown() : ball.moveUp();
    }
}
```

And last, update game loop.
```cpp
....
for (auto& brick : bricks) {
	brick.update();
	handleCollision(ball, brick);
}
...
for (auto& brick : bricks)
	brick.draw(m_gameWindow);
```

## Game manager 
Game manager is class with will manage the game - initialize entities, perform game loop etc.  We can also add pause/play state, game restart. Game entities (ball, paddle, background, block) will become class members, for this game we only initialize them once in constructor and reset their position on restart. 
Paused game state is meaning that we just don't update entities on new frame. 
> Also, since I hide bricks on ball hit instead deleting it from vector - to restart bricks simply requires to reset visibility flag. But in James architecture - it's fill again vector with new bricks on reset function. 

When handling pause key - use can hold a key, which during events polling result always catching key and flipping game state, which is not desirable effect. Is a workaround we can use flag before pulling events use flag to ignore duplicated key pressed event. 
> Or simply put in constructor `{cpp}m_gameWindow.setKeyRepeatEnabled(false);`. It doesn't brake control for paddle when holding arrow key. 

Second part of refactoring is Entity Manager.  Entity manager will use polymorphism - we store entities as pointers to base class and call virtual functions through pointer to base. It will provide an interface for performing operations on entities more flexible, scalable and  compact. 
All entities will be stored in the game as `{cpp}std::vector<std::unique_ptr<DynamicEntity>>` and additionally "grouped entities" - `std::map` with key depends on entity type and value `std::vector<DynamicEntity*>` of elements with the same type. These pointers will be "aliases" to the entity objects. 
> Or maybe better use instead `std::map` - `{cpp}std::array<std::vector<DynamicEntity*>, static_cast<size_t>(EntityType::Count)>` - it will give same $O(1)$ access by `{cpp}m_groupedEntitie[static_cast<size_t>(type)]`.

Interface to the class are 
+ `{cpp} create()`: create an entity object and add it to `m_allEntities` and `m_groupedEntities`
+ `{cpp}refresh()`: redraw all the entities 
+ `{cpp}clear()`: destroy all entities
+ `{cpp}getAll()`: return all the entities of a given type 
+ `{cpp}applyAll()`: call a function for every entity of a given type 
+ `{cpp}update()`: call `update()` member function of each entity
+ `{cpp}draw()`: call `draw()` member function of each entity

For manager function it's useful to use template functions.  We can also take an advantage of variadic templates and perfect forwarding to support constructors which take parameters (like position etc).
```cpp
template<typename T, typename... Args>
T& create(Args&&... args) {
	static_assert(std::is_base_of_v<Entity, T>,
		          R"("T" must derive from "Entity")");
    auto ptr{std::make_unique<T>(std::forward<Args>(args)...)};
    auto aliasPtr {ptr.get()};

    constexpr auto idx {static_cast<size_t>(T::EntityType)};
	m_groupedEntities[idx].emplace_back(aliasPtr);
    m_allEntities.emplace_back(std::move(ptr));

    return *aliasPtr;
}
```

`{cpp} getAll()` member simply return a corresponding vector of aliases. 
We also need to refactor collision handler - one of solutions is request from manager all balls, with `dynamic_cast` cast it from `DynamicEntity*` to `Ball*`, make similar operations for bricks. But this complicates game loop. Instead, we will add `{cpp}applyAll()` which takes a callable object, a lambda, for all balls we apply lambda which capture `this` of entity manager, inside lambda another  lambda which capture ball and for all bricks apply collision handler. 

```cpp
class EntityManager {
public:
    /// @brief Added new entity into manager. Usage: create<Type>(constructor_arg);
    template<typename T, typename... Args>
    T& create(Args&&... args) {
        // see above
    }

    /// @brief Scan all entities and clean up destroyed
    void refresh() {
        for (auto& aliasVector : m_groupedEntities) {
            std::erase_if(aliasVector,
                          [](const auto& p) { return p->isDestroyed();});
        }
        std::erase_if(m_allEntities, [](const auto& p) { return p->isDestroyed(); });
    }

    /// @brief Destroy all entities
    void clear() {
        for (auto& aliasVector : m_groupedEntities)
            aliasVector.clear();
        m_allEntities.clear();
    }

    /// @brief Call 'update' member function of each entity
    void update() const {
        for (auto& entity : m_allEntities)
            entity->update();
    }

    /// @brief Call 'draw' member function of each entity
    void draw(sf::RenderWindow& window) const {
        for (auto& entity : m_allEntities)
            entity->draw(window);
    }

    /// @brief Get all entities of given type T, returned as std::vector<T*> references
    template <typename T>
    auto& getAll() {
        constexpr auto idx {static_cast<size_t>(T::EntityType)};
        return m_groupedEntities[idx];
    }

    /// @brief Apply callable function to all entities of given type
    template<typename T, typename Func>
    void applyAll(const Func& func) {
        auto& entityGroup{getAll<T>()};

        for (auto ptr : entityGroup)
            func(*dynamic_cast<T*>(ptr));
    }

private:
    using AllEntities = std::vector<std::unique_ptr<DynamicEntity>>;
    /// @brief 'Owner' of all entities
    AllEntities m_allEntities {};

    using GroupEntities = std::array<std::vector<DynamicEntity*>, constants::EntityCount>;
    /// @brief Helper container with 'References' to Entities pointer of the same type.
    GroupEntities m_groupedEntities {};
};
```

How change entities to use `std::array` except `std::map` for grouped entities. 
```cpp title:constants.h
namespace constants {
    enum class EntityType {
        Ball,
        Paddle,
        Brick,
        Count
    };
    static constexpr auto EntityCount {static_cast<size_t>(EntityType::Count)};
};
```
```cpp title:Ball.h
class Ball final : public DynamicEntity {
public:
...
	 static constexpr auto EntityType {constants::EntityType::Ball};
};
```

On of basic game features - start of game, end of game, which we currently not implemented. It's also possible to add player "live". 

For this we need text messages to communicate with the player. `sf::Text` class represent graphical text, which can be drawn on a render target. It has  an associated `sf::Font` object which controls the appearance of the text. Text load quite similar to sprites and textures.

Fore lives we add a member for the number of live to game manager. Each time the ball hits the bottom of the screen, the player loses 1 live - we remove ball when it's below bottom edge of screen and simply check amount of balls - if it's zero -  player lost 1 live.  When the player has no lives, the game is over. When all bricks cleared - player win. We also add some more value to the game state - `gameOver` and `playerWins` and add text associated with that, and also `Unplayable` and `Start` as state for game initialization. 

> Previously I decided instead of removing bricks on ball hit - hide them, since removing brick involves moving all vector elements, which is $O(N)$ + it can invalidate pointers. And it's true that we will iterate over hidden bricks, but since we start from _Nmax_ and amount of bricks not grow - optimization from reducing amount of bricks from my opinion not a point - game should work good on every stages. But for for checked did player won - we need to check is there any visible bricks left on screen, which is iterate all over bricks again. Probably best solution would be swap 'defeated' brick with last 'alive' brick, _swap and pop_, but for consistency I leave as it is and just add brick counter in lambda which check collision. 

```cpp title:Game.h
namespace constants {  
    static constexpr int player_lives {3};  
}
class Game {
public:
    Game();
    ~Game() = default;
    
    /// @brief Represent one game session - Start -> Game loop -> Game Over
    void start();

private:
    /// @brief Purge previous entities and create new
    void reset();

    /// @brief Implements game loop, Clear -> Update -> Draw
    void loop();

    /// @brief Handles new cycle of game: clear screen, check for general use input (close, pause, restart)
    void handleNewFrame();

    /// @brief Handle entities update during game loop: update entities themselves and handle collisions
    void updateEntities();

    enum class GameState {Start, Paused, Unpaused, GameOver, PlayerWin, Unplayable};

    EntityManager m_entityManager {};
    GameState m_state{GameState::Start};
    sf::RenderWindow m_gameWindow;
    Background m_background {};

    sf::Font m_gameFont{std::string(RES_FOLDER) + "Library 3 am.otf"};
    sf::Text m_gameText{m_gameFont};
    sf::Text m_playerLivesText{m_gameFont};

    int m_playerLives {constants::player_lives};
};
```

We now almost have _State machine_: 
+ On first start - we try to load entities, if during entities loading we catch any exception - game in `Unplayable` state. If loaded - in `Start` state.
+ In `Unplayable` state: we only display error message, and prevent transition to other states. 
+ In `Start` state: show hint how to start game ("Press P"), can skip drawing ball and paddle, don't need to display player lives. From `Start` we can go to `Unpaused`. 
+ In `Unpaused` state: game is active, we update players live, update entities. And can go either `Paused`, `PlayerWins`, `GameOver`.
+ In `Paused`state: we only cut off entities update, making paddle and ball locked, since paddle and ball position not changing - we can skip coalition check. From `Paused` we can go to `Start` state.
+ In `PlayerWins` and `GameOver`: show only text with state and hint how to restart game ("Press R"), which wrap back to  `Start`.  

```cpp title:Game.cpp
namespace constants {  
    static constexpr sf::Vector2f initial_ball_position {window_width / 2.0f, window_height / 2.0f};  
    static constexpr sf::Vector2f game_text_position {window_width / 2.0f - 150.f, window_height / 2.0f - 100.f};  
    static constexpr sf::Vector2f lives_text_position {50.f, window_height / 2.0f - 100.f};  
    static constexpr sf::Color text_color {210, 109, 10};  
}  
  
Game::Game() : m_gameWindow {sf::VideoMode({constants::window_width, constants::window_height}),  
                             "Breakout game"} {  
    m_gameWindow.setFramerateLimit(60);  
    m_gameWindow.setKeyRepeatEnabled(false);  
  
    m_gameText.setPosition(constants::game_text_position);  
    m_gameText.setFillColor(constants::text_color);  
    m_playerLivesText.setPosition(constants::lives_text_position);  
    m_playerLivesText.setFillColor(constants::text_color);  
}  
  
void Game::reset() {  
    m_state = GameState::Start;  
    m_playerLives = constants::player_lives;  
  
    try {  
        m_entityManager.clear();  
        m_entityManager.create<Ball>(constants::initial_ball_position);  
        m_entityManager.create<Paddle>();  
  
        const Brick templateBrick{{0., 0.}};  
        const auto [brickWidth, brickHeight] = templateBrick.getBoundingBox().size;  
  
        constexpr auto rows {4U};  
        const auto cols = constants::window_width / static_cast<uint16_t>(brickWidth) - 3U;  
        const auto colGap = (constants::window_width - static_cast<float>(cols) * brickWidth) / static_cast<float>(cols + 1);  
        constexpr auto rowGap {5.f};  
  
        for (auto col {0U}; col < cols; ++col) {  
            for (auto row {0U}; row < rows; ++row) {  
                const auto x = static_cast<float>(col) * (brickWidth + colGap) + colGap;  
                const auto y = static_cast<float>(row) * (brickHeight + rowGap) + rowGap;  
                m_entityManager.create<Brick>(sf::Vector2f{x, y});  
            }  
        }  
    }  
    catch (std::exception& e) {  
        std::cerr << e.what() << std::endl;
        m_state = GameState::Unplayable;  
    }  
}  
  
void Game::start() {  
    reset();
    loop();  
}  
  
void Game::loop() {  
    while (m_gameWindow.isOpen()) {  
        handleNewFrame();  
        updateEntities();  
        if (m_state == GameState::Paused || m_state == GameState::Unpaused)  
            m_entityManager.draw(m_gameWindow);  
        m_gameWindow.display();  
    }  
}  
  
void Game::handleNewFrame() {  
    // Clear windows  
    m_gameWindow.clear(sf::Color::Black);  
    m_background.draw(m_gameWindow);  
    m_gameWindow.draw(m_gameText);  
    m_gameWindow.draw(m_playerLivesText);  
  
    // Handle game inputs  
    while (const auto event = m_gameWindow.pollEvent()) {  
	    if (event->is<sf::Event::Closed>())  
	        m_gameWindow.close();  
	  
	    if (const auto* keyPressed = event->getIf<sf::Event::KeyPressed>())  
	    {  
	        using namespace sf::Keyboard;  
	        if (keyPressed->scancode == Scancode::Escape)  
	            m_gameWindow.close();  
	        if (m_state != GameState::Unplayable) {  
	            if (keyPressed->scancode == Scancode::R)  
	                reset();  
	            if (keyPressed->scancode == Scancode::P) {  
	                if (m_state == GameState::Unpaused)  
	                    m_state = GameState::Paused;  
	                else if (m_state == GameState::Paused)  
	                    m_state = GameState::Unpaused;  
	                else if (m_state == GameState::Start)  
	                    m_state = GameState::Unpaused;  
	            }  
	        }  
	    }  
	} 
  
    m_playerLivesText.setString("");  
    switch (m_state) {  
        case GameState::Start:  
            m_gameText.setString("Press [P]lay");  
            break;  
        case GameState::GameOver:  
            m_gameText.setString("Game Over\n [R]estart?");  
            break;  
        case GameState::PlayerWin:  
            m_gameText.setString("Player Win\n [R]estart?");  
            break;  
        case GameState::Unplayable:  
            m_gameText.setString("Can't start game - failed to load entities");  
            break;  
        case GameState::Paused:  
            m_gameText.setString("[P]aused, press [P]lay");  
            m_playerLivesText.setString("Lives: " + std::to_string(m_playerLives));  
            break;  
        case GameState::Unpaused:  
            m_playerLivesText.setString("Lives: " + std::to_string(m_playerLives));  
        default:  
            m_gameText.setString("");  
            break;  
    }  
}  
  
void Game::updateEntities() {  
    if (m_state != GameState::Unpaused)  
        return;  
  
    m_entityManager.update();  
  
    int visibleBrickCount = 0;  
    m_entityManager.applyAll<Ball>([this, &visibleBrickCount](auto& ball) {  
       m_entityManager.applyAll<Brick>([&ball, &visibleBrickCount](auto& brick) {  
           handleCollision(ball, brick);  
           if (brick.isVisible())  
               visibleBrickCount++;  
       });  
    });  
  
    m_entityManager.applyAll<Ball>([this](auto& ball) {  
       m_entityManager.applyAll<Paddle>([&ball](auto& paddle) {  
           handleCollision(ball, paddle);  
       });  
    });  
  
    m_entityManager.refresh();  
  
    if (visibleBrickCount == 0) {  
        m_state = GameState::PlayerWin;  
        return;  
    }  
  
    if (m_entityManager.getAll<Ball>().empty()) {  
        m_playerLives--;  
        if (m_playerLives == 0) {  
            m_state = GameState::GameOver;  
            m_gameText.setString("Game Over");  
        }  
        else {  
            auto paddleCenter = m_entityManager.getAll<Paddle>().back()->getCenterPos();  
            m_entityManager.create<Ball>(sf::Vector2f{paddleCenter.x, paddleCenter.y - 30.f});  
            m_state = GameState::Paused;  
        }  
    }  
}
```