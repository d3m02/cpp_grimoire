SFML - [The  Simple and Fast Multimedia Library](https://www.sfml-dev.org/) - an easy to use and well documented library written on modern C++ which provides an interface to the multimedia components of computer. 
It's working with different operating systems. Library contain modules for different purposes:
+ _System module_ - mostly not relevent for modern C++ since most of provided features (like time handling, threads etc) part of modern C++, so module for more working with older versions/C
+ _Window module_ - managing windows, interactive with event, keyboard etc.
+ _Graphics module_ - drawing, working with sprites and textures, texts and fonts, shapes etc.
+ _Audio module_ - playing sounds and music, recording audio etc
+ _Network module_ - communication using sockets, packets handling, HTTP/FTP etc

> [!Attention] Course designed around SFML 2.5, which is now outdated

## CMake installing 
> It's my own note, in course provided instruction for Visual Code. 

Web site provide [CMake instruction](https://www.sfml-dev.org/tutorials/3.0/getting-started/cmake/), which probably can be simplified to including into CMake project
```cmake
cmake_minimum_required(VERSION 3.28)

include(FetchContent)
FetchContent_Declare(SFML
    GIT_REPOSITORY https://github.com/SFML/SFML.git
    GIT_TAG 3.0.2
    GIT_SHALLOW ON
    EXCLUDE_FROM_ALL
    SYSTEM)
FetchContent_MakeAvailable(SFML)

target_link_libraries({project} PRIVATE SFML::Graphics)
```
 
 Alternatively, create a submodule in project 
 ```bash
 mkdir external
 git submodule add https://github.com/SFML/SFML.git external/SFML
 ```
 and in CMake project file 
 ```cmake
# For linking library probably examples and tests are redundant
set(SFML_BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
set(SFML_BUILD_TEST_SUITE OFF CACHE BOOL "" FORCE)

add_subdirectory(${EXTERN_LIBS_PATH}/SFML "${CMAKE_BINARY_DIR}/SFML")
include_directories(${EXTERN_LIBS_PATH}/SFML/include)

target_link_libraries(
	untitled
        PRIVATE
    SFML::Graphics
    SFML::Window
)
 ```

## Basic windows 
SFML defines in `<SFML/Graphics.hpp>` classes which we require for window. These are in the `sf` namespace, 
+ `sf::Windows` - base class which represent a windows on the screen which does nothing really.
+ `sf::RenderWindows` - represents a windows which can be used for 2D drawing. 
+ `sf::Event` - union which contains a user interaction event (click on windows, pressing key while the windows has focus etc).
	> In v3.0 it's not union, it's `std::variant`

`RenderWindow` have 3 important member functions: `{cpp} clear(Color color)` for clearing the windows, `{cpp} draw()` - draw in the memory buffer which is maintained by the window (it will not change what is user see currently on the screen) and `{cpp} display()` which makes the contents of the memory buffer appear on the display. Those 3 functions usually run in loop, `clear -> draw -> display`. 

Constructor of `RenderWindow` takes as argument 2D vector with the windows dimensions (in this case it's worth to store them as `static constexpr int`) and optional title name of window. 
> [!note] 
> Constructor as first argument takes class `VideoMode` which in v2.5 have constructor `{cpp} VideoMode(unsigned int modeWidth, unsigned int modeHeight, unsigned int modeBitsPerPixel = 32);`. 
> However in v3.0 constructor is `{cpp}explicit VideoMode(Vector2u modeSize, unsigned int modeBitsPerPixel = 32);`, which mean that to for constructor `RenderWindow` - first argument will be `{cpp} sf::VideoMode({constants::window_width, constants::window_height})`    

Usually it's good idea to limit the frame rate with `{cpp}setFramerateLimit(60)` - how often the windows will update, higher FPS mean higher lowed on CPU, 60 FPS is usually is enough.  

After than we create game loop while windows is open, `{cpp}while(gameWindows.isOpen())`. 
First step we clear current windows and fill with black color, `{cpp} gameWindows.clear(sf::Color::Black)`; 

Then we check for user interaction events. By calling `{cpp}pollEvent(event)` the windows will stop and wait for some user event. Then it will check for _all events_.  We check type of event (since event is tagged ~~union~~ `std::variant`) and perform required actions. `sf::Event::Closed` means the user has done something which will close the windows, like clicking 'X' or pressing 'Alt-F4'. `close()`  window's member function will terminate the program. For keyboard press can be used static method `sf::Keyboard::isKeyPressed`, which take a key to test. The following example will be handler for application closing on ESC key or any system-provided close event.

```cpp fold:"Deprecated SFML V2.5 example"
sf::Event event;
while (gameWindows.pollEvent(event)) {
	if (event.type == sf::Event::Closed)
		gameWindows.close();	
}
if (sf::Keyboard:isKeyPressed(sf::Keyboard::Key::Escape))
	gameWindows.close();
```
```cpp title:"SFML v3.0 example"
while (const auto event = gameWindow.pollEvent()) {
	if (event->is<sf::Event::Closed>()) {
	    gameWindow.close();
    }
    // sf::Keyboard::isKeyPressed still available, but probably handling events inside one loop is more convenient 
	else if (const auto& keyPressed = event->getIf<sf::Event::KeyPressed>())
    {
	    if (keyPressed->scancode == sf::Keyboard::Scancode::Escape) {
	        gameWindow.close();
        }
    }
}
```

After that will be code for calculating and update graphics (placeholder  for `draw()`)
And in the end, with calling `display()` we update display for the next frame.

```cpp title:"Lesson example"
Game::Game() : m_gameWindow {sf::VideoMode({constants::window_width, constants::window_height}),
                             "Breakout game"} {
    m_gameWindow.setFramerateLimit(60);
}

void GameLoop::run() {
    while (gameWindow.isOpen()) {
        clearWindow();
		// update objects and draw objects
        gameWindow.display();
    }
}

void Game::clearWindow() {
    m_gameWindow.clear(sf::Color::Black);

    while (const auto event = m_gameWindow.pollEvent()) {
        if (event->is<sf::Event::Closed>()) {
            m_gameWindow.close();
        }
        else if (const auto* keyPressed = event->getIf<sf::Event::KeyPressed>())
        {
            if (keyPressed->scancode == sf::Keyboard::Scancode::Escape)
                m_gameWindow.close();
        }
    }
}
```

## Random walk
Firstly, we need to start off with a couple more concepts from SFML. 
+ `sf::Vector2` - represents a 2D vector with members `x` and `y` can be accessed directly. It's a template class with support of common arithmetic operations. 
+ `sf::Vector2f` - alias for `sf::Vector2<float>` instantiation. SFML uses `float` internally, so this vector will be used quite often. 
+ `sf::Texture` - represents an image which will be loaded into the graphics card and then can be drawn on a render target, such as render window. This drawn will be done by the graphics card.
+ `sf::Shape` - an abstract base class which represents a pre-defined texture. It has a _texture rectangle_ associated with it. All transformations are relative to the "origin" of the shape, be default this is the top left-hand corner of the texture rectangle. 
	+ `sf::CircleShape` - a subclass of `sf::Shape` representing a circle 
	+ `sf::ConvexShape` - a subclass of `sf::Shape` representing a convex polygon
	+ `sf::RactangleShape` -  a subclass of `sf::Shape` representing a rectangle 

In this example we create class which represent some 'creature'. In constructor we provide position where spawn it. Create have two variable `m_vx` and `m_vy` which control it's movement, 
        `-m_vy`
`-m_vx`                   `+m_vx`
         `m_vy`
Random walk implemented in `update` function, which uses Bernoulli distribution to get with 50/50 change `true` or `false`, which will flip sign of move variable and on each frame we move object by set values. Since random generator and distribution declared as `static` - they must be initialized outside class. And last member function is `{cpp}draw()` which will draw a creature on a provided windows. 
```cpp title:"Exaple from lesson"
class Creature {
public:
    /// @brief Create a creature in the requested position.
    Creature(float x, float y) {
        m_circle.setRadius(10.0f);
        m_circle.setPosition({x, y});
        m_circle.setFillColor(sf::Color::Red);
    }

    /// @brief Draw a creature on a provided window
    void draw(sf::RenderWindow& window) const {
        window.draw(m_circle);
    }

    /// @brief Calculate the creature's new position
    void update() {
        m_vx = bd(mt) ? m_vx : -m_vx;
        m_vy = bd(mt) ? m_vy : -m_vy;
        m_circle.move({m_vx, m_vy});
    }
private:
    // Random numer with 50/50 chance of true or false
    static std::mt19937 mt;
    static std::bernoulli_distribution bd;

    float m_vx{4.0f};                         /// @brief Control movements, positive - move right, negative - move left
    float m_vy{4.0f};                         /// @brief Control movements, positive - move down, negative - move up
    sf::Vector2f m_velocity{m_vx, m_vy};      /// @brief Creature velocity

    sf::CircleShape m_circle;                 /// @brief Used graphical object
};

// Initialized static variables
std::mt19937 Creature::mt;
std::bernoulli_distribution Creature::bd;

void GameLoop::run() {
	// Create window
	
	// Create a creature in the middle of a window
    Creature creature {constants::window_width / 2.0f, constants::window_height / 2.0f};
    while (gameWindow.isOpen()) {
		
		// after chacking events
		creature.update();
        creature.draw(gameWindow);
        
	    gameWindow.display();
    }
```

## Sprite 
`sf::Sprite`  represents a texture associated with a rectangle, similar to `sf::Shape`, but we provide our own image. They loaded into the graphics card and alternative when pre-defined by library options not enough. It's represents a group of pixels as a single graphical entity. 

To create a sprite, first we need a texture, `sf::Texture`. In that object we can use `{cpp} loadFromFile` to load a texture into a graphics card. Loading can fail if the image is not valid or image file in not in the expected directory, so it's worth to check result was a image loaded. Once we have texture, we can create the `sf::Sprite` object and set texture, `{cpp}setTexture(texture)` to associate this texture with sprite. 

In this game we require several sprites, to organize them we create an entity class to represent them - this will be an abstract base class and concrete sprite class will inherit from entity. 
Base class will contain `sf::Sprite` and pure virtual interfaces.
> [!note] 
> In SFML v3.0 removed default constructors for `sf::Sprite` and such base class not possible to compiler, since only left explicit constructor which takes texture, so we also need to add a texture to base class. If pass in sprite in-class member initialization default-initialized texture - sprite will have 0x0 rectangle, so after loading an image - we need to reset rectangle.
>
> Also, not agree with design - `draw()` function will be exactly same for all sub classes, but we can keep it as `virtual` in case if some different implementation will be required. Since each texture needs to be loaded from file in constructor, it's worth to add in base class non-virtual function  which take filename of resource, loads it into texture and recalculate rectangle. I using CMake for project and learn one trick to easily handle resource files - define a macro in CMakeLists.txt which will be expanded to absolute path to resource folder 
> ```cmake
> add_compile_definitions (RES_FOLDER="${CMAKE_CURRENT_SOURCE_DIR}/res/")
> ```

```cpp title:Entity.h
#include <string_view>
#include "SFML/Graphics/RenderWindow.hpp"

/// @brief Abstract class to represent graphical entities
class Entity {
public:
    virtual ~Entity() = default;

    virtual void update() = 0;
    virtual void draw(sf::RenderWindow& window) const {
        window.draw(m_sprite);
    }
	/// @brief Helper function to load texture with given name from project resouce folder and reset texture rectangle 
    void loadTextureFromRes(const std::string_view path) {
        if (m_texture.loadFromFile(std::string(RES_FOLDER) + path)) {
            m_sprite.setTexture(m_texture, true);
        }
    }

protected:
	sf::Texture m_texture;
    sf::Sprite m_sprite{m_texture};
};
```

> It's in most cases not good idea to put implementation inside header file, since that implantation will copy-pasted in each file which include that header file, everywhere where header included - it will cause recompilation of that file on every implementation change + extra work for compiler and linker to remove duplicates, link inline function. But in scope of game, it's probably safe for background class, since it's not expected to be reused multiple files.
```cpp title:Background.h
#include "Entity.h"

class Background final : public Entity {
public:
    Background() {  
	    loadTextureFromRes("background.png");  
	    m_sprite.setColor({0, 220, 140, 100});  
	    setPosition({0., 0.});  
	}
    ~Background() override = default;

    void update() override {}
};
```
Now we just create background object and draw it in main loop. 


## Moving object: Ball
In game we will have several sprites which can move. We can create a subclass of `Entity` which represents an entity with move possibilities, `MovingEntity`. It will have `sf::Vector2f` member for storing velocity, implementation of `Entity` pure virtual functions with require functionality to move entity.  Because we don't anything, class will inherit `Entity` class pure virtual functions and become also an abstract class.  

Ball needs to bounce when it hits and obstructions or edges of screen. 

To do this, we need a getter which provide ball position, we also can add getters for ball center and bounding rectangle. Ball center can be calculated from bounding rectangle origin, it's ${width/2, height/2}$. Those functions can be also useful to other entities, so we can add them in base class as well. 
> In SFML 2.5 to get center can be used `{cpp} return {m_sprite.getGlobalBound().width/2.f, m_sprite.getGlobalBound().height/2.f}`, `width` and `height` are fields of `sf::Rect`. In SFML 3.0 this class was refactored, fields `width`, `height`, `left` and `top`  replaced with `position` and `size`. So better approach will be use just `{cpp}m_sprite.getGlobalBounds().size / 2.f`, vectors support division.

```cpp title:Entity.h
/// @brief Abstract class to represent movable graphical entities
class Entity {
...
public:
    /// @brief Helper function to get the bounding box of the entity
    sf::FloatRect getBoundingBox() const noexcept {
        return m_sprite.getGlobalBounds();
    }
    /// @brief Helper function to get the center of the entity
    sf::Vector2f getCenter() const noexcept {
        return m_sprite.getGlobalBounds().size / 2.f;
    }

    /// @brief Helper function to get entity's center position
    sf::Vector2f getCenterPos() const noexcept {
        return m_sprite.getPosition() + getCenter();
    }

    /// @brief Helper function to get position of the entity
    sf::Vector2f getPosition() const noexcept {
        return m_sprite.getPosition();
    }

    /// @brief Helper function to set position of the entity
    void setPosition(const sf::Vector2f position) noexcept {
        m_sprite.setPosition(position);
    }
};
class MovingEntity : public Entity {
protected:
    sf::Vector2f m_velocity;
};
```


If ball is moving off the screen, we need to make sure it moves back onto the screen, so we need to keep ball inside coordinates ${0 <= x() <= windows\_width, 0 <= y() <= windows\_height}$. When balls coordinate is out of screen bounds, we just change velocity sign to make next ball move in opposite direction.  

```cpp title:"Ball.h"
/// @brief Class represent bouncing ball
class Ball : public MovingEntity {
public:
    /// @brief Constructor, arguments represent starting position of ball
    Ball(float x, float y);
    ~Ball() override = default;
    void update() override;
    
	void moveUp() noexcept;  
	void moveLeft() noexcept;  
	void moveRight() noexcept;
};
```
```cpp title:"Ball.cpp"
Ball::Ball(float x, float y) {
    loadTextureFromRes("ball.png");
    setPosition({x, y});
    m_velocity = {constants::ball_speed, constants::ball_speed};
}

void Ball::update() {
    const auto nextPos = getPosition() + m_velocity;
    // Bounce off the screen edges
    if (nextPos.x < 0 || nextPos.x > constants::window_width)
        m_velocity.x = -m_velocity.x;
    if (nextPos.y < 0 || nextPos.y > constants::window_height)
        m_velocity.y = -m_velocity.y;

    m_sprite.move(m_velocity);
}

void Ball::moveUp() noexcept {
    m_velocity.y = -constants::ball_speed;
}

void Ball::moveLeft() noexcept {
    m_velocity.x = -constants::ball_speed;
}

void Ball::moveRight() noexcept {
    m_velocity.x = constants::ball_speed;
}
```


## Paddle 
Paddle is another movable object in that game project. It will move left and right based on user input. The only tricky part is make a correct coordinates. Since origin on left-top corner and we want to appear paddle at the bottom of screen - proper `y` position will be `windows_height - (paddle_height + floating_offset)`. 
```cpp
Paddle::Paddle() {
    loadTextureFromRes("paddle.png");
    setPosition({constants::window_width / 2.f,
                 constants::window_height - getBoundingBox().size.y - constants::paddle_ground_offset});
}
```

For moving paddle in `{cpp}update()` function we check for pressed key, we only looking for keys for horizontal move (`sf::Keyboard::Key::Left` and `sf::Keyboard::Key::Right`)
```cpp
void Paddle::update() {
    m_velocity.x = 0;

    if (const auto bounds = getBoundingBox()
        ; sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Left) && bounds.position.x > 0) {
        m_velocity.x = -constants::paddle_speed;
    } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Right) &&
               bounds.position.x + bounds.size.x < constants::window_width) {
        m_velocity.x = +constants::paddle_speed;
    }
    m_sprite.move(m_velocity);
}
```

For interaction with ball we need to detect and resolve collisions for ball: if collision between ball and paddle we make ball bounce, if collision between ball and brick - destroy brick. Collision handler can be non-member function, which will call for member functions to change ball direction. 

```cpp title:Intersection.h
#pragma once
#include "Ball.h"
#include "Paddle.h"

inline bool isIntersecting(const Entity& e1, const Entity& e2 ) noexcept {
    const auto& box1{e1.getBoundingBox()};
    const auto& box2{e2.getBoundingBox()};
    return box1.findIntersection(box2).has_value();
}

inline void handleCollision(Ball& ball, const Paddle& paddle) noexcept {
    if (!isIntersecting(ball, paddle))
        return;

    ball.moveUp();
    if (ball.getCenterPos().x < paddle.getCenterPos().x)
        ball.moveLeft();
    else
        ball.moveRight();
}
```

And only left to add  in game loop `{cpp}handleCollision(ball, paddle)` after calling `{cpp}update()` of both entities. 

## Bricks 
Bricks are located on top of screen, from screen edges usually made offset, to make in simple. We are going to implement this using a vector of sprite objects (usually STL containers for games not suitable due to amount of allocation and deallocation, sometimes in debug mode they slower, so better use alternatives, but for this project it's enough). Next problem is location of bricks on screen, 
```
					     ^          ^ 
					     |  height  |
						 v          | 2 * height
         [###][###][###]            |
         [###][###][###]........... v 
<------->     .
 offset +     .
 width        .
<-----------> .
 offset + 2 * width         
```

> In course James suggested to calculate brick position in main function and coordinates pass to constructor. But with this approach one problem - textures loaded in runtime, while in his implementation bricks sizes - constant expressions, meaning that real size with calculated size can not match. I decided to create first a temporary object to get texture size, calculate how many bricks can I fit, then create bricks in place. Plus added some calculation set how many columns can fit displays with gap between bricks. Since resulted code quite messy, I moved it to factory-like function
```cpp title:Brickh.h

class Brick : public Entity {
public:
    Brick() noexcept {
        loadTextureFromRes("brick.png");
    }
    ~Brick() override = default;

    void update() override {}
};

inline std::vector<Brick> createBricks() {
    Brick templateBrick{};
    const auto [brickWidth, brickHeight] = templateBrick.getBoundingBox().size;

    constexpr auto rows {4U};
    const auto cols = constants::window_width / static_cast<uint16_t>(brickWidth) - 3U;
    const auto colGap = (constants::window_width - static_cast<float>(cols) * brickWidth) / static_cast<float>(cols + 1);
    constexpr auto rowGap {5.f};

    std::vector<Brick> bricks;
    bricks.reserve(rows * cols);

    for (auto col {0U}; col < cols; ++col) {
        for (auto row {0U}; row < rows; ++row) {
            auto x = static_cast<float>(col) * (brickWidth + colGap) + colGap;
            auto y = static_cast<float>(row) * (brickHeight + rowGap) + rowGap;
            bricks.emplace_back();
            bricks.back().setPosition({x, y});
        }
    }
    return bricks;
}
```

When the ball hits a brick, the brick is destroyed - we remove it from vector, so on next iteration of update we only will display not destroyed.
> But deleting from `std::vector` not so cheap operation, since it will also move elements which a right-hand from deleted element. Maybe better to add flag `visible` and based on that flag skip draw function and collision check.

```cpp title:Brick.h
class Brick : public Entity {
public:
	...
    void draw(sf::RenderWindow &window) const override {
        if (!isVisible())
            return;
        Entity::draw(window);
    }

    bool isVisible() const noexcept { return m_visible; }
    void setInvisible() noexcept { m_visible = false; }

private:
    bool m_visible{true};
};
```

For collision detection, the brick has 4 edges and ball can come from any one of four different directions. To detect collision we look on overlaps between edges of the ball and edges of the brick. For this we need to add also helper functions to get coordinates of bounding boxes edges.
```cpp title:Entity.h
class Entity {
	...
    /// @brief Helper function to coordinate of left bounding box edge
    float left() const { return getBoundingBox().position.x; }

    /// @brief Helper function to coordinate of right bounding box edge
    float right() const { return getBoundingBox().position.x + getBoundingBox().size.x; }

    /// @brief Helper function to coordinate of top bounding box edge
    float top() const { return getBoundingBox().position.y; }

    /// @brief Helper function to coordinate of bottom bounding box edge
    float bottom() const { return getBoundingBox().position.y + getBoundingBox().size.y; }
}
```

When ball get collision with left edge of brick - ball direction changes to left, when bottom edge - ball moves down etc. During overlapping we need to find distance between counterpart edges - smallest distance will be represent place of collapse.
```cpp title:instersect.h
inline void handleCollision(Ball& ball, Brick& brick) noexcept {
    if (!isIntersecting(ball, brick) || !brick.isVisible())
        return;

    brick.setInvisible();

    const float overlapLeft = ball.right() - brick.left();
    const float overlapRight = brick.right() - ball.left();
    const float overlapTop = ball.bottom() - brick.top();
    const float overlapBottom = brick.bottom() - ball.top();

    const float minOverlapX = std::min(overlapLeft, overlapRight);
    const float minOverlapY = std::min(overlapTop, overlapBottom);

    if (minOverlapX < minOverlapY) {
        overlapLeft < overlapRight ? ball.moveRight() : ball.moveLeft();
    } else {
        overlapTop < overlapBottom ? ball.moveDown() : ball.moveUp();
    }
}
```

And last, update game loop.
```cpp
....
for (auto& brick : bricks) {
	brick.update();
	handleCollision(ball, brick);
}
...
for (auto& brick : bricks)
	brick.draw(m_gameWindow);
```