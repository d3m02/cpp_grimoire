In STL presented 3 types of container:
* *Sequential containers* - data is stored in an order which is determined by the program. The order doesn't depend on its value and data will remain in the same position unless the program performs some action which changes them (move, reallocation etc). 
Those containers are `std::array`, `std::vector`, `std::list`, `std::forward_list`, `std::deque`, (`std::implace_vector` and `std::hive` which planned in C++26), from some perspective `std::string`,  (and `std::valarray`, `std::initializer_list`, `std::bitset` but they don't have iterators).
* *Associative containers* - data order depends on the data to provide better search (using red-black tree or hash tables). 
In C++ provided two types of associative containers, `std::set` which have only sorted unique keys and `std::map` which represents pair key-value. Beside that exist  `unorded_` modification, which uses hash tables for keys for faster search, but not sorted (`std::unorded_map`, `std::unorded_set`). And also exists multi-modification, (`std::multiset`, `std::multimap`, `std::unorded_multiset`, `std::unorded_multimap`), which allow non-unique keys. 
* *Containers adapters* - provide some different interface using sequential containers.
Examples are `std::stack`, `std::queue`, `std::priority_queue`, `std::flat_set`, `std::flat_map`, `std::flat_multiset`, `std::flat_multimap`. 


## Built-in array
C++ has a inherited from C array. 
`{cpp} int arr[] = {1, 2, 3};`
It's faster than `std::vector`, directly compatible with C code, can be allocated both on heap and stack. 
But it have serious disadvantages: 
* No direct way to find number of elements, either store separately or calculate each time.
* "Silent" conversion to pointer.
* Arrays can't be assigned ti each other.

## std::array
>[!code-ref]
>```cpp
>template<class T, std::size_t N> 
>struct std::array;
>```

`std::array` is  a templated wrapper for Built-in arrays, defined in `<array>`. 

`std::array` require two template arguments, elements type and number of elements. Number of elements also part of the object and using an array with wrong number of elements (for example, in function argument parameter) will give a compiler error. It has a similar interface to STL containers, while retaining the speed of build-in arrays, doesn't automatically decay to pointer, retains information about its size and supports iterators. 

An `std::array` object can only be created on the stack, number of elements must be known at compile time, a contiguous block of memory will be allocated to store the elements.
Unlike other containers, the default constructor creates a fully-sized object with default-initialized elements, while other containers 'empty'.

Starting from C++17 it's possible to skip template parameter specification when providing initial values in initialization, complier will use template argument deduction. 
```cpp
#include <array>

std::array<int, 5> arr {1, 2, 3, 4, 5};
std::array f_arr {1.0f, 2.0f, 3.0f, 4.0f, 5.0f};
```

Iterators of `std::array` are *Random Access Iterators* and *Contiguous Iterators* (from C++20 also *Contexpr Iterators*). 

### Member functions
>[!code-ref] `{cpp} operator=(std::array other)` 
> Overwrites every element if the array with the corresponding elements of another array 

>[!code-ref]+ `{cpp} std::size_t .size()`
>Returns number of elements 
>
>Complexity - $O(1)$

>[!code-ref] `{cpp}bool .empty()`
> Return `true` if container is empty.
> 
> Complexity - $O(1)$

>[!code-ref] `{cpp} T& operator[](std::size_t pos)` / `{cpp}const T& operator[](std::size_t pos) const`
> Access element by index without bounds checking.
> 
> Complexity - $O(1)$
> Never inserts a new element into the container. 

>[!code-ref] `{cpp}std::size_t .max_size() const`
> Return maximum number of elements (`N`)
> 
> Complexity - $O(1)$

>[!code-ref] `{cpp}T& at(std::size_t pos)` / `{cpp}const T& at(std::size_t pos) const`
>Access element by index with bounds checking. 
>
> Complexity - $O(1)$
>Throw `std::out_of_range` exception. 

>[!code-ref] `{cpp}T& .front()` / `{cpp}const T& .front() const`
>Get first element
>
>Complexity - $O(1)$
>Equivalent to `{cpp}*arr.begin()`
>*UB* for empty container.

>[!code-ref] `{cpp}T& .back()` / `{cpp}const T& .back() const`
>Get last element. 
>
>Complexity - $O(1)$
>Equivalent to `{cpp}*std::prev(arr.end())`.
>*UB* for empty container.

>[!code-ref] `{cpp}T* .data()` / `{cpp}const T* .data() const`
> Return a pointer to underlying array (C-style array)
> 
>Complexity - $O(1)$

>[!code-ref] `{cpp}void .fill(const T& value)`
> Assign all elements to `value`
> 
>Complexity - $O(N)$

>[!code-ref] `{cpp}void .swap( std::array& other)`
> Swaps the content of the containers with `other`.
> 
>Complexity - $O(N)$.
> `{cpp}noexcept(std::is_nothrow_swappable_v<T>)`

>[!code-ref]+ Get iterators, support all type of iterators
> * `iterator`: `{cpp}.begin()` and `{cpp}.end()`
> * `const_iterator`: `{cpp}.cbegin() const` and `{cpp}.cend() const`
> * `reverse_iterator`: `{cpp}.rbegin()` and `{cpp}.rend()`
> * `const_reverse_iterator`: `{cpp}.crbegin() const` and `{cpp}.crend() const`
> 
>  Complexity - $O(1)$

### Non-member functions
>[!code-ref] Lexicographical elements compare, all variations of `std::operator...`
>Complexity - $O(1)$

>[!code-ref] `{cpp} T& get<I>(std::array a)`/`{cpp} T&& get<I>(std::array a) const`/`{cpp} const T& get<I>(std::array a)`/`{cpp} const T&& get<I>(std::array a) const`
>Extract `I` element using tuple-like interface. 
>
> Using `std::` namespace not required, can be used for both set and get values. 
> ```cpp
> std::array<int, 5> arr {1, 2, 3, 4, 5};
> get<0>(arr) = 6, get<1>(arr) = 0; // set arr[0] and arr[1]
> ```
> Complexity - $O(1)$

>[!code-ref] `{cpp} std::array std::to_array<T>(T (&a)[N])` / `{cpp} std::array std::to_array<T>(T (&&a)[N])` _(C++20)_
>Create `std::array` from C-array. 
>```cpp
>auto a1 = std::to_array("foo"); // size() == 4 since also contain null-terminator
>auto a2 = std::to_array({0, 2, 1, 3});
>auto a3 = std::to_array<long>({0, 1, 3});
>```


## std::list 
The C++ Standard Library `std::list` is implementation of double-linked lists. 

In a double-linked list each node has a link to the previous node as well as to the next node. Memory stored not contiguous. A double-linked list can be easily traversed backwards and forwards by the following the pointers in each node. 
Inserting and removing elements done via changing corresponding `next`/`prev` pointers.
```mermaid
---
config:
  look: classic
  theme: dark
---
flowchart 
    subgraph N1["Node 1"]
        P1["prev: nullptr"]; D1["data: 10"]; N1n["next →"]
    end

    subgraph N2["Node 2"]
        P2["prev ←"]; D2["data: 20"]; N2n["next →"]
    end

    subgraph N3["Node 3"]
        P3["prev ←"];D3["data: 30"]; N3n["next: nullptr"]
    end

    N1n --> D2
    N2n --> D3
    P2 -.-> D1
    P3 -.-> D2

```

List of some Pros and Cons:
* Adding or removing elements from the middle of a list is faster than for `std::vector`
* List are useful where we expected to add or remove a lot of elements frequently. 
* List don't support indexing or subscript notation, it doesn't support random access. 
* Accessing an element is slower than for `std::vector`
* List use more memory to store an element than `std::vector`.

### Member functions 
>[!code-ref] `{cpp} .push_back()` / `{cpp}.push_front()`
> Add element to the end/beginning of container. 

>[!code-ref] `{cpp}void/std::size_t .remove(const T& value)`, `{cpp}void/std::size_t .remove_if(UnaryPred p)`
> Remove elements equal to given `value` or satisfy unary predicate `p`.
> Since C++20 return number of elements removed. 
> 
> Compare to generic `std::remove` actually remove elements, not moving them to end. 
> 
> Complexity: $O(N)$

>[!code-ref] `{cpp} void .sort(Compare comp = operator<)`
> Sort the elements in order based on `comp` operator. 
> 
> Generic `std::sort()` will not work with `std::list` since it's require Random Access Iterators. For sorting only available member function. 
> 
> Complexity $O(N* logN)$

>`.reverse`
> Reverse the order of the elements 

>`.unique()`
>Deletes duplicate elements from the list

>`.merge(std::list& other)` 
> Remove elements from the argument list and perform stable merge them into `this` list. 
> 
> Method expect *sorted* lists. If one of container is not sorted - *UB*. 

> `.splice()`
> Moves elements from another list or one element into a list.
> 
> All elements from another list will be inserted before given iterator. 

## std::forward_list
`std::forward_list` is non-contiguous sequential container representing one-directional list implementation. 

```mermaid
---
config:
  look: classic
  theme: dark
---
flowchart 
    subgraph N1["Node 1"]
        D1["data: 10"]; N1n["next →"]
    end

    subgraph N2["Node 2"]
        D2["data: 20"]; N2n["next →"]
    end

    subgraph N3["Node 3"]
        D3["data: 30"]; N3n["next: nullptr"]
    end

    N1n --> D2
    N2n --> D3
```
In a list, each element has its own memory allocation "node", each node contains data and pointer to next node. To iterate through a list, we start with the first node, get its link pointer and go to the address in that link pointer, which is location of the second node. To add element required to create a node for it, make the link from the node before point to the new node, then make the new node's link point to the node after. Removing an element require to make the previous node link point to the next node. 

`std::forward_list` doesn't have `{cpp}insert()` or `{cpp}erase()` member functions, instead used `{cpp}insert_after()` and `{cpp}erase_after()`. 

Also instead `{cpp}.splice()` from `std::list`  `std::forward_list` implements `{cpp} .splice_after()` member functions. It's work similarly, but elements are spliced in after the iterator argument instead of before it. 