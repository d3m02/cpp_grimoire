## Constructors
Constructors are special member functions of a class; they are called automatically when an object of the class is created. Compilers can generate a constructor if the class doesn't have one explicitly defined. Constructors are used to initialize data members and perform any necessary setup.  
If we don't explicitly initialize a class's members, they will be default-initialized. If the member is an object of another class, its default constructor will be called. If the member is of a built-in type, its initial value is undefined.

Beside initializing class members in constructor from C++11 we can initialize them in the class definition 
```c++
class A {
	int num{2}; // initialization in  class definition
	int secondNum;
public:
	A(int in) : secondNum{num * in} {}; // Init in constructor
}
```
> It's not recommended to initialize class member in constructor body since in that case member will be firstly default-initialized and then reassigned. Members order in initialization list recommended to keep in the same order as they definition in class since in that order they will be initialized, init-list can't change that order

 C++ allow to have multiple constructors. Common practice is perform all set-up in some separate function (`init()`/`setup()` etc) and call that function from constructors to reduce amount of duplication of code, in addition if something changed this approach can reduce amount of changes in constructors themselves. 
 ```c++
class Board{
public: 
	Board() { init("guest", "guest");}
	Board(int id) : m_id{id} 
	{
		init ("guest", "guest");
	}
	Board(const std::string& login, 
	      const std::string& pw)
	{ 
		init(login, pw);
	}
	Board(int id, 
	      const std::string& login, 
	      const std::string& pw) : m_id{id} 
	{ 
		init(login, pw);
	}
	
private:
	void init(const std::string& id, const std::string& pw){
		internet.connect();
	    internet.login(id, pw);
	} 

	int m_id{};
}
 ```
From C++11 it's also possible to use constructor in another constructor, it's called "delegating constructor". 
```c++
class Board{
public: 
	Board() : Board({}, "guest", "guest") {}
	Board(int id) : Board(id, "guest", "guest") {}
	Board(const std::string& login, 
	      const std::string& pw) : Board({}, login, pw) {}
	Board(int id, 
	      const std::string& login, 
	      const std::string& pw) : m_id{id} 
	{ 
		internet.connect();
	    internet.login(id, pw);
	}
	
private:
	int m_id{};
}
```

## Copy Constructor 
Copy constructor is a specialized version of the constructor which takes as argument a reference to an object of the same class and uses existing object of the class to initialize the new object. The copy constructor is automatically called: 
* When initialize a new object from an existing object (even when call `{cpp} Test test2 = test1;` - since `test2` is new object - instead `operator=` will be called Copy Constructor. But it doesn't mean that by defining copy constructor - we also change `operator=` - it's different function) 
* When object passed as an argument by value 
* When return from object a local variable by value 
However, compilers can apply RVO/copy elision as optimization to reduce amount of copying (from C++17 copy elision is guarantied is serval cases)

## Assignment Operator 
The assignment operator is a member function `operator=(const T&)`. It's invoked when when assign two object of the class: `y = z` will call `{cpp} y.operator=(z)`. After this statement, the members of `y` will have the same values as those of `z`. The assignment operator takes its argument by const reference and return modified object, usually _non-const_ reference to (`*this`). Main reason why operator return object is to support similar to build-in types chaining (`a = b = c`, firstly will be called `b.operator=(c)` and after `a.operator=(b)`), _non-const_ required for STL containers (again, to maintain similarity with build-in types). 

Assignment operator can be synthesized by compiler, in general synthesized operator will call assignment operator of all the data members. In general we might have to write own assignment operator if require some special work with resources, perform deep copy or avoid modification of some data members (like pointer to allocated memory of descriptor, created in constructor).   


## Shallow and Deep Copying 
Default generated by compiler copy special member function perform copy of class data members, which also appliable for pointers. If for example we have as data member pointer to some memory on heap, special member function will copy only pointer, which mean that two different object will point to one blob of memory. This  called "shallow" copy. Danger of such copy is that if one object remove data by pointer - another object can perform actions on already released memory. To avoid this required to create on copy member functions, which will allocate for second object own blob of memory and copy data from first's object blob of memory (this is called deep copying).

Main things to pay attention - me should ensure that we have enough space to store copied data, release current data, also worth it to check for self-assignment. 
```c++
String& operator=(const String& other) {
	if (&arg == this)
		return *this;
	
	delete[] data; // relase original memory
	data = new char[other.size];
	size = other.size;
	for (int i = 0; i < size; i++)
		data[i] = arg.data[i];
	
	retur *this;
} 
```
> This example have drawbacks. For example, if `new` throw exception - we already removed `data`, meaning that our class might be invalid (at least contain incorrect size). Take a look on [[Chapter 2 - Constructors, Destructors, and Assignment Operators#Item 11 Handle assignment to self in operator=|Item 11 from Effective C++]] 

There is "Rule of Three" which helps to determine when some special member functions need to be implemented.
_If a class needs to implement one of 
* _Copy constructor_
* _Assignment Operator_
* _Destructor_
_Then it probably need to implement the other two as well._
e.g class with pointer member allocated with `new` in constructor and release by `delete` in destructor - copy constructor is needed to perform deep copy when copying and assignment operator is needed to perform deep copy on assignment

## Copy elision 
Copy elision means that the compiler is allowed to skip over a call to the copy constructor in some cases and initialize the target object directly. This usually occurs when copying temporary variables during functions calls; either copying temporary variables into function arguments, or copying temporary variable into the function's return value. 
Usually compiler optimization not changing behavior as if optimization wasn't performed, but for copy elision allowed to change the behavior and might have side effects.

In this example expected two copies - one when return temporary object by value, and second when performing assign construction. In fact, first copy in return space will be elided (this's also known as "Return Value Optimization") and second copy will be elided as well.
```c++
sturct Test {
	Test(){ std::cout << "Default c_tor\n"; };
	Test(const Test& other) }{ std::cout << "Copy c_tor\n"; };
};

Test func() { return Test(); } // create temporary object
Test test = func();
// output will be "Default c_tor"
```

Return Value Optimization is when copy of a returned temporary object is elided, meaning that object instead initialized in return space instead. Also exist "Named Return Value Optimization" - a similar process but for local variables return by value. 

## Conversion Operator 
A class can define a conversion operator - member function which converts an object to some other type. For example the conversion operator below will be called whenever the object is used when an int is expected 
```c++
class Test {
	int i{};
public:
	operator int() const { return i; }
}; 
```
This used for implicit conversion. For example, if class don't have `{cpp} operator<<()` but have `{cpp} operator int()` - compiler as fallback will use provided to int for `{cpp} std::cout << test_obj` since compiler known how to print int values. 
> But this have downsides - when defined two conversion operator (for example, for `int` and `float`) and we use class where both types are supported (like `std::cout`) - for compiler this will be ambiguous.

Implicit conversion are often surprising, with undesirable results. 
For example, valid code from older versions of C++ (before C++11)
```c++
int i = 99;
std::ci << i;
```
`std::cin` have `operator bool()` conversation which check is used stream good. Compiler don't find `opartor<<` overload, but find conversion to bool and convert `std::cin` to `bool`. Then compiler see `<<` as left shift bit shift operator, converts `bool` to `int`, make 99 left shifts and discard result. 

In C++11 introduced `explicit` keyword. This prevent implicit conversion and conversion will only happen if it was ask for it (using casts). Exception only for `{cpp} explicit operator bool()` - beside casts, conversion performed in conditions (like `{cpp} if (test_obj)`). 

A constructor with a argument might also perform implicit conversion operator. If it's undesirable - `explicit` should be used. 
```c++
struct Test {
    int m_i{};
    Test (int i, char c = 'c') : m_i{i} {};
};
std::cout << Test(5.2).i;
```
> This also can be avoided using `{}` initialization: `Test{5.2}.i` will not compile

## Operators and Overloading 
C++ defines 3 types of operators:
* Unary operators - operators which takes a single argument 
* Binary operators - operators which takes two arguments
* Ternary operator - conditional operator `?:`

Operators takes either one or two arguments, can be member function or non-member functions (which in most cases define will operator be unary or binary).

C++ allows to write own operators implementation , which is called "overloading" the operators. We can only use the symbols which are supplied for built-in operators and use syntax, provide similar semantics to built-in operators. 

Overloaded operators (but not the built-in operators) can be called using function notation:
```c++
std::string str = "Hello, ";
str.operator+=("world");  // same as str += "world";
operator<<(operator<<(std::cout, str), '\n'); // same as std::cout << str << '\n';
```

Restrictions: 
* Built-in logical AND and OR (`operator&&` and `operator||`) have a guaranteed order of execution (from left to right) and can "short-circuit" (when rest execution not necessary, like `a && b && c`, if `Aa && b` return false - no need to check `&& c`) Overloading of those operators can't provide such behavior. 
* The `operator::` (scope resolution), `operator.*` (member access), `operator.` (member access through pointer to member), and `operator?:` (ternary conditional) cannot be overloaded.
* `operator&` and `operator,` already defined for classes and redefinition will cause confusion
> From cppref: If the unary `&` is applied to an lvalue of incomplete type and the complete type declares an overloaded `operator&`, it is unspecified whether the operator has the built-in meaning or the operator function is called. It's mostly case for forward declaration

### Note from cppreference 
There are other restrictions as well: 
* New operators such as `operator**`, `operator<>`, or `operator&|` cannot be created.
* The overload of `operator->` must either return a raw pointer, or return an object (by reference or by value) for which operator is in turn overloaded.
* An operator function must have at least one function parameter or implicit object parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration. 
Literally this mean that for built-in types overloading not allowed (like `{cpp} int operator+(int a, int b)`. "_or implicit object parameter_" - meaning that classes member-unary operators overloading allowed (since they will have hidden `this` parameter). 
* It is not possible to change the precedence, grouping, or number of operands of operators. 

## Keyword `friend` 
`friend` keyword allows to make an exception in access to class private members. 
Normally a non-member function can only access a class's public members, however class can declare a non-member function to be a "friend", which "grants" access to all class's members 
```c++
class Test { 
	int m_i {};
public: 
	friend void print(const Test&);
};

void print (const Test& test) {
	std::cout << "i = " << test.m_i << '\n';
}
```
> Which now looks closer to what compiler actually do with member functions ([[0. Review of C++#Class functions in global scope]]), from some perspective, it's equal to explicit defining member functions with hidden `this`.

We also can declare another class access to be a friend, this gives all the member function of friend-class access to class members.
```c++
class Test {
    int m_i {};
    friend class Example; 
};

class Example {
public:
	void print (const Test& test) {
		std::cout << "i = " << test.m_i << '\n';
	}
};

Test test;
Example example;
example.print(test);
// Fun fact - example also work if write 
// Example {}.print({});
```

To avoid using friend, we can create a member function which implements the functionality of the operator. This member function has direct access to all members, the non-member function then calls this member function. 
```c++
class Test { 
	int m_i {};
public: 
	void print() const { 
		std::cout << "i = " << test.m_i << '\n';
	}
};

void print (const Test& test) {
	test.print();
}
```
### Small research with Gemini
Defining friend member function without class object as argument is almost meaningless, except cases when only required to get access to class private static members.
```c++
class Test { 
	static int s_counter;
public: 
	friend void print();
};

int Test::s_counter{5};

void print () {
	std::cout << "counter = " << Test::s_counter << '\n';
}
```


## Member and Non-member Operators
"if you can, you should implement as a member functions, this will provide direct access to the private data, we don't need any friends or delegate member functions. And also, it keeps all the code that is related to the class together in the class definition" 
> Objection: [[Chapter 4 - Design and Declarations#Item 23 Prefer non-member non-friend functions to member functions.|Item 23 from Effective C++: prefer non-member non-friend functions to member functions]]

Binary _member_ operators don't work in some cases if we need a type conversion.
> Here can be confusion, even though operator looks like unary, it's actually have hidden second argument to `this`. 
```c++
struct String{ 
	String(const std::string& arg) : m_str{arg} { }
	String operator+(const String& arg) { return m_str + arg.m_str;}
    std::string m_str{};
};

int main(){
    String w {"world"};
    String we = w + std::string{" end\n"};
    String hw = std::string{"Hello "} + w; // error - can't find in std::string class member-operator overload for struct String 
}
```

Non-member function solve this problem, compiler will use this function if will be able to convert input to arguments type
```c++
String operator+(const String& lhs, const String& rhs) { 
	return lhs.m_str + rhs.m_str;
}
```

Operators which change the state of the object are best implemented as member functions (`operator+=`, `operator++` and similar) or operators which are closely related to member type (like dereference `operator*`). Some operators can be only defined as member functions - assignment `operator=`, subscript `operator[]`, function call `operator()`, arrow `operator->`

> Some recommendations and examples also exist in [[Chapter 4 - Design and Declarations#Item 24 Declare non-member functions when type conversions should apply to all parameters.|Effective C++ Item 24]] 


## ## Binary arithmetic operators 
One on approach how to implement for our class arithmetic operators is define non-member overload for `operator+` which will call member overload `operator+=`. In this case we need to maintain only one function, (`operator+=`), we don't need to define any friends for that, compiler will be able to use implicit conversions - overall we will complain with built-in types behavior.  
```c++
class OInt {
public:
	OInt (int i) : m_val {i} {};
	OInt& operator+=(const OInt& rhs) {
		m_i += rhs.m_val;
		return *this;
	}
private:
	int m_val{};
};

OInt operator+(const OInt& lhs, const OInt& rhs) {
	OInt tmp{lhs};
	tmp += rhs;
	return tmp;
	// or 
	return OInt{lhs} += rhs;
} 
```

> More advance technic suggested by gemini:
```c++
// concept checks that operator+= exists and result type correct
template <typename LhsT, typename RhsT>
concept Addable = requires(LhsT a, const RhsT& b) {
    { LhsT(a) += b } -> std::same_as<LhsT&>; 
};

// if constrains met - generate such operator overload for any supported class 
template <typename LhsT, typename RhsT>
requires Addable<LhsT, RhsT>
LhsT operator+(const LhsT& lhs, const RhsT& rhs) {
    return LhsT(lhs) += rhs; 
}
```



## Comparison operators
* Equality and inequality operators 
```c++
bool operator==(const OInt& lhs, const OInt& rhs){
	return lhs.m_val == rhs.m_val
}
bool operator!=(const OInt& lhs, const OInt& rhs){
	return !(lhs == rhs);
}
```

Less-than operator quite important since it's used actively used in STL sort functions and for some containers' insertion functions. 
The `operator<` is sufficient to perform all comparison operations:
* `a <= b`: `!(b < a)`
* `a >= b`: `!(a < b)`
* `a > b`: `(b < a)`
and even equality, although it's not typical
* `a == b`: `!(a < b) && !(b < a)`
* `a != b`: `(a < b) || (b < a)`

```c++
bool operator<(const OInt& lhs, const OInt& rhs){
	return lhs.m_val < rhs.m_val;
}

inline bool operator>(const OInt& lhs, const OInt& rhs) { 
	return rhs < lhs; 
}
inline bool operator<=(const OInt& lhs, const OInt& rhs) { 
	return !(lhs > rhs); 
}
inline bool operator>=(const OInt& lhs, const OInt& rhs) { 
	return !(lhs < rhs); 
}
```
### Note from cppreference:
Also possible implementation is to provide implementation for three-way comparison (similarly to `std::memcmp` or `std::string::compare` or C++20 `operator<=>`) and implement 
```c++
bool operator==(const X& lhs, const X& rhs) { return cmp(lhs, rhs) == 0; }
bool operator!=(const X& lhs, const X& rhs) { return cmp(lhs, rhs) != 0; }
bool operator< (const X& lhs, const X& rhs) { return cmp(lhs, rhs) <  0; }
bool operator> (const X& lhs, const X& rhs) { return cmp(lhs, rhs) >  0; }
bool operator<=(const X& lhs, const X& rhs) { return cmp(lhs, rhs) <= 0; }
bool operator>=(const X& lhs, const X& rhs) { return cmp(lhs, rhs) >= 0; }
```


## Prefix and postfix operators
Prefix (`--i`/`++i`) and postfix(`i--`/`i++`) operators: postfix `operator+(int)` returns unchanged value (by creating copy in place, equal to `temp = i; i+=1; return temp`). This temporary copy can add additional redundancy, but modern compilers can notice it and remove, when temporary object not used. `int` argument in overload operator signature used to define postfix operator overload.
```c++
OInt& operator++() {
	++m_val;
	return *this;
}
// Note that return is by value, not by reference.
OInt operator++(int) {
	OInt temp(*this);
	++(*this);  // or operator++();
	return temp;
}
```


## Function Call Operator
Procedural programming involves a sequence of commands, organized into functions/procedures that are executed in a specific order to solve a problem. Classical C++ follows procedural programming, but from C++11 become possible to use functional programming.

Functional programming involves a tree of functions calls which transform data. In can be chain on functions calls in which one function takes some data and return data, which can become input data for next function. Functional programming in C++ possible using _callable objects_ using functions pointers.
```c++
void func(int, int);
void (*func_ptr)(int, int) = func;
func_ptr(1, 2);
```

### Functor`
C++ classes can define a function call operator. This allows to make callable objects - the object of this class will be callable objects, but continue behave as data variable. Such classes called "_functor_". 
```c++
struct Divisible {
	Divisible(int d) : divisor{d} {}
	bool operator()(int num) {
		return (num & divisor == 0)
	}
private:
	int divisor{1};
}

void For_each(const std::vector<int>& vec, Divisible is_div) {
	for (const auto& v : vec)
		if (is_div(v))
			std::cout << v << " is divisible\n"l;
}

std::vector numbers{1, 4, 7, 11, 12};
Divisible divisible_by_three{3};
For_each(numbers, divisible_by_three);
```

## Stream operators
Overloading stream operators can allow to print/read data not only from console, but from files etc. 
```c++
class OInt {
public:
	void print(std::ostream& os) const {
		os << "val = " << m_val;
	}
}
std::ostream& operator<<(std::ostream& os, const OInt& oint) {
	oint.print(os);
	return os;
}
```

> List of operators can be find in [[Notes#C++ operators' signatures]]  