 The "traditional" pointers was inherited from C, it's a built-in type, size depends on system architecture, but in most cases is 8 bytes. Pointer variable stores a binary number which represents an address in memory. Pointer can be used to manage memory allocated on the heap (usually for container), can be used to implement polymorphism (create pointer to base class and using virtual functions call to derived class function). 
 
 There are many problems with traditional pointers:
 * No concept of ownership, any code that uses pointer can reassign it, overwrite it or invalidate it
 * No destructor, not indication is memory in use, which mean allocated memory can be released twice, or not at all. It's also no easy to determine when pointer is valid. 
From C++11, traditional pointers are very rarely needed. For working with stack memory can be used references instead pointers; for variable-size container can be used `std::string`, `std::vector` and other containers. And we can use _smart pointers_. 

Smart pointers are classes which encapsulated allocated memory, owning traditional pointer as private member and managing it's releasing. Smart pointer are implement using RAII, the memory is allocated in constructor and destroyed in destructor, smart pointers not allow pointer arithmetic.

There are 3 smart pointers in C++ (not including `std::auto_ptr`, since it's deprecated in C++11 and removed in C++17)
+ `std::unique_ptr` - lightweight move-only smart pointer, with `std::unique_ptr` it's possible to transfer memory allocation with `{cpp}std::move()` explicitly.
+ `std::shared_ptr` - smart pointer which allows to share its memory allocation with other `std::shared_ptr`/`std::weak_ptr` using reference counting. Similar to a garbage-collected object in other languages. 
+ `std::weak_ptr` - smart pointer which allows to hold memory allocated by `std::shared_ptr` without increasing reference counting, which allows to avoid reference cyclic. It's used when required temporary access to already existing resource.    

For `std::unique_ptr` and `std::shared_ptr` if assign to nullptr - original object will be destroyed.  
## Unique pointer 
>[!code-ref] `<memory>`
>```cpp
>template<class T, class Deleter = std::default_delete<T>>
>class std::unique_ptr;
>```

In most situations, `std::unique_ptr` is the best replacement for traditional pointers which manage heap memory. Heap memory allocated in its constructor and has sole ownership of it, automatically releases the memory when it goes out of scope. This allows heap-allocated memory to be used like a stack object. The pointer to the memory cannot be overwritten or invalidated, no issues with "shallow copying" (when copied address to data instead data) since it's move-only class.`std::unique_ptr` is quite lightweight with minimum overhead than a traditional pointer. 

`std::unique_ptr` can be used for both single object and array of objects.  For example, `{cpp}std::unique_ptr<int[]> p{new int[6]` - strange trick to create fixed-size memory in heap. Usually for arrays used `std::array`, but's allocated memory in stack, while `std::vector` is not fixed size. 

In C++14 introduced `{cpp}std::make_unique()` function which calls `{cpp}new` internally, uses perfect forwarding it's argument to the constructor and from some point help to create more compact code. 
`{cpp} auto p {std::make_unique<int[]>(6)};`
> Using make function much preferred due to drawbacks with explicit call `{cpp}new`, [[Chapter 4 - Smart Pointers#Item 21 Prefer `std make_unique` and `std make_shared` to direct use of `new`.|More details in Item 21 from Effective Modern C++]]

There small difference between single-object `std::unique_ptr` and array-object:
```cpp
auto pInt {std::make_unique<int>(42)}; // create int* and initialize with 42
auto pArr {std::make_unique<int[]>(6)}; // create 6 int with default initialization

*pInt;                                          // Single object can be dereferenced, array - not
pArr[1]                                         // Array can be indexed, single - no
std::unique_ptr<int> pInt2 {std::move(pInt)};   // Can be moved only to single object 
// std::unique_ptr<int> pArr2 {std::move(pArr)} // Error, incompatible types.
```

`std::unique_ptr` can be used with function, it can be used as argument (but object should be moved in it) or function can return `std::unique_ptr` (already `rvalue` and will always be moved to variable)
```cpp
std::unique_ptr<Point> point_ptr (int x, int y) {
	Point* p = new Point(x, y);
	p.normalize(); // it's just for reference, normally 
	               // it's better to create smart pointer and then call for functions.
	               // Plus from design point "normilize" can be part of constructor instead. 
	               // Here example when something additional required with pointer.
	return std::make_unique<Point>(*p)};
}

auto ptr {point_ptr(3, 6)};

void func1 (std::unique_ptr<Point> point);
func1(std::move(ptr)); // cast to rvalue. 
```

`std::unique_ptr` allows to write polymorphic code. We can use similarly base class and initialize pointer with derived to use dynamic binding. We also can use `std::unique_ptr` in STL containers (like `std::vector`).
```cpp
std::unique_ptr<Base> pBase {std::make_unique<Derived>()};
// equal to Base* pBase = new Derived();
using tBase = std::unique_ptr<Base>;
std::vector<tBase> shapes;
shapes.emplace_back(std::make_unique<Circle>());
```

In this case we get all advantages of smart pointers - `pBase` can't be accidentally reseated, overwritten or invalidated, pointer arithmetic disabled, automatically deleted on an exception or leaved scope, can't be used after deletion. 

This also allow to implement safe _Factory pattern_. In this pattern function call create a new object and return a pointer to that object. Created object type usually depends on argument. This pattern is useful when working with class hierarchies: function create a child class object and return it through pointer to base class. 
Advantages are: 
+ All the code to create object in the hierarchy in a single place, in a factory function
+ Flexibility - we pass arguments to choose which child class type to create.
+ Easy top extent if new child classes are added. 

With `std::unique_ptr` we can avoid unexpected memory leaks, safely transfer ownership to factory function caller and lifetime will be depends on scope of function caller. 
```cpp
std::unique_ptr<Shape> createShape(const int sides) {
	switch(sides) {
		case 1: return std::make_unique<Circle>();
		case 3: return std::make_unqiue<Triangle>();
		case 4: return std::make_unique<Square>();
		default:
			std::cout << "Incorrect argument value\n";
	}
	return nullptr;
}
// Or we can use map, but map create some redundancy, but it's usefull with dynamic amout of derived classes
std::unique_ptr<Shape> createShape(const int sides) {
    using creatorT = std::function<std::unique_ptr<Shape>()>;
    static const std::unordered_map<int, creatorT> creators = {
        {1, []{ return std::make_unique<Circle>(); }},
        {3, []{ return std::make_unique<Triangle>(); }},
        {4, []{ return std::make_unique<Square>(); }}
    };
    
    
    if (auto it = creators.find(sides); it != creators.end())
        return it->second();
    
    std::cout << "Incorrect argument value\n";
    return nullptr;
}

auto pShape {createShapte(3)};
```

`std::unique_ptr` can take in constructor traditional pointer, no just one which represents allocated memory. Eventhogh, we can use `std::unique_ptr` as a generic class for managing resources. However, `std::unique_ptr`'s destructor calls `{cpp}delete` which will be disastrous if the pointer wasn't return by `{cpp}new`. 

We can provide a _deleter_ - callable object which will be invoked instead `{cpp}delete`, the managed pointer is passed to the deleter. 
Deleter is a part of `std::unique_ptr` template type. Since for template instantiation we need to provide type, which might be unknown for us (when using lambda for example), we can used `{cpp}decltype()` to get the type. 
```cpp
// Some C API
struct destination {};
struct connection {};

connection connect (destination dest) {
	...
	connection conn;
	return conn;
}
void disconnect(connection conn) {
	...
}

auto end_connection = [](connection* conn) { disconnect(*conn); };

auto conn {connect(dest)};
std::unique_ptr<connection, decltype(end_connection)> p(&conn, end_connection);
```

> [!note] Using functors can to make code more readable 
> ```cpp
> struct ConnectionDeleter {
> 	void operator()(connection* c) const {
> 		disconnect(*c);
> 	}
>};
>std::unique_ptr<connection, ConnectionDeleter> p(&conn);
>``` 

## pImpl 
One of application for smart pointers is _Pointer to implementation_, or _pImpl_ idiom. 

When we writing an object oriented code, we aim to separate the interface from implementation. In this case clients don't need to known inner details of the class and clients don't need to modify their code if the implementation changes, unless interface is stable. Typically in C++ we put the class definition in a header files and the member function definition in a source file, with `public`, `private`, `protected` specifiers restrict control access to the implementation. However, some implementation details are still visible to clients (names of private data members, prototypes of private/protected member function, definitions of inline member functions, used types which require either include corresponding header or use forward declaration). All clients which use the class must include the header file and any changes in header will force a recompile of all clients. 

To solve this problem can be applied the *handle-body* pattern. We split the class into two parts:
+ _handle_ part - outer class that  provides the interface to clients 
+ _body_ part - inner class that proved implementation. 
When clients creates a Handle object - the Handle creates a Body object. Clients calls a member function on the Handle object, which inside the Handle forwarded to the Body.

The pImpl idiom is one of popular way tom implement the Handle-Body pattern. The Handle has a private member which is a pointer to a Body object. To use `std::unique_ptr` we have to add to Handler destructor to make it "complete type". Since we declare a destructor, compiler will not synthesize move operators and we have to proved them it's needed. And compiler will not synthesize copy operators (although, `std::unique_ptr` member can't be copied). 

```cpp title:Date_impl.h
class Date_impl {
public:
	Date_impl(int day, int month, int year) : m_day{day}, m_month{month}, m_year{year} {}
	void setDay(int day);
	void print(); 
private:
	int m_day;
	int m_month;
	int m_year;
};
```

```cpp title:Date.h
#include <memory>

class Date_impl;   // Forward declaration
	
class Date {
public:
	Date(int day, int month, int year);
	~Date();
	Date(Date&&) noexcept;
	Date& operator=(Date&&) noexcept;

	void setDay(int day);
	void print();
private:
	std::unique_ptr<Date_impl> pImpl;
};
```

```cpp title:Date.cpp
#include "Date_impl.h"
#include "Date.h"

Date::~Date() = default;
Date::Date(Date&&) noexcept = default;
Date& Date::operator=(Date&&) noexcept = default;

Date::Date(int day, int month, int year)
	: pImpl {std::make_unique<Date_impl>(day, month, year)}
{}

void Date::setDay(int day) {
	pImpl->setDay(day);
}

void Date::print() {
	pImpl->print();
}

```

Pimpl used when required to reduce compilation time in large projects, make updates simpler. 

This idiom have following disadvantages:
- Require an extra memory allocation for the Body object
- Member function calls require a pointer dereference 
- Loading a shared library increases the program's start-up
- Adds complexity to the codebase
- Adding new function to Impl class might require adding to Handler class, which can be easily missed.  

> See also [[Chapter 4 - Smart Pointers#Item 22 When using the Pimpl idiom, define special member functions in the implementation file.| Item 22 from Effective Modern C++]], it also have example of pImpl without separate header file for Impl. 

## Shared pointers
Reference counting as a technique in which an integer used to store number of objects which are share the resource. When counter when to 0 - object is destroyed. When an objected is bound to a resource, counter incremented, when unbound - counter is decremented. As result, last resource unbounding destroy an object.  

`std::shared_ptr` is a smart pointer which uses reference counting. This allow to share once allocated memory when `std::shared_ptr` copied or assigned.  `std::shared_ptr` has a private data member which is a pointer to the allocated memory and private member which is a pointer to its _control block_, which contains the reference counter. 
To create `std::shared_ptr` pointer can be passed to constructor, also can be used `{cpp}std::make_shared()`, we can move `std::unique_ptr` into `std::shared_ptr` (not not in another way). 

`{cpp}std::make_shared()` allows to perform a single allocation for the shared memory and the control block, while allocating with `{cpp}new` will have extra `{cpp}new` call. This also mean that allocated memory can be in different places (which can affect a little bit performance). 

Moving `std::shared_ptr` doesn't change reference counter and new object is stealing the memory allocation and control block. 

Control block in `std::shared_ptr` is atomic to prevent from data race when different threads copy or assign `std::shared_ptr` object with same control block. However, access to the allocated memory must be protected by the programmer. In C++20 introduced support if `std::atomic<std::shared_ptr>>` (and also from C++20 some member function deprecated due to inefficiency when working with multiple threads).

`std::shared_ptr` comes with overhead which in most cases not required. Thus, `std::unique_ptr` should be choice for most cases and `std::shared_ptr` when different objects need to have access to the same area of heap memory. 

## Weak pointer 
`std::weak_ptr` not really a smart pointer, it's provides a safe way of aliasing a `std::shared_ptr`. 
A `std::weak_ptr` is bound to a `std::shared_ptr` object, it's require existing object and  doesn't affect the reference count. `std::weak_ptr` cannot access the shared memory directly, it has to be converted back to `std::shared_ptr`, which allowed only if original `std::shared_ptr` is still valid. 

To convert from weak to shared pointer used member function `{cpp}lock()`, which returns the `std::shared_ptr` if it's valid, otherwise returns `nullptr`. Alternatively, we can copy `std::weak_ptr` into a `std::shared_ptr`, if shared pointer is invalid - `std::bad_weak_ptr` will be thrown. 

`std::weak_ptr` can be also used to check - is `std::shared_ptr` valid or not. 
```cpp
void check(std::vector<std::shared_ptr<int>> vec) {
	for (std::weak_ptr<int> p : vec) 
	{
		auto ptr = p.lock();
		if (!ptr)
			// deleted element	
	}
}
```

With `std::shared_ptr` it's possible to create cyclic references. It's a situation when two different objects has pointer to each other. 
```cpp
struct A {
	std::shared_ptr<B> ptr;
	void set_ptr(const std::shared_ptr<B> bObj) { ptr = bObj; }
}
Struct B {
	std::shared_ptr<A> ptr;
	B(const std::shared_ptr<A>& aObj) : ptr{aObj} {}
}
std::shared_ptr<A> aObj = std::make_shared<A>();
std::shared_ptr<B> bObj = std::make_shared<B>();

A->set_ptr(bObj); 
```
In this case reference counter will never equal 0, meaning that destructors of the objects are never called. 
Solution is to replace one of `std::shared_ptr` with `std::weak_ptr`. 

