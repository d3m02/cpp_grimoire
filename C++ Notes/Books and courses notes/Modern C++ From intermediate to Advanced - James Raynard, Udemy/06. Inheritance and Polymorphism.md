Programmers often work with entities which are related or represent similar concepts
 * Graphical shapes all have position on the screen, can be drawn, filled, rotated, etc

To express such relations can be used a class hierarchy. 
The class at the top of the hierarchy represents the most general or the most basic version. This is known as the "base class".

The base class is the most generic or basic version. The classes which come below this are known as derived/child. These are more specialized versions of the base class, or enhanced versions with more features. And also it's possible to derived from derived class. 

The relationship between classes at different levels in the hierarchy is called "inheritance". 
Inheritance models an "is-a" or "is-a-kind-of" relationship between classes
  * A Circle is a Shape

## Derived class
To define a derived class, we put `:` after its name, followed by the `public` keyword and the name of the base class 
```cpp
class Vehicle {
public:
   int m_maxSpeed{};
};

class Aeroplane : public Vehicle { 
public:
   int m_maxHeight{};
};
```
The derived class is able to call non-private (public and protected) member functions of the base class, can access any non-private data members. 
   * `public` class members are available everyone
   * `protected` class members are available to child classes (and `friend`)
`protected` also help maintain _encapsulation_


A derived class object is stored in memory as a base class object followed by the derived class part. For example, we have some memory, which is an aeroplane object. The first part of this is going to be the vehicle part of the object, and the rest of it will be the bits that are specific to an aeroplane. 
 ```
 ___ Vehicle ____
[================-----------------]
 ^---        Aeroplane        ---^
```

When a derived class object is created, the base class's constructor is called firest, then the derived class's constructor. Destruction complete in reverse order, first is derived class, then base class. 

From derived class we can manually call base class constructor and pass the arguments to the base class constructor.
```cpp
class Vehicle { 
   Vehicle(int maxSpeed) : m_maxSpeed{maxSpeed} {}
   ..
};

class Aeroplane : public Vehicle {
    Aeroplane (int maxSpeed, int maxHeight) : Vehicle{maxSpeed}, m_maxHeight{maxHeight} {}
};
```

In derived class also possible to _overwrite_ (not override, `override` is appliable to `virtual` methods) the base class member functions. Instead of calling a member function from the base class, in derived class can be defined a member function, which has the same name, and use that instead. 
If required not replace base class member function functionality, but extend - inherited class can call base class non-private member functions
```cpp
class Aeroplane : public Vehicle { 
public:
    void start() {
         // some pre-actions
         Vehicle::start();
         // some post-actions
     }
};
```

It's also possible to _overload_ the base class functions in the inherited class (by using same function name and required arguments list). But if we overload an inherited function in the child class, it will "hide" all the other inherited member functions with that name.
```cpp
class Vehicle { 
   void accelerate() { std::cout << "Vehicle::accelerate()\n"; }
};

class Aeroplane : public Vehicle {
    void accelerate(int height) { std::println("Aeroplane::accelerate({})", height); }
};

Aeroplane plane;
plane.accelerate(1000);
plane.accelerate(); // Error: 'function does not take 0 arguments'
```

From C++11 we can tell the child class to "use" the parent's version by `{cpp}using Vehicle::accelerate;`. This will make all the hidden versions of the function available in the child class (including overloads from the base class).


## Pointers and Inheritance
Usually when we have a pointer, it has a type, and it must be the address of some variable or object, which has the same type. 

A pointer to the basic class can point to any object in the same hierarchy. However, derived class can't point to object of it's base class
Same applies to the references. 
```cpp
Aeroplane aeroplane;
Vehicle* pvehicle = &aeroplane; // OK 

Vehicle vehicle;
Aeroplane* paeroplane = &vehicle; // Error invalid conversion from 'Vehicle*' to 'Aeroplane*'
```

This works because the memory layout of derived class 
```
            ___ Vehicle ____
pvehicle ->[================-----------------]
            ^---        Aeroplane        ---^
```

This brings following behavior when calling member functions: we can call any public member function of the base class using pointer to base class, _this will call base's version of the function_. We cannot call any public member functions of child class, even if base-type pointer is actually pointing to child object. 

One way to get access to derived class public member is to cast it from base class pointer to derived class pointer 
```cpp
std::vector<std::unique_ptr<Vehicle>> vehicles(2);
vehicles.push_back(std::make_unique<Aeroplane>());
vehicles.push_back(std::make_unique<Aeroplane>());

for (const auto& veh : vehicles)
     static_cast<Aeroplane*>(veh.get())->draw();
```

## Virtual Functions.
In example above (`Vehicle* pvehicle = &aeroplane;`) pointer `pvehicle` is declared as a pointer to `Vehicle`, but in the address is `Aeroplane` object type. 
This represent case when *static* type and *dynamic* is different. 
 
*Static type* is the type used in the variable declaration. C++ almost always uses static typing in compiler time, it's give less runtime overhead and better optimization.
*Dynamic type* is the type of the variable in memory. Is only used for a pointer or reference to a base class, the member function is chosen at runtime. 

Dynamic type is used for *virtual* functions and represent C++ *polymorphism*. 

Normally when we call a member function of an object, the compiler will decide which function is called using the static type of the object at compiler time. This is known as _static binding_.
```cpp
Aeroplane aeroplane;
Vehicle& rvehicle = aeroplane;  // Reference to base class, bobund to a Aeroplane objbect
rvehicle.draw();                // Calls Vehicle::draw(rvehicle), 
							    // where signature of member function putted in global space by complier 
							    // is something like Vehicle::draw(Vehicle* this)        
```

For dynamic types, where compiler can't make decision which function call, compiler instead generates some code which is used  to make the decision in runtime. This is known as _dynamic binding_. Dynamic binding occur when a member *virtual* function is called through a pointer or reference to a base class. 

To make a member function virtual, we put the `virtual` keyword before its declaration in the base class. This virtual member function will be inherited in all subclasses (we don't need to write `virtual` again). A child class which reimplements a virtual function is said to _override_ it. 

Virtual functions useful when class object passed as argument. Instead, created for each ppossible child own function overload - we can pass reference to base class and use dynamic binding
```cpp
void draw_obj(const Vehicle& obj)
{
	obj.draw(); // Can also call member function of Aeroplane
}
```

Overloading and overriding looks almost exactly same yet have some significant differences: 
* Overload - Same name, different signature from the perent, uses  static binding, may hide the parent's member functions 
* Override - Same name and signature as the perent, uses dynamic binding, if in the Base classs signature or name changed - instead overriding become declaration. 

In C++11 was added keyword `override` which can be added to the definition of a member function in a child class. 
```cpp
class Vehicle { 
   virtual void draw() const;
};

class Aeroplane : public Vehicle {
    void draw() const override;
};
```
The compiler will check whether this member function overrides a virtual member function in the parent class and give a compiler error if the function doesn't override. 

 In C++11 also added `final` keyword. When class is marked as `final` it forbid from inheriting from that class. But `final` also can be used with functions, in this case `final` forbids to override function. 

Virtual also can (and sometimes should) be used with destructors. When using a pointer/reference to a base class - static binding still be used for non-virtual members. Which mean that if destructor is no virtual, static binding will be used even when we're destroying by pointer to base class a derived class object (which also means a _memory leak_). *Virtual destructor* solve that issue and during destruction - firstly will be called destructor of derived class, and after that destructor of base class. 

Generated by compiler destructor *not virtual*. It's designed in this way by standard based on idea that `virtual` brings some overhead for dynamic dispatch, which not always required. 
In general, if a class has virtual functions, it should have a virtual destructor or if derived class manage some resources or if destruction of base class depends on destruction of child classes. As simple solution to prevent from generating non-virtual destructor is use `{cpp} virtual ~Base() = default;`

Member functions are not in the object, they are implemented as global functions. When they are called, a pointer to the object is passed as an extra argument `this`. 
When the compiler encounters a class which has a virtual member function, it creates and populates a `vtable` and when the compiler sees a call to a virtual member function, it generates some extra code executed at runtime for dynamic binding. The virtual function table is an array of pointer to the addresses of all the member functions of the class which are declared virtual. Each virtual member function is identified by index in that array. When a virtual member function is called, the compiler replaces the name of the function by the corresponding index in the `vtable`. The runtime code will determine the object's dynamic type, locate the `vtable` for that  dynamic type, look up the element in the `vtable`, dereference the function pointer and call it. 
As results, there is some overhead to using virtual member functions. Calling a virtual member functions takes longer than for a non-virtual and also some additional memory allocation required to store `vtable`. 

## Interfaces 
The base class is the interface to the class hierarchy, Its public virtual member functions provide all the functionality that is common to the hierarchy. The derived classes override these functions in a concrete way that is specific to each class. Often, the base class's virtual member functions cannot do anything useful. These member functions can be left empty,  or we can use C++ syntax to indicate that they are not implement here. This helps express the idea of a base class as interface. 

We can make the base class's virtual functions _pure virtual_, which indicate compiler that implementation should be provided by inherited classes
```cpp
class Vehicle { 
   virtual void draw() const = 0;
}; 
```
Classes in which every function is pure virtual called *abstract base classes*, from abstract classes can not be made any object. Derived classes from abstract classes should implement each pure virtual function which they inherit from base class. If derived class doesn't implement some pure virtual functions - that mean that this class inherit not implemented functions and cannot be instantiated. 

If we have a function that takes a base class object by value, and we pass a derived class object to it - this will call base class copy constructor and only base part of derived class will be copied. This is known as _object slicing_. Abstract base classes cannot be passed by value, only pointer or reference possible to use as a function argument, which enforce using of dynamic binding and helps to avoid object slicing. 

## Polymorphism 
Polymorphism come from Greek language and means "many forms". 
In programming, polymorphism means that different types have the same interface. STL container are an example of polymorphism, representing example of _parametric polymorphism_.

The classes in an inheritance hierarchy have the same interface as well, this is known as _subtype polymorphism_. An object of a type can be replaced by an object of its subtype. In places where base class used as argument, we can provide child class object to that function - this is known as _Liskov substitution principle_.

Polymorphism is a very useful programming technique. When we have related types, we can write one set of code which handles all of them and avoid duplicated code. We can add new types without having to write extra code to handle them. However, it still respects the individual properties of aparticularr type. 

| Subtype polymoorphism                                           | Parametric polymoorphism                                                   |
| --------------------------------------------------------------- | -------------------------------------------------------------------------- |
| Run-time overheaad                                              | Compile-time binding<br>No run-time overhead                               |
| May require memory management                                   | No memory allocation                                                       |
| No control over child classes                                   | More control over which types are instantiated<br>(SFINAE, C++20 concepts) |
| Can result in large, unmaintaainable<br>inheritance hierarchies |                                                                            |
Inheritance is often over-used. Many problems are better solved by composition. The trend in C++ is away from subtype polymorphism towards parametric polymorphism. Inheritance still is used when needed and "is-a" relationship. 