In compile-time programming, the compiler executes code at compile-time, the result of the computation is available in the program, meaning no run-time overhead. 
> Sometimes also called _metaprogramming_

Compile-time programming possible in C with pre-processor "macro functions" - `#define`. It's executed before compilation, similarly to `#include`.
C++ inherited it, it's a simple copy and paste with substitution, no type information, doesn't understand C++ system and error-prone
```cpp
#define Max(x, y)((x) > y ? (x) : (y))
Max(++a, b); // replaced with ((++a) > (b) ? (++a) : (b)), a can be incremented twice. 
```

C++ has another "traditional" way for compile-time programming, `template`.  Initially they were intended to support generic programming, like `std::vector` - it's generic part (function etc) independent from type, type is provided as template argument and compiler generate final required for provided type code.  Later discovered templates can provide Turing-complete programming language (meaning that any problem can be solved using templates) - template parameters can represent state variables, recursive instantiation can simulate loops, template specializations to implement control flow , integer operations to calculate results and so on. 

Templates mostly used for compile-time programming, writing generic code to avoid duplication, making decisions at compile time for efficiency and/or portability, for domain-specific programming (e.g. customized language), expressing complex software patterns and concepts, but mainly all that done by library developers (so templates not really bother regular developer).

Mostly uses class templates rather than functions. Metaprogramming makes heavy use of template specialization. C++11 introduced something called _type traits_ which give information about the properties of type (e.g. `{cpp}std::is_arithmetic<T>::value`). 

C++11 also provides `constexpr` - normal-like code which can be executed at compiler time if it's possible. 

## constexpr
A constant expression has a value which is evaluated at compile time, and which cannot be changed. Common examples are literals, a value computed from literals and a value computed from other constant expressions.

A variable can be a constant expression if it's initialized by constant expression and it cannot subsequently be modified. For example,  `{cpp} const int i{42}, j{99];`, also `i + j` can be constant expression since computed from other constant expressions. 
Constant expressions can be used with C-array elements, `{cpp} int arr[i+j]` - valid code, but if remove `const` from initialization `i` and `j` - they still initialized from constant expressions, but they can be modified after initialization, meaning that they no longer constant expressions. In example with `arr`, compilation will be failed (unless `-pendanic` not used). 

`const` keyword used to make variable which cannot be modified after being initialized, either with another constant expression (known at compile time) or from a value which will be known at runtime.
Mainly used for function arguments, compiler will not allow to modify such argument, an const reference arguments are efficient and safe.    

`constexpr` indicates that an variable is a constant expressions. A `constexpr` variables evaluated at compile time, they can't be modified. 
Used for computing the values of constants in compile time.

Functions can be also marked with keyword `constexpr`. In C++11 `constexpr` function has constant expression argument, return a constant expression. Such functions executed at compile time using a compiler-time interpreter (which supports most of C++). `constexpr` functions are useful for performing calculations at compiler time, such calculations are done once during compilation instead of calculating every time the program is run. 

To make `constexpr` functions we put `constexpr` keyword before its return type. A`constexpr` function must be _pure function_ - it can't modify its argument and can't modify global/static variables. `contexpr` functions are implicitly defined as `inline` - can be used in header-only libraries and also multiple definitions allowed. 

 A `constexpr` function can be called with arguments that are not constant expressions. In this case, the return will not be a constant expression and function will be evaluated at runtime, like other functions. This avoids the need to write and otherwise identical functions (for compile-time and run-time executions). 

In C++11, the body of `constexpr` function could only contain a single return statement. 
In C++14 these requirements were relaxed and `constexpr` functions can contain multiple statements, local non-static variable declaration, flow control (`if`, `switch`,`for`). Still, the body of a `constexpr` function can't contain any code which causes an action at runtime (e.g. calling `new`/`delete`, calling virtual functions, throwing exception). 

>[!note] Some other changes in following after C++ standards (claude-generated, checked with gemini) 
>C++17:
> + Lambda expressions can be `constexpr`
> + `constexpr` can be used with `if constexpr` for compile-time branching
>
> C++20:
> + `try-catch` blocks allowed in `constexpr` functions (but exception can't be thrown during constant evaluation)
> + Virtual function calls allowed if the object type is known at compile time
> + `constexpr` destructors
> + `constexpr` dynamic memory allocation (new/delete) allowed with specific constraints
> + `std::vector`, `std::string` and other containers can be used in `constexpr` context
> + `consteval` keyword introduced for immediate functions (must always evaluate at compile time)
> + `constinit` keyword for ensuring compile-time initialization of variables
>
> C++23:
> + `static` and `std::thread_local` variables allowed in `constexpr` functions if they have constant initialization and constant destruction
> + `constexpr` functions can call `non-constexpr` functions during runtime evaluation (they just can't be evaluated at compile-time in such cases)
> + `static constexpr` variables in `constexpr` functions
> + Labels and `goto` statements allowed in `constexpr` functions
> + Expanded standard library `constexpr` support (more algorithms, containers)
>
> C++26:
> + `constexpr` placement new - allows using placement new in constant expressions
> + More relaxed rules for constant expressions in general
> + `constexpr` cast from void* in certain cases
> + Extended standard library `constexpr` coverage (more functions marked as `constexpr`)
> + `constexpr` functions can have uninitialized variables in certain contexts (as long as they're initialized before use during constant evaluation)
> + Reflection facilities that work with `constexpr `(though this is a broader feature)


A member function can be made `constexpr`, in C++11 such member function were also `const`, meaning that they can't modify `this`. In C++14 `constexpr` member functions are allowed to modify `this`, unless they not declared as `constexpr const`. 

`constexpr` class member functions also exists, they initialized from constant expression, can't be modified, but also must be declared `static`, otherwise the data members will not available at compile time. 

## Template classes 
Template classes support pretty much every function that non-template classes do, they can have friends, static members, member function with default argument, can be part of inheritance, can be composed. 

We can also have a templated member functions, _member template_, the class does not have to be templated to have a member template. A member template can't be virtual. One of the examples of member template - generated by compile from generic lambda
```cpp
auto lambda = [](auto x) { retrun x % 2; };
// implemented as 
class functor { 
public:
	template <typename T>
	T operator()(T x) { return x % 2; }
};
```
Type of `T` will be deduced from passed argument, which  will instantiate the member template. 

A member template can have different parameters from the class
```cpp
template<typename T>
class Compare {
	T t1, t2;
public: 
	Compare(const T& t1, const T& t2) : t1{t1}, t2{t2} {}
	template <typename Func>
	bool compare(Func f){ return f(t1, t2); }	
 };
 
 int x{1}, y{2};
 Compare<int> c(x, y); 
 if (c.compare([](int i1, int i2) { return i1 < i2;}))
	 std::cout << "true";
```
Although the parameter for the member template can be different from the template for the class (for example class parameters expected to be comparable, while member template parameter - callable object) , there in fact a coupling between them - they moth subject to constraints. 

In C++20 introduced _concepts_. Concepts allow to express requirements as part of the template definition. This makes clearer code which expresses the programmer's intentions and compiler error will clearly state why the code didn't compile.
```cpp
template<typename T>
concept Comparable = std::totally_ordered<T>;

template<typename Func, typename T>
concept BinaryPredicate = std::invocable<Func, T, T> && 
                          std::convertible_to<std::invoke_result_t<Func, T, T>, bool>;

template<Comparable T>
class Compare {
    T t1, t2;
public: 
    Compare(const T& t1, const T& t2) : t1{t1}, t2{t2} {}
    
    template <typename Func>
        requires BinaryPredicate<Func, T>
    bool compare(Func f) { 
        return f(t1, t2); 
    }
};
```

Templates are generic, when we write a class or function template, we will get the same behavior for every type that we instantiate it with. Sometimes we may wish to have different behavior for some types: if we want to handle some type differently, optimize code for some types. For such purpose we can use `template specialization.` Usually, the specialization follows immediately after the generic template: if the specialization comes before the generic template, if the generic template is not visible -  it will not compile; if the specialization is not visible to code that uses it (so code-user in between generic template and template specialization) - the compiler will instantiate the generic template.

```cpp
// Generic vector class 
template <typename T>
class vector {
...
};

// Specialization of vector class for bool type 
template<>
class vector<bool> {
...
};
```
When a template is instantiated, the compiler has to choose which version to use. It will always chose the most specific alternative which matches. `vector<bool>` is ore specific than `vector<T> with T == bool`.

Template specialization requires a single type per parameter. Occasionally we may want to have a family of types instead of a single type - we can use _partial specialization_. It's only allowed for class and value templates, there are a number of limitations on the arguments.
```cpp
// Generic vector
template <typename T>
class Vector {...};

// Partial specialization for pointer elements 
template <typename T>
class Vector<T*> {...};

// Other examples from claude:

// const variables 
template <typename T> 
class Vector<const T> {}

// arrays 
template <typename T>
class SmartPtr<T[]> {}

// For pairs, when similar types 
template <typename T>
class Pair<T, T> {}

// function types 
template <typename R, typename... Args>
class TypeTraits<R(Args...)> {}

// For specific value 
template <typename T, size_t N>
class Array { T data[N]; };

template <typename T>
class Array<T, 0> { // zero size edge case };

// Pointer to class members 
template <typename T, typename C>
class MemberPtr<T C::*> {} 
```


With template can happen situation called _template bloat_. Let's say we have in some header file template function. We include that header file in n separate source files, but instantiate in all cases with same type. The compiler will instantiate a separate but identical functions in every source file, every object fill contain same binary code for function. The linker will remove the duplicate definition from the executable, but shill be have increased object file, compilation time, memory usage. 
The traditional way to handle this situation is to manually instantiate templates - we put in header only template declaration without the actual body of function and in one of source we provide template definition
```cpp
// manual.h
// Template declaration only
template<typename T>
std::ostream& print(std::ostream& os, const T& t);

// manual1.cpp
#include "manual.h"

void func(const std::string& str) {
	print(std::cout, str); // call template function. Compiler can't instantiate since can't see definition  
}

// manual2.cpp
#include "manual.h"
// Template definition 
template<typename T>
std::ostream& print(std::ostream& os, cont T& t) {
	return os << t;
}

// Manual template instantiation 
template std::ostream& print(std::ostream& os, const std::string& str);
```

However, better solution is mark template with keyword `extern`.
`extern` keyword inherited from C, it turns the definition of an uninitialized variable into a declaration, used to make a global variable accessible across source files: 
`extern int val;` - declared, but not defined  and definition (`int val`) located in some other file. Something similar for templates
```cpp
// header.h
template <typename T>
void func(T);

// Declare that instantiation elsewhere
extern template void func(std::string);

// file1.cpp
func(std::string); // call to template function

// impl.cpp
template void func(std::string); // instantiation here. 
```


## Variadic Templates 
A variadic function is a function that can take any number of arguments. In the declaration of variadic function, the last parameter is parameter pack `...` . 
C++11 introduced variadic template function.
```cpp
template<typename... Args>
void func(Args... args);
```

The compiler will deduce the number of arguments and their type from the function call. 
```cpp
func("hello"s);         // instantiated as func(std::string)
func(42, 0.0, "text"s); // instantiated as func(int, double, std::string)
```

Parameter packs are only available at compile time, we can use `{cpp}sizeof...()` to get the number of elements, `{cpp}std::make_tuple()` to store in an `std::tuple` or iterate over the elements using template recursion. 
```cpp
template<typename.. Args>
void func(Args... args){
	std::cout << "Arguments number " << sizeof(Args) << '\n';
	auto tuple = std::make_tuple(args...);
	std::cout << "First argument " << std::get<0>(tuple) << '\n';
}
```

_Template recursion_ is meaning that we can call template function inside template function 
```cpp
template <typename T, typename U, typename V>
void func(T t, U u, V v) {
	func(u, v); // recursive call
}

template <typename U, typename V>
void func(U u, V v) {
	func(v); // recursive call
}

template <typename V>
void func(V v) {
	// end of recursion
}
```
With variadic pack, we can make such trick - declare variadic template which takes one template argument and variadic pack,  each call removes the first element from the list. To terminate the recursion, we write another template with a single argument before the variadic template.  
```cpp
template<typename T>
void func(T t) {
	// end of recursion
}

template<typename T, typename... Args>
void func(T t, Args... arg) {
	func(args...); // recursive call
}
```
 
 This trick can be improved with `if constexpr` from C++17, in this case we need only one template function
 ```cpp
template<typename T, typename... Args>
void func(T t, Args... arg) {
	if constexpr (sizeof...(args) > 0)
		func(args...);
}
 ```

## Miscellaneous Template Features:
* `{cpp} static_assert()` - compile-time version of `{cpp} assert()`, introduced in C++11. It takes a constant bool expression and a string literal. The bool expression is checked during compilation, if it's false - the compilation stops and the string literal will be used as compiler error message. 

+ _Default template parameters_ - we can write a template class which has default parameters, which will be sued if we don't provide template parameter type
```cpp
template <typname T = int> 
class number {
	T value;      // Value will have default type int
}

// Instantiate with long double
number<long double> high_precision(1.99999);

// Instantiate with int
number<> default_number(2); 
```

 + _Library-defined operator objects_  - C++11 defines some generic operator classes in `<functional>`, e.g. `{cpp} std::less<T>` calls `{cpp}operator<` of `T`. 
They are:
+ _Arithmetic operators_: `std::plus`, `std::minus`,  `std::multiplies`, `std::divides`, `std::modulus`, `std::negate`
+ _Relation operators_: `std::equal_to`,  `std::not_equal_to`,  `std::greater`,  `std::greater_equal`,  `std::less`,  `std::less_equal`
+ _Logical operators_: `std::logical_and`, `std::logical_or`, `std::logical_not`
+ _Bitwise operators_: `std::bit_and`, `std::bit_or`, `std::bit_xor`, `std::bit_not` (C++14)

We can use these operators to write generic functions with default operator. 
```cpp
template<typename T, typename Func = std::less<T>>                 // Func now have default parameter
bool compare(const T& t1, const T& t2, Func func = Func()) {  // When template instantiated withouth func - will be used std::less 
	return func(t1, t2);
}
```

+ `if constexpr`
In C++17 added `if constexpr` which allows conditionals with constant expressions to be evaluated at compile-time. Other branches not appear in source code, meaning that it's similar to directives `#ifdef`/`#if` and can be used for such purposes, but directives is processed by the preprocessor (which doesn't understand anything about C++), `if contexpr` processed by compiler with access to all the compilers internal data, type information etc. 

```cpp
template <typename T>
std::string get_string(const T& arg) {
	// Instantiate code based on type. If remove constexpr - compiler will try to compile both branches
	// with T = std::string - there is no overload of std::to_string(std::string)   
	if constexpr (std::is_same_v<std::string, T>)
		return arg;
	else 
		return std::to_string(arg);
}

// equal to template specialization 
template <typename T>
std::string get_string(const T& arg) {
	return std::to_string(arg);
}

template <>
std::string get_string(const std::string& arg) {
	return arg;
}

// Or using SFINAE (Substituion Failure Is Not An Error)
// default template parameter used to instantiate if the case is true
template <typename T, std::enable_if_t<!std::is_same_v<std::string, T>, int> = 99>
std::string get_string(const T& arg) {
	return std::to_string(arg);
}

template <typename T, std::enable_if_t<std::is_same_v<std::string, T>, int> = 99>
std::string get_string(const std::string& arg) {
	return arg;
}
```

+ `{cpp}decltype()` - C++11 keyword that can be used at compile time to get type of its argument. 
`decltype` doesn't evaluate its argument, it doesn't cause any code to be executed. The compiler will replace `decltype` with the type that argument would return (so `{cpp}decltype(1 + 2 ) y;` equal to `{cpp} int y;`)

```cpp
// with lvalue expression 
decltype(x + y)  // Gives int&
// but in pair of brackets it's become an expression 
decltype((x))    // Gives int&

// with prvalue 
decltype(2)       // int

// wtih xvalue 
decltype(Test())   // Test&&
```

Although it looks similar to `auto`, in fact `auto` makes a variable have the same type as its initializer, dropping `const` and reference; `decltype` will give the type of object or an expression, retaining `const`, reference etc. In C++14 we can use `auto` as the argument, which will makes work like `auto` but retain qualifiers.
```cpp
const int cx;
auto y = cx;      // y is int
decltype(cx) cz;  // cz is const int

const int& a{99};
auto b = a;            // b is int
decltype(auto) c = a;  // c is const int&
```

`decltype` is mainly used in compile-time programming or with C++14' generic lambdas to declare type.
```cpp
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
	return t + u;
}

auto make_vector = [](auto x, std::size_t n) {
	return std::vector<decltype(x)>(n, x);
}
```