Нормальная ситуация, когда вывод адреса одной и той же переменной может быть разный, т.к. срабатывает случайное распределение адресного пространства, которое представляет собой функцию безопасности, чтоб запутывает базовый адрес. В основном это делает для защиты от эксплоита вредоносного ПО в память. 

Так же, в зависимости от архитектуры меняется и размер указателя - размер указателя такой же, как и универсальный регистр процессора.  Архитектура x86 имеет 32-битные (4-байтовые) универсальные регистры, x64 – 64-битные (8-байтовые)

Указатели имеют несколько общих характеристик с массивами. Указатели кодируют местоположение объекта; массивы кодируют местоположение и размер смежных объектов. Из-за этого при малейшей провокации массив превращается в указатель. Разрушенный массив теряет информацию от размере и преобразуется в указатель на первый элемент массива.

Иногда указатель не имеет тип (`void`) - в этом случае нельзя разименовать указатель и использовать арифметику (т.к. не известен размер).

В случае, если необходимо взаимодействовать с необработанной память на уровне байтов - можно использовать указатель std::byte.

Указатели могут иметь специально  значение, nullptr. Указатели неявным образом преобразуются в `bool`: если значение отлично от `nullptr` - то это указатель преобразуется в `true`

Указатель `this` позволяет получить доступ к текущему объекту. Обычно в этом нет необходимости, поскольку это подразумевается при доступе к членам. Но иногда может потребовать устранить неоднозначность, например если объявляется параметр метода, имя которого совпадает с именем переменной-члена.