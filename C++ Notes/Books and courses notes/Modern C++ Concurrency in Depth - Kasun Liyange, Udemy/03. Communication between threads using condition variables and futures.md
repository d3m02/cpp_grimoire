## Conditional variables
`std::condition_variable` is a synchronization primitive used with a `std::mutex` to block one or more threads until another thread both modifies a shared variable (the _condition_) and notifies the `std::condition_variable`.

A condition variable is associated with some event, and one or more threads can wait for that event to happen. If some thread has determined that the event is satisfied, it can then notify one or all threads waiting for that condition variable to wake them up and allow them to continue processing.

After calling the member function `{cpp}void wait(std::unique_lock<std::mutex>& lock, Predicate pred);`, the thread will be blocked until a notification is received from another thread or after _spurious (random) awakenings from the OS_. The predicate `pred` is optional, but this predicate can be used to ignore spurious awakenings - if the predicate is in the `false` state, the thread will fall asleep until the next awakening. Right after `{cpp}wait()` returns, the mutex inside `std::unique_lock` is locked by the calling thread.

Besides `{cpp}wait()`, there also exists `{cpp}wait_for()`, which in addition takes a timeout, and `{cpp}wait_until()`, which takes a time point (similar to `{cpp}std::this_thread::sleep_for()`/`{cpp}std::this_thread::sleep_until()`). Those functions also might have an optional predicate, but the overload with a predicate has a different return value:
- without predicate: functions return one of the values from `std::cv_status`, either `std::cv_status::timeout` or `std::cv_status::no_timeout`.
- with predicate: `bool` with the last predicate result.

The thread that intends to modify the shared variable must acquire `std::mutex` (typically via `std::lock_guard`) before modifying the shared variable and call `{cpp}notify_one()` or `{cpp}notify_all()` after finishing the modification (can be done after releasing the lock).
```cpp
std::mutex m;
std::condition_variable cv;
int currentStop = 0;

void bus() {
    for (int stop = 1; stop <= 3; ++stop) {
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        
        {
            std::lock_guard lg{m};
            currentStop = stop;
            std::println("Bus at stop {}", stop);
        }
        cv.notify_all();
    }
}

void passenger() {
    std::unique_lock ul{m};
    cv.wait(ul, [] { return currentStop == 2; });
    std::println("Passenger exits at stop 2");
}

int main() {
    std::jthread p{passenger};
    std::jthread b{bus};
}
```

## Thread safe queue implementation
> Section more based on book C++ Concurrency in Action, 2nd Edition by A Williams, since looks like author on this course most of example took from that book

`std::queue`, similar to `std::stack`, is not thread-safe; therefore, some adaptation is required. Similar to a [[02. Thread safe access to shared data and locking mechanisms#Thread safe stack implementation.|thread-safe implementation of a stack]], we are going to wrap `std::queue` function calls with locking mechanisms. We also need to adapt the interface to avoid race conditions. Consequently, we need to combine `front()` and `pop()` into a single function call.
The receiving thread often needs to wait for the data. Let’s provide two variants for taking an element from the queue:
1. `{cpp}try_pop()`: Tries to pop the value from the queue but always returns immediately (with an indication of failure) even if there wasn’t a value to retrieve.
2. `{cpp}wait_and_pop()`: Waits until there’s a value to retrieve.
    
For the `{cpp}wait_and_pop()` function, we are going to use a condition variable. If the underlying `std::queue` is empty, the condition variable will block all threads requesting data. We will also add a predicate to ignore random OS thread awakenings (spurious wakeups), since in this function we guarantee that it will return a value. Inside `{cpp}push()`, we will call a notify function on the condition variable.
> Note, I used `std::optional` instead `std::shared_ptr` since 

We could use `notify_all()` without worrying about race conditions, since only one thread will obtain the lock over the mutex. The thread that "wins" the mutex race will check its predicate. If the predicate is `true`, that thread continues execution with the locked mutex; otherwise, it returns to the wait state.

However, with `notify_all()`, _every_ waiting thread will be woken up, and every thread will check the predicate. If 10 threads are waiting on the condition variable, 1 thread will take the value, and the 9 others will find the queue empty and fall back asleep (the "thundering herd" problem). Therefore, it is usually a wiser decision to notify only one thread. `notify_one()` will wake an arbitrary thread, which is functionally equivalent to a random thread locking the shared mutex, but without spending resources on redundant queue size checks in all other threads.

```cpp
template<typename T>
class threadsafe_queue
{
    mutable std::mutex m_mutex; // 'mutable' allows locking in const member functions (like copy ctor)
    std::queue<T> m_queue;
    std::condition_variable m_condvar;

public: 
    threadsafe_queue() = default;
    
    threadsafe_queue(const threadsafe_queue& other) {
        std::scoped_lock locker(other.m_mutex);
        m_queue = other.m_queue;
    }

    void push(T new_value) {
        std::lock_guard locker{m_mutex};
        m_queue.push(std::move(new_value));
        m_condvar.notify_one();
    }

    std::shared_ptr<T> wait_and_pop() {
        std::unique_lock locker{m_mutex};

        m_condvar.wait(locker, [this]{ return !m_queue.empty(); });
        
        auto element{std::make_shared<T>(data_queue.front())};
        m_queue.pop();

        return element;
    }

    std::shared_ptr<T> try_pop() {
        std::lock_guard locker{m_mutex};
        
        if (m_queue.empty())
            return std::nullopt;
            
        auto element{std::make_shared<T>(data_queue.front())};
        m_queue.pop();

        return element;
    }

    bool empty() const {
        std::lock_guard locker{m_mutex};
        return m_queue.empty();
    }
};
```