## std::jthread 
With `std::thread` from C++11 exist two major problems:
1. Thread has to explicitly either be joined or detached. This also require some custom RAII wrapper to increase program safety. 
2. `std::threads` can't be interrupted after it's launched. Either manually add some cancel flag in function body (which require design how often check flag, how update - probably made flag `std::atomic` which brings some execution overhead, also might be cases when thread is stuck or cause deadlock since one thread reacted on break flag, while another didn't reach "checkpoint" and wait information from another thread or maybe `conditional variable` wake call to check state of cancel-flag)
Those issues taken into account in boost library, [boost::thread](https://www.boost.org/doc/libs/latest/doc/html/thread/thread_management.html#thread.thread_management.thread) and [boost::scoped_thread](https://www.boost.org/doc/libs/latest/doc/html/thread/ScopedThreads.html#thread.ScopedThreads.scoped_thread).

`std::jthread` represents an auto-joinable on object destruction `std::thread` (RAII-like) with stop request mechanism.

Stop-request mechanism is working with `std::stop_token` object which provide thread-safe way to check if a stop request has been made or can be made. `std::jthread` implicitly from it's `std::stop_source` object pass `std::stop_token` _as first argument_ of callable object, however if `std::stop_token` not declared in callable object argument -  there is no way to get access to that `std::stop_token`, simply meaning that `std::stop_token` and stop request will be ignored. `std::jthread` also have member function `{cpp}get_stop_token()` which can return it's `std::stop_token`

Typical use of stop request mechanism is add in callable object `std::stop_token` argument, check it's member function `{cpp}stop_requested()` and in `std::jthread` creator's thread either obtain `std::stop_marker` from created `std::jthread` object or use `std::jthread`'s member function `{cpp}request_stop()`
```cpp

void worker(const std::stop_token& st, const int startVal) {
	thread_local auto counter{startVal};
	while (true && !st.stop_requested()) { // true here redundant
		std::cout << ++counter << '\n';
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}
}

int main() {
	std::jthread t1(worker, 1);

	auto t1st = t1.get_stop_token();

	std::this_thread::sleep_for(std::chrono::milliseconds(300));
	if (t1st.stop_possible())
		t1.request_stop();
}
```

`std::stop_token` also can be used to register `std::stop_callback` - RAII object type that registers a callback function, which will be executed in thread which made `{cpp}stop_request()` (there still small "or" - in case of race condition if stop has already been requested before `std::stop_callback` constructor execution - the callback is invoked in the thread constructing the `stop_callback` from constructor). 
```cpp
std::println("Main thread: {}", std::this_thread::get_id());

std::jthread worker([](const std::stop_token &st) {
	std::println("Worker thread: {}", std::this_thread::get_id());

	std::atomic<unsigned> counter{0};
	std::stop_callback callback(st, [&counter] {
		std::println("Stop requested from {} at count:{}", std::this_thread::get_id(), counter.load());
	});

	while (!st.stop_requested()) {
		std::println("{}", ++counter);
		std::this_thread::sleep_for(100ms);
	}
});
std::this_thread::sleep_for(300ms);
worker.request_stop();
	
/* Possible output
Main thread: 140019825661824
Worker thread: 140019815675584
1
2
3
Stop requested from 140019825661824 at count:3
*/
```

Another part of stop mechanism - is `std::stop_source`.  `std::stop_source` object is actually what initiate `std::stop_request`, from `std::stop_source` we can get `std::stop_token` and pass it to multiple threads. 
```cpp
std::stop_source source;
std::stop_token token = source.get_token();

std::jthread worker1([token]() {
    while (!token.stop_requested()) { ... }
});

std::jthread worker2([token]() {
    while (!token.stop_requested()) { ... }
});

std::jthread worker3([token]() {
    while (!token.stop_requested()) { ... }
});

// One request will stop all workers 
source.request_stop();
```

## Coroutines
*Routines* - a reusable block of code that performs a specific, well-defined task.There are two types of routines: subroutines and coroutines. 

_Subroutines_ - Is a named routines, usually a function, that have a clear, hierarchical control flow. When any function (including `{cpp}main()`) executed, function get corresponding stack frame (which contains arguments of function, local variables etc). When from function we execute another function - it's stack frame set on top of execution stack of caller function, which will be popped when function execution finished, meaning that caller function execution blocked until callee function not finished. 
There are two stages in  subroutines - _Invoke_ - when function call initialized and _Finalize_ - where resource deallocation happen.

_Coroutines_ - similar to subroutines, but with addition of two stage - _suspend_ and _resume_. When coroutine object is initialized - it's in suspended state and should be explicitly resumed for execution. Coroutens constructed in heap (instead a stack for subroutines). When from caller function corutine execution resumed - it creates frame copy on caller stack. When execution suspended, heap frame will be updated and the temporary stack frame popped from the caller stack. 

Copying stack frame can be from performance perspective more efficient that context switching. 

A coroutine consist of 3 parts
+ _A promise object_ - manipulated from the coroutine and used to deliver result via this object. This object is not the same as `std::promise` and is defined based on the developer defined `promise_type` type.  
+ _Handle object_ - non-owning handle which used to resume or destroy coroutine frame from outside
+ _Coroutine state_ - is an internal, typically heap-allocated state which contains promise object, argument to coroutine, suspension points,  local variables etc. 

To use corutines we need to define handle object, promise. In most cases it will use similar boilerplate. 
> According to claude, C++ committee decided to provide in STL only low-level building blocks and abstractions should be provided by libraries. Already exists libraries [cppcoro](https://github.com/lewissbaker/cppcoro), [boost.cobalt](https://www.boost.org/doc/libs/latest/libs/cobalt/doc/html/index.html), [Facebook libunifex(experimental)](https://github.com/facebookexperimental/libunifex), [Facebook folly's coro (experemental)](https://github.com/facebook/folly/tree/main/folly/experimental/coro) etc. 
```cpp
// Handle type
struct foo_handle {
	struct promise_type;
	using co_handle = std::coroutine_handle<promise_type>;

	explicit foo_handle(const co_handle handle) : handle_(handle) { assert(handle); }
	~foo_handle() { handle_.destroy(); }

	void resume() { handle_.resume(); }
private:
	co_handle handle_;
};

// Promise
struct foo_handle::promise_type {
	using co_handle = std::coroutine_handle<promise_type>;

	auto get_return_object() { return foo_handle{co_handle::from_promise(*this)}; }
	auto initial_suspend() { return std::suspend_always(); }
	auto final_suspend() noexcept { return std::suspend_always(); }
	void return_void() {}
	void unhandled_exception() { std::terminate(); }
};

foo_handle foo() {
	std::println("a");
	co_await std::suspend_always();
	std::println("b");
	co_await std::suspend_always();
	std::println("c");
	co_await std::suspend_always();
}

int main() {
	foo_handle f = foo();
	f.resume();
	f.resume();
	f.resume();

	return 0;
}
```

```cpp title:"Lazy generator"
template<typename T>
struct LazyArrayGen {
	struct promise_type {
		auto get_return_object() { return LazyArrayGen{std::coroutine_handle<promise_type>::from_promise(*this)}; }
		auto initial_suspend() { return std::suspend_always(); }
		auto final_suspend() noexcept { return std::suspend_always(); }
		void return_void() {}
		void unhandled_exception() { std::terminate(); }
		auto yield_value(const T value) {
			current_value = value;
			return std::suspend_always();
		}
		T current_value;
	};
	using co_handle = std::coroutine_handle<promise_type>;

	explicit LazyArrayGen(const co_handle handle) : handle_(handle) { }
	~LazyArrayGen() { handle_.destroy(); }

	T getValue() { return handle_.promise().current_value; }
	bool next() { handle_.resume(); return !handle_.done(); }
private:
	co_handle handle_;
};

template<typename T>
LazyArrayGen<T> co_gen(T start = 0, T step = 1) noexcept {
	auto value = start;
	while (true) {
		co_yield value;
		value += step;
	}
}

int main() {
	LazyArrayGen<int> gen = co_gen(10, 5);
	for (int i = 0; i <= 10; ++i) {
		gen.next();
		std::cout << " " << gen.getValue();
	}

	return 0;
}
```

## Barriers
Latches and barriers are thread coordination mechanisms that allow any number of threads to block until an expected number of threads arrive. When all threads reached latch or barrier, they all will be unblocked almost at the same time. 
A `std::latch` cannot be reused, while a `std::barrier` can be used repeatedly.

Constructor of `std::barrier` takes number of expected threads to block on barrier and optional completion function object to be called on phase completion step.
Inside thread we have several member functions to manipulate barrier's expected  value: 
+ `{cpp}arrival_token arrive(std::ptrdiff_t n = 1);` - create `arrival_token` and then, decrements the expected count by n
+ `{cpp}void wait(arrival_token&& arrival)` - blocks at the synchronization point associated with `arrival` until the phase completion step of the synchronization point's phase is run. 
+ `{cpp}void arrive_and_wait()` - decrements the expected count by 1, then blocks at the synchronization point for the current phase until the phase completion step
+ `{cpp}void arrive_and_drop()` - decrements the initial expected count for all subsequent phases by one, and then decrements the expected count for the current phase by one. 

```cpp
const auto workers = {"Anil", "Busara", "Carl"};

auto on_completion = [] {
	thread_local auto phase = "... done\n Cleaning up...\n";
	std::cout << phase;
	phase = "... done\n";
};

std::barrier sync_point(std::ssize(workers), on_completion);

auto work = [&sync_point](const std::string& name) {
	std::string product = "  " + name + " worked\n";
	std::osyncstream(std::cout) << product;  // atomic call
	sync_point.arrive_and_wait();

	product = "  " + name + " cleaned\n";
	std::osyncstream(std::cout) << product;
	sync_point.arrive_and_wait();
};

std::cout << "Starting...\n";
std::vector<std::jthread> threads;

for (auto const& worker : workers)
	threads.emplace_back(work, worker);
```

`std::latch` constructor takes only number of expected threads. Following member function available: 
+ `{cpp}void count_down(std::ptrdiff_t n = 1)` - decrements the internal counter by n without blocking the caller
+ `{cpp}bool try_wait()` - test the counter, returns `true` only if the counter has reached zero, but function doesn't block execution
+ `{cpp}void wait()` - blocks the calling thread until the internal counter reaches ​0​. If it is zero already, returns immediately.  
+ `{cpp}void arrive_and_wait(std::ptrdiff_t n = 1)` - decrements the internal counter by n and (if necessary) blocks the calling thread until the counter reaches zero

## Other C++20 topics not mentioned in course 
+ [std::atomic_wait](https://en.cppreference.com/w/cpp/atomic/atomic_wait.html)
+ [std::atomic_notify](https://en.cppreference.com/w/cpp/atomic/atomic_notify_one.html)/[std::atomic_notify_one](https://en.cppreference.com/w/cpp/atomic/atomic_notify_one.html)/[std::atomic_notify_all](https://en.cppreference.com/w/cpp/atomic/atomic_notify_all.html)
+ [std::atomic_flag_test](https://en.cppreference.com/w/cpp/atomic/atomic_flag_test.html)/[std::atomic_flag_wait](https://en.cppreference.com/w/cpp/atomic/atomic_flag_wait.html)/[std::atomic_flag_notify_one](https://en.cppreference.com/w/cpp/atomic/atomic_flag_notify_one.html)/[std::atomic_flag_notify_all](https://en.cppreference.com/w/cpp/atomic/atomic_flag_notify_all.html)
+ [std::atomic_init](https://en.cppreference.com/w/cpp/atomic/atomic_init.html)
+ [std::counting_semaphore](https://en.cppreference.com/w/cpp/thread/counting_semaphore.html)/[std::counting_semaphore](https://en.cppreference.com/w/cpp/thread/counting_semaphore.html)
+ 