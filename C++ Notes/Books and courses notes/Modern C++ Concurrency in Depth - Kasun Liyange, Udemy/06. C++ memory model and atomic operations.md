## Atomic
Atomic operation is an indivisible operation that cannot be observed half-done from any thread in the system. 

Some C++ operations are non-atomic and can be executed in several machine instructions. For example, `i++` typically involves three steps: read the value of `i`; increment that value by one; store the modified value. In multi-threaded code, this leads to a race condition where two threads might read the same initial value and the final result is an increment by 1 instead of 2.

Atomic objects are free of data races, which allows the creation of lock-free data structures and algorithms. Atomicity may be achieved either via _lock-free CPU instructions_ (hardware-based) or via internal locks (software-based, e.g., a mutex) provided by the C++ library implementation on the given platform. The C++ standard allows for atomic types to be _sometimes_ lock-free. The following functions and constants check the lock-free status:
- `{cpp}bool std::atomic_is_lock_free(const std::atomic<T>*)` - non-member function which determines if the atomic object is implemented lock-free.
- `{cpp}bool is_lock_free() const noexcept` - member function of `std::atomic` class.
- `{cpp}static constexpr bool is_always_lock_free` _(C++17)_ - static member constant equals `true` if this specialization of `std::atomic` is guaranteed to be lock-free on all target platforms, and `false` otherwise.

STL provides both the template class, e.g., `{cpp}std::atomic<int>`, and typedef versions for most built-in types, e.g., `{cpp}std::atomic_int`.

`std::atomic` does not have copy or move assignment/construction. Atomics can be stored in containers using `{cpp}emplace()` for in-place construction, and their values can be copied using explicit atomic operations, e.g., `{cpp}a1.store(a2.load())`, or copied (loaded) into a non-atomic variable. References and pointers to atomic objects can be used.

### Atomic flag
`std::atomic_flag` is the most basic atomic type, representing a simple boolean flag. It is typically initialized with `{cpp}ATOMIC_FLAG_INIT` for _static storage duration objects_, and is guaranteed to be initialized to clear (`false`). `std::atomic_flag` is _guarantee lock-free_ implementation. Compared to `std::atomic_bool`, it has a limited interface, lacking simple `{cpp}load()` and `{cpp}store()`.

`std::atomic_flag` provide following interface: 
+ `{cpp}void clear(std::memory_order order = std::memory_order_seq_cst)` - set value to `false` 
+ `{cpp}bool test_and_set(std::memory_order order = std::memory_order_seq_cst)` which set value to `true` and return previous state. 
+ (_from C++20_)
	+ `{cpp}bool test(std::memory_order order = std::memory_order_seq_cst)` - return current value 
	+ `{cpp}void wait(bool old, std::memory_order order = std::memory_order_seq_cst)` - compare current value with `old` and block execution until current value not changed to different from `old`. Thread can be unblocked via notification functions or via spurious wake-up, yet execution will continue when value changed (similarly to conditional variable with `{cpp}cv.wait(lock, []{ return condition; });)
	+ `{cpp}void notify_one()`/`{cpp}void notify_all()` - performs atomic notifying operations


### Atomic objects
`std::atomic<T>` objects initialization _is not atomic_. For initialization used non-atomic value. 
_Prior to C++20_, the default constructor left the object uninitialized (except for static/thread-local objects, which were zero-initialized); non-static objects needed non-atomic initialization via `{cpp}std::atomic_init`. 
_Since C++20_, the default constructor performs value-initialization (`T()`), and `{cpp}std::atomic_init` has been deprecated.

`{cpp} std::atomic<T>` class provide next interface for interacting with atomic objects:
+ `{cpp}void store(T desired, std::memory_order order = std::memory_order_seq_cst)` - atomically replace the current value with desired. 
+ `{cpp}T load(std::memory_order order = std::memory_order_seq_cst)` - atomically loads and return the current value
+ `{cpp}operator T()` - conversion operator, equivalent to `{cpp}load()`. 
+ `{cpp}T exchange(T desired, std::memory_order order = std::memory_order_seq_cst)` - atomically replace the underlying value with desired and return atomic variable before the call. 
+ `{cpp}bool compare_exchange_weak(T& expected, T desired, std::memory_order success, std::memory_order failure)`
	`{cpp}bool compare_exchange_weak(T& expected, T desired, std::memory_order order = std::memory_order_seq_cst)`
	`{cpp}bool compare_exchange_strong(T& expected, T desired, std::memory_order success, std::memory_order failure)`
	`{cpp}bool compare_exchange_strong(T& expected, T desired, std::memory_order order = std::memory_order_seq_cst)` - atomically compares values with `expected`, if those are bitwise-equal, replaces the former with `desired`, otherwise, loads the actual stored value into `expected`. Return `true` if store is performed. `_weak` is susceptible to spurious failures (returning `false` even if the comparison succeeded), often due to loop-based CPU instructions that might be interrupted. It's typically used in a loop. `_strong` on the other hand might use extra instructions to guarantee compare exchange, which affect performance. 

For `std::atomic<T*>` atomic is a pointer - doesn't mean that objects pointed to is atomic, but pointer it self is atomic. 

For integral, floating point (since _C++20_) and atomic pointers (for atomic pointers used `std::ptrdiff_t arg` function argument) there are additional member functions: 
+ `{cpp}T fetch_add(T arg, std::memory_order order = std::memory_order_seq_cst);` - replaces the current value with the result of arithmetic addition of the value and `arg`.  Return previous value. 
+ `{cpp}T fetch_sub(T arg, std::memory_order order = std::memory_order_seq_cst);` - replaces the current value with the result of arithmetic subtraction of the value and `arg`.  Return previous value. 
+ `{cpp}T operator+=(T arg)`/`{cpp}T operator-=(T arg)` - equivalent to `{cpp}return fetch_add(arg) + arg`

For integral and pointers also available atomic pre-increment, post-increment, pre-decrement and post-decrement. (Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for atomic types do not return a reference to the modified object. They return a copy of the stored value instead). From _C++26_ also expected `{cpp}T fetch_max(T arg, std::memory_order order = std::memory_order_seq_cst)` and `{cpp}T fetch_min(T arg, std::memory_order order = std::memory_order_seq_cst)` - atomically replaces the current value with the result of `std::max`/`std::minn` of the value and `arg`.

For integral only - `{cpp}T fetch_and(T arg, std::memory_order order = std::memory_order_seq_cst)`/`{cpp}T fetch_or(T arg, std::memory_order order = std::memory_order_seq_cst)`/`{cpp}T fetch_xor(T arg, std::memory_order order = std::memory_order_seq_cst)` - atomic boolean operations. And `{cpp}T operator&=(T arg)`/`{cpp}T operator|=(T arg)`/`{cpp}T operator^=(T arg)` - equivalent of `{cpp}return fetch_and(arg) & arg`/`{cpp}return fetch_or(arg) | arg`/`{cpp}return fetch_xor(arg) ^ arg` respectfully. 

For user-defined types (`T` in `std::atomic<T>`) to be used, they must satisfy strict requirements, primarily:
1. `T` must be _Trivially Copyable_.
2. `T` must be _bitwise equality comparable_. (This often implies that `T` is also a Standard Layout Type for compatibility and proper memory alignment, although the C++ standard focuses on Trivially Copyable and Trivial Copy-Assignment).
