#virtual 
Виртуальные методы если вкратце - позволяют переопределять методы в базовом классе. 

Предположим у нас есть такой код:
```c++
class Entity
{
public:
    std::string GetName(){return "Entity";}
};

class Player : public Entity
{
    std::string GetName(){return "Player";}
}

void PrintName (Entity* entity) 
{
    std::cout << entity->GetName()<<std::endl;
}

void main()
{
    Entity* e = new Entity();
    PrintName(e);
    
    Player* p = new Player ();
    PrintName(e);
    
    Entity* entity = p;
    PrintName (entity);
}
```

Вывод приложения будет `Entity; Player; Entity`. Логично было бы получиться в `PrintName(entity)` - `Player`, так как мы сказали, что `enitity = p`. Проблема решается добавлением `virtual` - при вызове функции вызывается не первый попавшийся метод класса (что будет родительский), а будет сперва по таблице виртуальных методов проверено - если ли у дочерних классов переопределение функции, а после - вызвана "последняя" функция. 

В наследуемых классах так же можно использовать ключевое слово `override`, чтобы показать , что данная функция - является переопределением некой существующей виртуальной функции - поможет явно понять, что это за функция просто взглянув на ее сигнатуру и избежать ошибки в духе не совпадающего имени или если функция не обозначена как виртуальная, а мы пытаемся ее переопределить. 
```c++
class Entity
{
public:
   virtual std::string GetName(){return "Entity";}
};

class Player : public Entity
{
    std::string Getname() override {return "Player";}
    //             ^ - такой функции нет в базовом классе
}
```
При использовании виртуальных функций мы приносим в жертву память, так как создается таблица виртуальных методов, а так же жертвуем время на то, чтобы проверить эту таблицу виртуальных методов в описке корректного метода.