По своей природе - это просто обертка над обычными указателями, которые слегка упрощаю жизнь с удалением памяти из `heap`, которая создается оператором `new`

## unique pointer
Удаляются после выхода за пределы `scope`. Unqiue так называются по той причине, что они должны быть уникальными. Нельзя их копировать (как объяснение - если копировать unique pointer - он будет скопирован в unique pointer, оба указателям будут указывать в одно место и при удалении по одному из указателю - второй указатель будет указывать в освобожденную память, и... бессмысленно )
`std::unique_ptr <Entity> entity(new Entity());`
Конструктор у unique pointer `explicit`, поэтому оператор `=` работать не будет.
 Хорошо так же объявлении использовать `std::make_unique` для безопасности от исключений и небольшой подстраховки от утечки памяти. 
 `std::unique_ptr<Entity> entity = std::make_unique<Entity>();`
 Недостаток - отсутствие возможности копировать, а значит и не получится "поделиться" указателем, к примеру, передать в другую функцию. 

## Shared pointer
Позволяет выполнить копирование указателей. Реализация зависит от компилятор, но в основном используется подсчет референсов. Как только счетчик референсов подходит к нулю - указатель удаляется.
`std::shared_ptr<Entity?> entity = std::make_shared<Entity>();`
Использование без `std::make_shared` так же возможно, но если в `uniqite pointer` можно столкнуться с исключениями, когда в `shared pointer`  выделяется специальный "контролируемый" блок памяти с счетчиком отсылок и при создании через оператор `new` и использовании `shared pointer` конструктора происходит два выделения памяти: сперва выделяется память для класса, а после `shared pointer`  выделяется контролируемый блок.
```c++
{
	std::shared_ptr<Entity> e0;
	{
		std::shared_ptr<Entity> entity = std::make_shared<Entity>();
		c0 = entity;
	}
	// в e0 все еще будет указатель на класс
}
// e0 вышел за Scope, указатель и класс уничтожен
```

## Weak pointer
При копировании `weak pointer` не увеличивается счетчик отсылок. По сути `weak pointer` не продлевает жизнь\забирает право владения над указателем.
```c++
{
	std::weak_ptr<Entity> e0;
	{
		std::shared_ptr<Entity> entity = std::make_shared<Entity>();
		e0 = entity;
	}
	// Класс уничтожен
}
```