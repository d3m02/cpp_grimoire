Основная суть в том, что в `Stack` объект уничтожаются после выхода из `Scope`, когда в `Heap` – остаются, пока не будут удалены вручную. По этой причине, если в функции создается переменная, которая помещается в `Stack` и указатель на эту переменную возвратить – после выхода их функции переменная будет уничтожена и по указателю будет уже «не валидные» данные.
```c++
int* CreateArray()
{
    int array[50];
    return array;
}

int* a = CreateArray();
```
Но эту особенность можно использовать и для создания собственного «умного» указателя, к примеру, если надо, чтоб созданный в `Heap` класс удалялся после выхода из `Scope` -  для этого делается класс, который принимает в конструкторе указатель на уничтожаемый класс, в деструктор помещается освобождение памяти и класс-указатель при инициализации помещается в `Stack`. 
```c++
class Entity 
{
    Entity () { cout<<"Created"<<endl; }
    ~Entity() { cout<<"Destroyed"<<endl; }
};

class ScoopedPtr 
{
public:
    ScopedPtr(Entity* ptr) : m_Ptr(ptr){}
    ~ScopedPtr(){ delete m_Ptr; }
private:
	Entity* m_Ptr;
};

Entity e; // In Stack
Entity* e = new Entity(); // In Heap

ScopedPtr e = new Entity(); // In "Heap", but destroyed out of scope
```
Использование «new Entity()» возможно за счет не явного преобразования?
