## Указатели
Указатели - это адреса какой-то ячейки памяти. С точки зрения памяти, нам все равно на типы данных, типы данных просто "выдумка", чтоб было проще работать с памятью (конкретно - сколько байт памяти нужно использовать и как интерпретировать: как положительное\\отрицательное дробное\\целочисленное значение или как символ\\набор символов).  Для указателей тип данных еще больше не важен, указатель - просто число, которое означает адрес в памяти. Если указателю дать тип, то мы говорим, что данные по адресу, которые находятся по указателю - <i><u>предположительно</u></i> такого то типа. Можно так же отметить, что изменение типа указателя никак не поменяет сам указатель (как и в целом не поменяет данные по указателю). 
`void* ptr = 0 \ NULL \ nullptr ` - чистый указатель
`&` - взять адрес переменой: `void* ptr = &var;`
`*` перед указателем - разименовать указатель (т.е. получить данные). 
`int var = *ptr;`
Если у указателя есть тип - то можно так же и записать данные по указателю `*ptr = 10;`, однако если тип void - нельзя записать т.к. не ясно, сколько байт использовать для записи. 

Размер указателя зависит от разрядности системы:
*  x32 = 4 байта (что примерно как `int` \\ `float`) 
* x64 = 8 байт (примерно как `long long` \\ `double`)
Размер можно проверить 
```c++
int* x = new int(1);
std::cout << sizeof(x) << std::endl;
```
Именно из-за размера не рекомендуется передать в функции указатели на базовые типы (т.е. если выполняется копия - дешевле будет скопировать любой базовый класс, чем скопировать указатель)
\
## Ссылка 
Фактически, ссылка -  это синтаксический сахар вокруг указателя. Принцип работы компилятора с ссылкой и указателем фактически одинаков. 
Ссылка может ссылаться только на существующую переменную. А значит, ссылке нельзя дать значение NULL, она должна иметь валидную ссылку ена существующую переменную. По сути, ссылки не занимают памяти (т.к. они по сути не существуют в памяти и являются alias)
Ссылка создается указанием `&` после типа данных. Важно, что `&` - часть названия типа. 
```c++
int a = 5;
int& ref = a;
``` 

Ссылки часто используются вместе с функциями когда нужно какую-то переменную использовать в функции. Если написать `void func(int a)` - мы создадим новую копию `a` и скопируем в нее значение переменной, которую передаем - при выходе из функции `a` удалится. Используя `void func (int& a)` - мы изменим "внешнюю" переменную, сохранив изменения после выхода из функции. Так же удобно использовать ссылки, если переменная никак не меняется в функции - так можно избежать излишнее выделение памяти `void func (const int& a)`
Тоже самое справедливо и для указателей, так как ссылки и указатели работают в одном ключе. Отличие в том, что при работе с указателем можно немного запутаться с передачей адреса и разыменованием 
```c++
void fun (int* a) { (*a)++;} // Из-за приоритета действий – без скобочек мы сперва инкрементируем адрес, а потом сделаем разыменование.

int b = 5;
fun (&b);

/=====

void fun (int& a) { a++; }   // Из-за приоритета действий – без скобочек бы сперва инкрементируем адрес, а потом сделаем разыменование.

int b = 5;
fun (b);
```

## CPP con, [Understanding Value Categories](https://youtu.be/XS2JddPq7GQ?si=4kFEI9E0ObZ74FqO&t=1128)
Ссылка по сути указатель, которая автоматически разыменовывается каждый раз когда ее используют

| Reference         | pointer                                                              |
| ----------------- | -------------------------------------------------------------------- |
| `int %ri = i;`    | `int* const cpi = &i` <br>(`const int*` - будет иметь другой эффект) |
| `ri = 4;`         | `*cpi = 4;`                                                          |
| `int j = ri + 2;` | `int j = *cpi + 2;`                                                  |
Ссылки позволяют более удобные интерфейсы функций и упрощает перегрузку. 
К примеру, если требуется сделать перегрузку `void operator++`

| `void operator++(Month x) { x = static_cast<Mont>(x + 1); }`    | локальная копия и перегрузка не изменит переданную переменную.                                                                                                                        |
| --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `void operator++(Month *x) { *x = static_cast<Mont>(*x + 1); }` | не компилируется, перегрузки не могут принимать; <br><br>если предположить что компилируется:<br>++month // не компилируется <br>++&month // выглядит странно и не компилируется <br> |
| `month& operator++(Month& x) { x = static_cast<Mont>(x + 1); }` | Работает как надо, как бонус - не принимают rvalue:<br>++Apr; // ошибка компиляции                                                                                                    |
