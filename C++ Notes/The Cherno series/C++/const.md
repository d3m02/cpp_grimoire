#const 
## Переменные 
`const` по факту просто синтаксическое украшение, которым мы "даем обещания", что переменная не будет меняться, но фактически с точки зрения компилятора - оно ничего не меняет. Как `const` удобно  помечать вещи, котоыре не стоит менять, чтоб в случае чего - компилятор мог дать предупреждение\\ошибку.

Пример "нарушения обещания"
```c++
const int MAX_AGE = 90;
int* a = new int;
*a = (int*)%MAX_AGE;
```
(по сути тут C - пример const_cast)

Однако компилятор может заменить переменную `MAX_AGE` на 90 где она используется, сделав ее константой (т.е. без расположения в памяти) и такое действие может привести к ошибкам. 

## Особенности с указателями
С указателями от расположения const (слева или справа от `*` ) меняется и эффект:
+ `const int* a = new int;`   - Нельзя изменить содержимое указателя, при этом можно изменить адрес в указателе
+ `int* const a = new int`;  - Можно изменить контекст, но нельзя адрес

## Функции 
+ Если после скобок - нельзя менять поля класса 
```c++
class Entity
{
public:
	int GetX(int y) const // - Не изменяет поля класса
    {
        y++;          // Однако можем менять аргументы
        //m_X++;      // Ошибка
        return m_X;
    }
private:
	int m_X;
};
```
+ Если перед скобками - менять возвращаемое значение (но это довольно редкий и странный случай)
```c++
class Entity
{
public:
    const int& GetCx()
    {
        return m_X;
    }
private:
	int m_X;
};

int main()
{
    Entity e;
    e.GetCx() = 20; // ошибка
}
```
 (бонус )
 ```c++
class Entity
{
public:
    const int* const GetPx() const
    {
        // возвращаем указатель, которые нельзя изменить
        // нельзя изменить содержимое на которое указывает
        // функцие нельзя менять членов класса.
        return m_pX;
    }
private:
    int* m_pX;
};
```
