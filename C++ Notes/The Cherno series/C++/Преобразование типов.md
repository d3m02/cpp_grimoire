`C Style` касты ( в виде `(int)f`), `C++ Style` касты - `static\dynamic\const\reinterpret_cast<int>(f)`

По сути, `C style` касты могут выполнить все то, что делают `C++ style` касты. По большей части `C++` касты просто синтаксическое украшение, разве что `dynamic_cast` может выполнять проверку и возвращать `null`, что экстра-действие и может замедлять программу. 
Полезность в том, что при поиске каста, C++ стиль имеет слова, отражающие выполняемые действия, что упрощает поиск в коде и избегать возможные ошибки, но это добавляет лишние проверки, что снижает производительность. Плюс дает небольшое разграничение и безопасность:
+ `const_cast` только отбрасывает  `const`/`volatile` (но при этом не меняет память и изменение переменной по переменной, к которой привели другую переменную - неопределенное поведение)  или добавляет `const` 
+ `dynamic_cast` использует систему `Runtime type information`, в случае неправильного приведения типов вызывается исключение `std::bad_cast,` для указателей будет возвращён `null`. Позволяет безопасно сделать upcast/downcast из одного класса в другой
+ `static_cast` преобразует выражение статического типа в объект и значения другого статического типа. Проверка производиться на уровне компиляции. Нельзя
	+  Преобразование битового представления данных [[Type punning]]
	+  Преобразование между несвязанными типами: (`static_cast` не может выполнять преобразования между типами, которые не имеют никакой логической связи друг с другом. Например, преобразование указателя на `int` в указатель на `double` невозможно с использованием `static_cast`.)
	```c++
int* intPtr = nullptr;
uintptr_t intVal = static_cast<uintptr_t>(intPtr); // Ошибка компиляции
```
	+ Преобразование между указателями на функции разных типов (`static_cast` не позволяет преобразовывать указатели на функции одного типа в указатели на функции другого типа.)
```c++
void (*funcPtr)();
int (*intFuncPtr)() = static_cast<int(*)()>(funcPtr); // Ошибка компиляции
```

+ `reinterpret_cast` - опасный зверь, который фактически делает [[Type punning]]. Более безопасно использовать [[Union]]. Так же позволяет делать то, что нельзя с `static_cast`
```c++
// Преобразование между указателями на разные типы:
int* intPtr = nullptr;
double* doublePtr = reinterpret_cast<double*>(intPtr);

// Преобразование указателя в целое число и обратно:
int* intPtr = nullptr;
uintptr_t intVal = reinterpret_cast<uintptr_t>(intPtr);
int* newIntPtr = reinterpret_cast<int*>(intVal);

// Преобразование между указателями на функции разных типов:
void (*funcPtr)();
int (*intFuncPtr)() = reinterpret_cast<int(*)()>(funcPtr);

// Type punning:
int a = 0x41424344;
double b = reinterpret_cast<double&>(a);

```
